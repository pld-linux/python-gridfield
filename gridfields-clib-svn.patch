diff -Nur -x .svn tag/gridfieldsclib-0.7/ChangeLog gridfields/clib/ChangeLog
--- tag/gridfieldsclib-0.7/ChangeLog	2012-02-13 17:47:11.000000000 +0100
+++ gridfields/clib/ChangeLog	2014-05-16 22:59:45.900055090 +0200
@@ -0,0 +1,178 @@
+2014-04-04  jgallagher@opendap.org
+
+	Removed warnings except for cast-align, deprecated and
+	sign-compare which seem like more work.
+
+2014-04-04  jgallagher@opendap.org
+
+	svn ignores
+
+2014-04-04  jgallagher@opendap.org
+
+	Changed from using a header named config.h to config_gridfields.h
+	so that it can be used by library headers that are installed
+	without causing too much grief for other packages. Ideally this
+	header would not be installed or used by any of the library's
+	headers...
+
+	M    CmdLine.cpp
+	M    Makefile.am
+	M    NEWS
+	M    configure.ac
+	M    src/access.h
+	M    src/accumulate.cc
+	M    src/accumulate.h
+	M    src/aggregate.cc
+	M    src/aggregate.h
+	M    src/aggregations.cc
+	M    src/apply.cc
+	M    src/apply.h
+	M    src/array.cc
+	M    src/array.h
+	M    src/arrayreader.cc
+	M    src/arrayreader.h
+	M    src/arraywriter.cc
+	M    src/assignments.cc
+	M    src/bind.cc
+	M    src/bindconstant.cc
+	M    src/cell.cc
+	M    src/cellarray.cc
+	M    src/cellarray.h
+	M    src/constarray.cc
+	M    src/cross.cc
+	M    src/datadump.cc
+	M    src/dataset.cc
+	M    src/elcircfile.cc
+	M    src/elio.c
+	M    src/expr.cc
+	M    src/fparser.cc
+	M    src/grid.cc
+	M    src/grid.h
+	M    src/gridfield.cc
+	M    src/gridfieldoperator.cc
+	M    src/implicit0cells.cc
+	M    src/merge.cc
+	M    src/netcdfadaptor.cc
+	M    src/output.cc
+	M    src/outputtuples.cc
+	M    src/project.cc
+	M    src/project.h
+	M    src/rankeddataset.cc
+	M    src/refrestrict.cc
+	M    src/restrict.cc
+	M    src/scaninternal.cc
+	M    src/sift.cc
+	M    src/timing.cc
+	M    src/tonetcdf.cc
+	M    src/tuple.cc
+	M    src/type.cc
+	M    src/unarynodemap.cc
+	M    src/util.cc
+	M    src/util.h
+
+2014-02-13  jgallagher@opendap.org
+
+	Updates for C++-11. See NEWS. I bumbed the version to 1.0.2.
+
+	M    Makefile.am
+	M    NEWS
+	M    configure.ac
+	M    src/accumulate.h
+	M    src/aggregate.h
+	M    src/apply.h
+	M    src/array.cc
+	M    src/cell.cc
+	M    src/cellarray.cc
+	M    src/cellarray.h
+	M    src/expr.cc
+	M    src/expr.h
+	M    src/grid.cc
+	M    src/grid.h
+	M    src/implicit0cells.cc
+	M    src/normnodemap.h
+	M    src/project.h
+
+2012-12-11  jgallagher@opendap.org
+
+	Added a --disable-netcdf option. This lets us build the library
+	and use it with run-time loaded modules, some of which also use
+	netcdf, without conflicts due to different versions of the
+	library.
+
+	M    configure.ac
+	M    INSTALL
+	M    NEWS
+	M    README
+
+2012-10-29  jgallagher@opendap.org
+
+	Fixed syntax errors on lines with both libnetcdf and libnetcdf++.
+
+	M    conf/netcdf.m4
+
+2012-10-26  jgallagher@opendap.org
+
+	Some fixes for distcheck - it's closer now but still not there yet. And
+	Fixes for elio.c where fprintf() was called using mis-matched format
+	control chars and srguments.
+
+	M    tests/Makefile.am
+	M    src/elio.c
+	M    Makefile.am
+
+2012-10-26  jgallagher@opendap.org
+
+	Fixes so that the dist target builds a good distribution.
+
+	D    tests/Makefile.in
+	D    tests/Makefile
+	M    tests/Makefile.am
+	M    Makefile.am
+
+2012-08-16  smeest1@gmail.com
+
+	updated Makefile.am
+
+2012-08-10  smeest1@gmail.com
+
+	fixed cell array
+
+2012-08-10  smeest1@gmail.com
+
+	fixed array.cc
+
+2012-08-09  smeest1@gmail.com
+
+	updated clib
+
+2012-08-09  smeest1@gmail.com
+
+	added triangulate.h
+
+2012-08-09  smeest1@gmail.com
+
+	added triangulate.cc
+
+2012-08-09  smeest1@gmail.com
+
+	added remesh.h
+
+2012-08-09  smeest1@gmail.com
+
+	added remesh.cc
+
+2012-08-09  billhowe
+
+	added tests
+
+2012-08-09  billhowe
+
+	Attempting to commit namespace changes
+
+2012-04-09  smeest1@gmail.com
+
+	added new stuff to tags and trunk
+
+;; Local Variables:
+;; coding: utf-8
+;; End:
diff -Nur -x .svn tag/gridfieldsclib-0.7/CmdLine.cpp gridfields/clib/CmdLine.cpp
--- tag/gridfieldsclib-0.7/CmdLine.cpp	2012-02-13 17:47:11.000000000 +0100
+++ gridfields/clib/CmdLine.cpp	2014-05-16 22:59:45.903388424 +0200
@@ -81,7 +81,7 @@
          cmd.m_strings.push_back(arg);
 
          // add the CCmdParam to 'this'
-         pair<CCmdLine::iterator, bool> res = insert(CCmdLine::value_type(curParam, cmd));
+         // Unused. jhrg 4/4/14 pair<CCmdLine::iterator, bool> res = insert(CCmdLine::value_type(curParam, cmd));
 
       }
       else
diff -Nur -x .svn tag/gridfieldsclib-0.7/conf/netcdf.m4 gridfields/clib/conf/netcdf.m4
--- tag/gridfieldsclib-0.7/conf/netcdf.m4	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/conf/netcdf.m4	2014-05-16 22:56:56.463391955 +0200
@@ -56,7 +56,7 @@
   AC_PATH_PROG([NC_CONFIG], [nc-config], [no])
 	if test "$NC_CONFIG" != "no" ; then
 		nc_ready=yes
-		NC_LIBS="`$NC_CONFIG --libs` -lnetcdf_c++"
+		NC_LIBS="`$NC_CONFIG --libs` -lnetcdf_c++ -lnetcdf"
 		NC_CPPFLAGS="`$NC_CONFIG --cflags`"
 		NC_LDFLAGS="`$NC_CONFIG --cflags`"
 		NC_VERSION="`$NC_CONFIG --version`"
@@ -121,11 +121,11 @@
             NC_LDFLAGS="-L$ac_netcdf_libdir"
           ])
         LDFLAGS="$LDFLAGS $NC_LDFLAGS"
-        LIBS="$LIBS-lnetcdf_c++- lnetcdf"
+        LIBS="$LIBS-lnetcdf_c++ -lnetcdf"
 dnl we have to avoid the autoconf internal cache in that case
         AC_LINK_IFELSE([AC_LANG_CALL([],[$ac_check_nc_func_checked])],
           [
-            NC_LIBS='-lnetcdf_c++- lnetcdf'
+            NC_LIBS='-lnetcdf_c++ -lnetcdf'
             ac_netcdf_ok='yes'
             AS_IF([test "z$ac_netcdf_libdir" != 'z'],[AC_MSG_RESULT([yes])])
           ],
diff -Nur -x .svn tag/gridfieldsclib-0.7/configure.ac gridfields/clib/configure.ac
--- tag/gridfieldsclib-0.7/configure.ac	2012-02-13 17:47:11.000000000 +0100
+++ gridfields/clib/configure.ac	2014-05-16 22:59:46.443388412 +0200
@@ -2,9 +2,13 @@
 # Process this file with autoconf to produce a configure script.
 
 AC_PREREQ([2.68])
-AC_INIT([gridfields], [1.0.0], [Bill Howe <billhowe@cs.washington.edu>])
+AC_INIT([gridfields], [1.0.3], [Bill Howe <billhowe@cs.washington.edu>])
 AC_CONFIG_SRCDIR([src/abstractcellarray.h])
-AM_CONFIG_HEADER([config.h])
+# This has to be named specially since it's included in headers that
+# are installed. The config header defines compile-time switches that 
+# select between older (deprecated) versions of hash map and C++'s new
+# unordered_map. jhrg 4/4/14
+AM_CONFIG_HEADER([config_gridfields.h])
 
 # This provides a place to keep all the autotools stuff (m4 files, etc.)
 AC_CONFIG_AUX_DIR(conf)
@@ -32,30 +36,22 @@
 AC_PROG_LIBTOOL
 
 dnl echo "CC = $CC"
-if test "$CC" = "g++"
+if test "$CC" = "g++" -o "$CC" == "gcc"
 then
     AM_CONDITIONAL([COMPILER_IS_GCC],[true])
 else
     AM_CONDITIONAL([COMPILER_IS_GCC],[false])
 fi
 
-# Checks for libraries.
-# These appear to be used by test code
-# FIXME: Replace `main' with a function in `-lefence':
-# AC_CHECK_LIB([efence], [main])
-# FIXME: Replace `main' with a function in `-lnetcdf':
-# AC_CHECK_LIB([netcdf], [main])
-# FIXME: Replace `main' with a function in `-lvtkCommon':
-# AC_CHECK_LIB([vtkCommon], [main])
-# FIXME: Replace `main' with a function in `-lvtkFiltering':
-# AC_CHECK_LIB([vtkFiltering], [main])
-# FIXME: Replace `main' with a function in `-lvtkIO':
-# AC_CHECK_LIB([vtkIO], [main])
-# FIXME: Replace `main' with a function in `-lvtkRendering':
-# AC_CHECK_LIB([vtkRendering], [main])
-# FIXME: Replace `main' with a function in `-lwayne':
-# AC_CHECK_LIB([wayne], [main])
+AC_ARG_ENABLE([netcdf], [AS_HELP_STRING([--enable/disable-netcdf],
+					[use netcdf (default is yes)])], [], [])
+# $enable_netcdf will be 'no' if --disable-netcdf is used, 'yes' if
+# --enable-netcdf is used and '' if neither is used
 
+netcdf_found_ac=false
+
+if test -z "$enable_netcdf" -o "$enable_netcdf" = "yes"
+then
 AC_CHECK_NETCDF(
    [
    LIBS="$LIBS $NC_LIBS"
@@ -67,10 +63,10 @@
    echo "*** Use --with-netcdf for the root netcdf directory."
    echo "*** Otherwise use --with-netcdf-include switch for includes directory"
    echo "*** and --with-netcdf-libdir switch for libraries directory."
-   netcdf_found_ac=false
    AC_MSG_WARN([netcdf library and netcdf headers not found.])
    ],[3]
 )
+fi
 
 AM_CONDITIONAL([NETCDF_FOUND], [$netcdf_found_ac])
 
@@ -97,6 +93,51 @@
 
 # Checks for typedefs, structures, and compiler characteristics.
 AC_HEADER_STDBOOL
+
+AC_LANG_PUSH([C++])
+dnl # Do the checks for C++ headers
+
+# <functional> is not needed...
+# AC_HEADER_TR1_FUNCTIONAL
+
+# Look for the old versions, then the new ones and use them in roughly
+# that order. It seems that older compiers include the tr1 or standard
+# headers but they don't always work. It might be that explicitly using 
+# C++ 2011 is needed to get the  standard headers.
+AC_CHECK_HEADER(ext/hash_map, [AC_DEFINE([HAVE_EXT_HASH_MAP],[],["Have ext"])
+                                    have_ext_hash_map="yes"
+				    AC_MSG_WARN([Found ext/hash map])], [], [])
+                                    
+AC_CHECK_HEADER(tr1/unordered_map, [AC_DEFINE([HAVE_TR1_UNORDERED_MAP],[],["Have tr1"])
+                                    have_tr1_unordered_map="yes"
+				    AC_MSG_WARN([Found tr1/unordered map])], [], [])
+                                    
+AC_CHECK_HEADER(unordered_map, [AC_DEFINE([HAVE_UNORDERED_MAP],[],["Have C++0x"])
+                                have_unordered_map="yes"
+				AC_MSG_WARN([Found plain unordered map])], [], [])
+
+AC_LANG_POP([C++])
+
+# These AC_DEFINE calls set values used by a 'glue' header. See 
+# gridfields_hash_map.h.in
+if test "x$have_unordered_map" == "xyes"
+then
+    AC_SUBST([GF_UNORDERED_MAP_HEADER], ["<unordered_map>"])
+    AC_SUBST([GF_HASH_MAP], ["std::unordered_map"])
+elif test "x$have_ext_hash_map" == "xyes"
+then
+    AC_SUBST([GF_UNORDERED_MAP_HEADER], ["<ext/hash_map>"])
+    AC_SUBST([GF_HASH_MAP], ["hash_map"])
+    AC_SUBST([GF_HASH_MAP_NAMESPACE], ["namespace GF { using namespace __gnu_cxx; }"])
+    AC_SUBST([GF_USE_REHASH], ["#define USE_HASH_MAP_RESIZE"])
+elif test "x$have_tr1_unordered_map" == "xyes"
+then
+    AC_SUBST([GF_UNORDERED_MAP_HEADER], ["<tr1/unordered_map>"])
+    AC_SUBST([GF_HASH_MAP], ["std::tr1::unordered_map"])
+else
+    AC_MSG_ERROR([Could not find a suitable 'unordered map' c++ class.])
+fi
+
 AC_C_INLINE
 AC_TYPE_OFF_T
 AC_C_RESTRICT
@@ -110,5 +151,8 @@
 AC_FUNC_STRTOD
 AC_CHECK_FUNCS([floor gettimeofday pow putenv sqrt strtol])
 
-AC_CONFIG_FILES([Makefile tests/Makefile])
+AC_CONFIG_FILES([Makefile src/gridfields_hash_map.h])
+AC_CONFIG_FILES([gridfields-config], [chmod 755 gridfields-config])
+AC_CONFIG_FILES([tests/Makefile tests/testarrayreader.cc \
+		 tests/testcross.cc tests/testbind.cc tests/testoutput.cc])
 AC_OUTPUT
diff -Nur -x .svn tag/gridfieldsclib-0.7/gridfields-config.in gridfields/clib/gridfields-config.in
--- tag/gridfieldsclib-0.7/gridfields-config.in	1970-01-01 01:00:00.000000000 +0100
+++ gridfields/clib/gridfields-config.in	2014-05-16 22:56:56.463391955 +0200
@@ -0,0 +1,83 @@
+#! /bin/sh
+#
+# Borrowed the idea for this script (and some code) from libcurl.
+#
+prefix=@prefix@
+exec_prefix=${prefix}
+libdir=${exec_prefix}/lib
+libdir64=${exec_prefix}/lib64
+includedir=${prefix}/include
+
+usage()
+{
+    cat <<EOF
+Usage: dap-config [OPTION]
+
+Available values for OPTION include:
+
+  --help      	display this help message and exit
+  --cc        	C compiler
+  --cxx       	C++ compiler
+  --cflags    	pre-processor and compiler flags
+  --libs      	library linking information for libdap (both clients and servers)
+  --server-libs libraries for servers
+  --client-libs libraries for clients
+  --prefix    	OPeNDAP install prefix
+  --version   	Library version
+EOF
+
+    exit $1
+}
+
+if test $# -eq 0; then
+    usage 1
+fi
+
+while test $# -gt 0; do
+    case "$1" in
+    # this deals with options in the style
+    # --option=value and extracts the value part
+    # [not currently used]
+    -*=*) value=`echo "$1" | sed 's/[-_a-zA-Z0-9]*=//'` ;;
+    *) value= ;;
+    esac
+
+    case "$1" in
+    --help)
+	usage 0
+	;;
+
+    --cc)
+	echo "@CC@"
+	;;
+
+    --cxx)
+	echo "@CXX@"
+	;;
+
+    --cflags)
+	echo "-I${includedir}/libgridfields"
+	;;
+
+    --libs)
+       	echo "-L${libdir64} -L${libdir} -lgridfields @LIBS@"
+        ;;
+
+    --prefix)
+       	echo "${prefix}"
+       	;;
+
+    --version)
+	echo "gridfields @PACKAGE_VERSION@"
+	;;
+
+    *)
+        echo "unknown option: $1"
+	usage
+	exit 1
+	;;
+    esac
+    shift
+done
+
+exit 0
diff -Nur -x .svn tag/gridfieldsclib-0.7/gridfields.spec gridfields/clib/gridfields.spec
--- tag/gridfieldsclib-0.7/gridfields.spec	1970-01-01 01:00:00.000000000 +0100
+++ gridfields/clib/gridfields.spec	2014-05-16 22:59:46.443388412 +0200
@@ -0,0 +1,55 @@
+Name:		gridfields
+Version:	1.0.3
+Release:	1%{?dist}
+Summary:	The Gridfield library implements an algreba for irregular meshes.
+
+Group:		Development/Libraries
+License:	LGPLv2+
+URL:		http://www.opendap.org/
+Source0:	http://www.opendap.org/pub/source/gridfields-%{version}.tar.gz
+
+BuildRoot:  %{_tmppath}/%{name}-%{version}-%{release}-root-%(%{__id_u} -n)
+
+%description
+Written by Bill Howe. Packaged by James Gallagher.
+
+%package devel
+Summary: Development and header files for teh gridfields library
+Group: Development/Libraries
+Requires: %{name} = %{version}-%{release}
+
+%description devel
+This package contains all the files needed to develop applications that
+will use libgridfields.
+
+%prep
+%setup -q
+
+%build
+%configure --disable-static --disable-dependency-tracking
+make %{?_smp_mflags}
+
+%install
+rm -rf $RPM_BUILD_ROOT
+make install DESTDIR=$RPM_BUILD_ROOT INSTALL="%{__install} -p"
+rm $RPM_BUILD_ROOT%{_libdir}/*.la
+
+%clean
+rm -rf $RPM_BUILD_ROOT
+
+%post -p /sbin/ldconfig
+
+%postun -p /sbin/ldconfig
+
+%files
+%defattr(-,root,root,-)
+%{_libdir}/libgridfields.so.*
+%doc README NEWS COPYING
+
+%files devel
+%defattr(-,root,root,-)
+%{_libdir}/libgridfields.so
+%{_includedir}/gridfields/
+%{_bindir}/gridfields-config
+
+%changelog
diff -Nur -x .svn tag/gridfieldsclib-0.7/Makefile.am gridfields/clib/Makefile.am
--- tag/gridfieldsclib-0.7/Makefile.am	2012-02-13 17:47:11.000000000 +0100
+++ gridfields/clib/Makefile.am	2014-05-16 22:59:46.446721746 +0200
@@ -9,19 +9,25 @@
 AM_CPPFLAGS = 
 AM_CXXFLAGS = 
 if COMPILER_IS_GCC
-AM_CXXFLAGS += -Wall -W -Wcast-align
+# jhrg 2/13/14
+# I got tired of the sign compare warnings, but they should be
+# addressed. jhrg 4/3/14
+AM_CXXFLAGS += -Wall -Wno-deprecated
+# -Wno-cast-align 
+# -Wno-deprecated 
+# -Wno-sign-compare
 endif
 
 # These are not used by automake but are often useful for certain types of
 # debugging. The best way to use these is to run configure as:
 #     export CXXFLAGS='...'; ./configure --disable-shared
 # the --disable-shared is not required, but it seems to help with debuggers.
-CXXFLAGS_DEBUG = -g3 -O0 -fno-defer-pop -Wall -W -Wcast-align -Werror
+CXXFLAGS_DEBUG = -g3 -O0 -Wall -Wcast-align
 TEST_COV_FLAGS = -ftest-coverage -fprofile-arcs
 
-SUBDIRS = tests 
+SUBDIRS = . tests 
 # vis
-DIST_SUBDIRS = tests
+# DIST_SUBDIRS = tests
 # vis
 
 # noinst_LTLIBRARIES = libparsers.la
@@ -29,7 +35,9 @@
 
 # bin_PROGRAMS =
 
-# BUILT_SOURCES = 
+BUILT_SOURCES = src/gridfields_hash_map.h
+
+bin_SCRIPTS = gridfields-config
 
 libgridfields_la_SOURCES = $(SRCS)
 libgridfields_la_LDFLAGS = -version-info $(LIBGF_VERSION)
@@ -37,11 +45,11 @@
 libgridfields_la_LIBADD = 
 
 # really?
-pkginclude_HEADERS = src/$(HDRS)
+pkginclude_HEADERS = $(HDRS)
 
-noinst_HEADERS = config.h
+# noinst_HEADERS = config.h
 
-# EXTRA_DIST = 
+EXTRA_DIST = gridfields.spec NEWS README INSTALL COPYING
 
 # At some point write a m4 macro that can be used to test for the
 # gridfields library; same for pkg config
@@ -58,39 +66,43 @@
 
 # MAINTAINERCLEANFILE
 
-SRCS = CmdLine.cpp src/accumulate.cc src/aggregate.cc src/aggregations.cc src/apply.cc	\
-src/array.cc src/arrayreader.cc src/arraywriter.cc src/assignments.cc src/bind.cc		\
-src/bindconstant.cc src/cell.cc src/cellarray.cc src/constarray.cc src/cross.cc		\
-src/datadump.cc src/dataset.cc src/elcircfile.cc src/elio.c src/expr.cc src/fparser.cc src/grid.cc	\
-src/gridfield.cc src/gridfieldoperator.cc src/implicit0cells.cc 		\
-src/merge.cc src/output.cc src/outputtuples.cc src/project.cc		\
-src/rankeddataset.cc src/refrestrict.cc src/restrict.cc src/scaninternal.cc src/sift.cc	\
-src/timing.cc src/tuple.cc src/type.cc src/unarynodemap.cc	\
-src/util.cc 
+SRCS = CmdLine.cpp src/accumulate.cc src/aggregate.cc			\
+src/aggregations.cc src/apply.cc src/array.cc src/arrayreader.cc	\
+src/arraywriter.cc src/assignments.cc src/bind.cc src/bindconstant.cc	\
+src/cell.cc src/cellarray.cc src/constarray.cc src/cross.cc		\
+src/datadump.cc src/dataset.cc src/elcircfile.cc src/elio.c		\
+src/expr.cc src/fparser.cc src/grid.cc src/gridfield.cc			\
+src/gridfieldoperator.cc src/implicit0cells.cc src/merge.cc		\
+src/output.cc src/outputtuples.cc src/project.cc src/rankeddataset.cc	\
+src/refrestrict.cc src/restrict.cc src/scaninternal.cc src/sift.cc	\
+src/timing.cc src/tuple.cc src/type.cc src/unarynodemap.cc src/util.cc
 
 if NETCDF_FOUND
 SRCS += src/tonetcdf.cc src/netcdfadaptor.cc 
 endif
 
-HDRS = CmdLine.h src/RTree.h src/abstractcellarray.h src/access.h src/accumulate.h	\
-src/aggregate.h src/aggregations.h src/apply.h src/array.h src/arrayreader.h src/arraywriter.h	\
-src/assignments.h src/binarynodemap.h src/bind.h src/bindconstant.h src/cell.h src/cellarray.h	\
-config.h src/constarray.h src/counted_ptr.h src/cross.h src/crossnodemap.h		\
-src/crossordmap.h src/datadump.h src/dataset.h src/elcircfile.h src/elio.h src/expr.h src/grid.h	\
-src/gridfield.h src/gridfieldoperator.h src/idnodemap.h src/idordmap.h			\
-src/implicit0cells.h src/implicitcrossnodemap.h src/leftnodemap.h src/merge.h		\
-src/nodemap.h src/normnodemap.h src/object.h src/onegrid.h src/ordmap.h	\
-src/output.h src/outputtuples.h src/partition.h src/project.h src/rankeddataset.h		\
-src/refrestrict.h src/restrict.h src/scan.h src/scaninternal.h src/sift.h		\
-src/subgridordmap.h src/timing.h src/tuple.h src/type.h src/unarynodemap.h	\
-src/util.h
+HDRS = config_gridfields.h src/CmdLine.h src/RTree.h			\
+src/abstractcellarray.h src/access.h src/accumulate.h src/aggregate.h	\
+src/aggregations.h src/apply.h src/array.h src/arrayreader.h		\
+src/arraywriter.h src/assignments.h src/binarynodemap.h src/bind.h	\
+src/bindconstant.h src/cell.h src/cellarray.h src/constarray.h		\
+src/counted_ptr.h src/cross.h src/crossnodemap.h src/crossordmap.h	\
+src/datadump.h src/dataset.h src/elcircfile.h src/elio.h src/expr.h	\
+src/fparser.hh src/fptypes.hh src/fpconfig.hh src/grid.h		\
+src/gridfield.h src/gridfieldoperator.h src/idnodemap.h src/idordmap.h	\
+src/implicit0cells.h src/implicitcrossnodemap.h src/leftnodemap.h	\
+src/merge.h src/nodemap.h src/normnodemap.h src/object.h src/onegrid.h	\
+src/ordmap.h src/output.h src/outputtuples.h src/partition.h		\
+src/project.h src/rankeddataset.h src/refrestrict.h src/restrict.h	\
+src/scan.h src/scaninternal.h src/sift.h src/subgridordmap.h		\
+src/timing.h src/tuple.h src/type.h src/unarynodemap.h src/util.h   \
+src/gridfields_hash_map.h
 
 if NETCDF_FOUND
 HDRS += src/tonetcdf.h src/netcdfadaptor.h
 endif
 
 OLD_REMOVED_SRCS = stuebe.cc
-
 OLD_REMOVED_HDRS = stuebe.h
 
 ###########################################################################
@@ -103,6 +115,20 @@
 	doxygen $(srcdir)/doxy.conf
 	(cd docs && tar -czf html.tar.gz html)
 
+###########################################################################
+
+# Fortify targets.
+
+.PHONY: fortify
+fortify:
+	sourceanalyzer -b @PACKAGE@ $(MAKE)
+	sourceanalyzer -b @PACKAGE@ -scan -f @PACKAGE@-@PACKAGE_VERSION@.fpr
+
+# Use this to clean the fortify project.
+.PHONY: fortifyclean
+fortifyclean:
+	sourceanalyzer -b @PACKAGE@ -clean
+
 # cccc computes metrics like Lines of code and McCabe. It'a available
 # on the web...
 .PHONY: cccc
@@ -166,8 +192,8 @@
 	(cd test-coverage; \
          cov_dat="coverage-data-`date +%m.%d.%y`"; \
          touch $$cov_dat; \
-         for f in $(ALLSRCS); do \
+         for f in $(libgridfields_la_SOURCES); do \
             echo "\n*** Coverage data for $$f ***\n" >> $$cov_dat; \
-            gcov -l -o ../ $$f >> $$cov_dat; \
+            gcov -a -o ../ $$f >> $$cov_dat; \
          done)
 
diff -Nur -x .svn tag/gridfieldsclib-0.7/NEWS gridfields/clib/NEWS
--- tag/gridfieldsclib-0.7/NEWS	2012-02-13 17:47:11.000000000 +0100
+++ gridfields/clib/NEWS	2014-05-16 22:59:46.446721746 +0200
@@ -1 +1,37 @@
-Version 1.0.0
+Version 1.0.3
+
+Fixed the warnings (many many) that were issued when code used this
+library. Because the library had headers that included the library's
+private 'config.h' header - and many other programs/libraries also
+have a similarly named header with the same symbols defined
+(differently), including that in an installed header often results in
+warnings. I fixed this by adding a special 'glue' header the defined
+just what was needed by the installed header and thus avoided
+including the config.h header in it.
+
+I fixed a number of other 'warning' problems.
+
+Fixed a bug in cellarray.cc where an iterator was used after it was 
+invalidated (by calling erase()).
+
+I removed useless includes of the <functional> header (aka
+<tr1/functional) and four instances if "config.h" in headers that are
+installed. Removed the test for tr1/functional in configure.ac.
+
+Version 1.0.2
+
+Updated a handful of files so that a C++-11 compiler won't gag. This
+mostly means adding a compiler check for tr1/functional or functional.
+There is still a problem with etc/hash_map versus the new
+unordered_map. I added a test for unordered_map and use it if
+available. It appears that unordered_map::rehash() is the same as
+hash_map::resize(). the Grid class is abstract but did not declare its
+destructor 'virtual'. All but one test pass and that test fails
+without these changes (testaggregate) with an odd message from the
+linking loader.
+
+Version 1.0.1
+
+Fixed configure.ac so it's possible to suppress building/linking with
+netCDF. To do this, use --disable-netcdf.
+
diff -Nur -x .svn tag/gridfieldsclib-0.7/README gridfields/clib/README
--- tag/gridfieldsclib-0.7/README	2012-02-13 17:47:11.000000000 +0100
+++ gridfields/clib/README	2014-05-16 22:59:45.906721757 +0200
@@ -1,20 +1,60 @@
 What is Gridfields?
 
-Scientists' ability to generate and store simulation results is outpacing their ability to analyze them via ad hoc programs. We observe that these programs exhibit an algebraic structure that can be used to facilitate reasoning and improve performance.
+Scientists' ability to generate and store simulation results is
+outpacing their ability to analyze them via ad hoc programs. We
+observe that these programs exhibit an algebraic structure that can be
+used to facilitate reasoning and improve performance.
 
 GridFields separate topology from data attributes
 
-In our work on GridFields, we present a formal data model that exposes this algebraic structure, then implement the model, evaluate it, and use it to express, optimize, and reason about data transformations in a variety of scientific domains.
-
-Simulation results are defined over a logical grid structure that allows a continuous domain to be represented discretely in the computer. Existing approaches for manipulating these gridded datasets are incomplete. The performance of SQL queries that manipulate large numeric datasets is not competitive with that of specialized tools, and the up-front effort required to deploy a relational database makes them unpopular for dynamic scientific applications. Tools for processing multidimensional arrays can only capture regular, rectilinear grids. Visualization libraries accommodate some forms of unstructured grid, but no algebra has been developed to organize the library of raw algorithms and afford optimization. Further, these libraries are data dependent---physical changes to data characteristics break user programs. 
-
-The GridFields library exposes 1) topological equivalences among gridded datasets and 2) logical equivalences among grid-oriented programs. These equivalences offer optimization opportunities and simplify programming.
-
-We adopt the grid as a first-class citizen, separating topology from geometry and separating structure from data. Our model is agnostic with respect to dimension, uniformly capturing, for example, particle trajectories (1-D), sea-surface temperatures (2-D), and blood flow in the heart (3-D). Equipped with data, a grid becomes a gridfield. We provide operators for constructing, transforming, and aggregating gridfields that admit algebraic laws useful for optimization. We implement the model by analyzing several candidate data structures and incorporating their best features. We then show how to deploy gridfields in practice by injecting the model as middleware between heterogeneous, ad hoc file formats and a popular visualization library.
-
-In this project, we define, develop, implement, evaluate and deploy a model of gridded datasets that accommodates a variety of complex grid structures and a variety of complex data products. We evaluate the applicability and performance of the model using datasets from oceanography, seismology, and medicine and conclude that our model-driven approach offers significant advantages over the status quo.
-
-Here at CMOP, we use GridFields to implement query services over ocean circulation model results, and we have added a GridFields plugin module for the VisTrails provenance and visualization system. 
+In our work on GridFields, we present a formal data model that exposes
+this algebraic structure, then implement the model, evaluate it, and
+use it to express, optimize, and reason about data transformations in
+a variety of scientific domains.
+
+Simulation results are defined over a logical grid structure that
+allows a continuous domain to be represented discretely in the
+computer. Existing approaches for manipulating these gridded datasets
+are incomplete. The performance of SQL queries that manipulate large
+numeric datasets is not competitive with that of specialized tools,
+and the up-front effort required to deploy a relational database makes
+them unpopular for dynamic scientific applications. Tools for
+processing multidimensional arrays can only capture regular,
+rectilinear grids. Visualization libraries accommodate some forms of
+unstructured grid, but no algebra has been developed to organize the
+library of raw algorithms and afford optimization. Further, these
+libraries are data dependent---physical changes to data
+characteristics break user programs.
+
+The GridFields library exposes 1) topological equivalences among
+gridded datasets and 2) logical equivalences among grid-oriented
+programs. These equivalences offer optimization opportunities and
+simplify programming.
+
+We adopt the grid as a first-class citizen, separating topology from
+geometry and separating structure from data. Our model is agnostic
+with respect to dimension, uniformly capturing, for example, particle
+trajectories (1-D), sea-surface temperatures (2-D), and blood flow in
+the heart (3-D). Equipped with data, a grid becomes a gridfield. We
+provide operators for constructing, transforming, and aggregating
+gridfields that admit algebraic laws useful for optimization. We
+implement the model by analyzing several candidate data structures and
+incorporating their best features. We then show how to deploy
+gridfields in practice by injecting the model as middleware between
+heterogeneous, ad hoc file formats and a popular visualization
+library.
+
+In this project, we define, develop, implement, evaluate and deploy a
+model of gridded datasets that accommodates a variety of complex grid
+structures and a variety of complex data products. We evaluate the
+applicability and performance of the model using datasets from
+oceanography, seismology, and medicine and conclude that our
+model-driven approach offers significant advantages over the status
+quo.
+
+Here at CMOP, we use GridFields to implement query services over ocean
+circulation model results, and we have added a GridFields plugin
+module for the VisTrails provenance and visualization system.
 
 
 Directory Structure:
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/abstractcellarray.h gridfields/clib/src/abstractcellarray.h
--- tag/gridfieldsclib-0.7/src/abstractcellarray.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/abstractcellarray.h	2014-05-16 22:57:00.733391866 +0200
@@ -1,5 +1,5 @@
 #ifndef _ABSTRACTCELLARRAY_H
-#define _ABSTRACTCELLARRAY_H 
+#define _ABSTRACTCELLARRAY_H
 
 #include <vector>
 #include <set>
@@ -8,52 +8,67 @@
 #include "util.h"
 #include "object.h"
 
-
-using namespace __gnu_cxx;
 using namespace std;
 
+namespace GF {
+
 class UnaryNodeMap;
 class CrossNodeMap;
 
-class AbstractCellArray : public Object {
- public:
-  
-  virtual idx getsize()=0;
-  virtual ~AbstractCellArray() {};
-
-  virtual int whoami()=0;
-
-  virtual Cell *getCell(idx i)=0;
-  virtual Cell getCellCopy(idx i)=0;
-  virtual Node *getCellNodes(idx i)=0;
-
-  virtual bool contains(const Cell &c)=0; 
-  virtual idx getOrd(const Cell &c)=0;
-  virtual idx getOrd(Node n)=0;
-  virtual unsigned int getNodeCount()=0;
-
-  virtual void getIncidentCells(Node n, set<CellId> &out)=0;
-  virtual void getIncidentCells(const Cell &c, set<CellId> &out)=0;
-  virtual void getAdjacentCells(CellId cid, vector<CellId> &out)=0;
-  
-  virtual void print(size_t indent)=0;
-  virtual void print()=0;
-
-  virtual void toNodeSet(set<Node> &outset)=0;
-  virtual CrossNodeMap makeCrossNodeMap(AbstractCellArray *other)=0;
-
-  virtual void mapNodes(UnaryNodeMap &h)=0;
-  bool implicit() { return false; };
-  virtual int bytes()=0;
-  
-  virtual AbstractCellArray *Intersection(AbstractCellArray *othercells)=0;
-  virtual AbstractCellArray *Cross(AbstractCellArray *othercells, CrossNodeMap &h)=0;
+class AbstractCellArray: public Object {
+public:
 
-  virtual void ref() { };
-  virtual void unref() { };
+	virtual idx getsize()=0;
+	virtual ~AbstractCellArray()
+	{
+	}
+	;
+
+	virtual int whoami()=0;
+
+	virtual Cell *getCell(idx i)=0;
+	virtual Cell getCellCopy(idx i)=0;
+	virtual Node *getCellNodes(idx i)=0;
+
+	virtual bool contains(const Cell &c)=0;
+	virtual idx getOrd(const Cell &c)=0;
+	virtual idx getOrd(Node n)=0;
+	virtual unsigned int getNodeCount()=0;
+
+	virtual void getIncidentCells(Node n, set<CellId> &out)=0;
+	virtual void getIncidentCells(const Cell &c, set<CellId> &out)=0;
+	virtual void getAdjacentCells(CellId cid, vector<CellId> &out)=0;
+
+	virtual void print(size_t indent)=0;
+	virtual void print()=0;
+
+	virtual void toNodeSet(set<Node> &outset)=0;
+	virtual CrossNodeMap makeCrossNodeMap(AbstractCellArray *other)=0;
+
+	virtual void mapNodes(UnaryNodeMap &h)=0;
+	bool implicit()
+	{
+		return false;
+	}
+	;
+	virtual int bytes()=0;
+
+	virtual AbstractCellArray *Intersection(AbstractCellArray *othercells)=0;
+	virtual AbstractCellArray *Cross(AbstractCellArray *othercells, CrossNodeMap &h)=0;
+
+	virtual void ref()
+	{
+	}
+	;
+	virtual void unref()
+	{
+	}
+	;
 
-  virtual void buildInvertedIndex()=0;
-  virtual vector<Cell> *getCellVector()=0;
+	virtual void buildInvertedIndex()=0;
+	virtual vector<Cell> *getCellVector()=0;
 };
 
-#endif 
+} // namespace GF
+
+#endif
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/access.h gridfields/clib/src/access.h
--- tag/gridfieldsclib-0.7/src/access.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/access.h	2014-05-16 22:57:00.763391866 +0200
@@ -4,160 +4,223 @@
 #include "object.h"
 #include "util.h"
 #include <fcntl.h>
+#include <stdlib.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/mman.h>
 
+namespace GF {
+
 typedef char Byte;
 
 template<class T>
 class DatumIterator {
- public:
-  typedef T Datum_t;
-  virtual void Open()=0;
-  virtual Datum_t Next()=0;
-  virtual bool Done()=0;
-  //virtual ~DatumIterator()=0;
+public:
+	typedef T Datum_t;
+	virtual void Open()=0;
+	virtual Datum_t Next()=0;
+	virtual bool Done()=0;
+	//virtual ~DatumIterator()=0;
+	virtual ~DatumIterator()
+	{
+	} // jhrg 4/8/14
 };
 
 template<class T>
-class CArrayIterator : public DatumIterator<T> {
-  public:
-    CArrayIterator(T *s, size_t sz) : source(s), size(sz), i(0) {};
-    void Open() {};
-    T Next() { return source[i++]; }
-    bool Done() { return (i>=size); }
-    
-  private:
-    T *source;
-    size_t size;
-    idx i;
+class CArrayIterator: public DatumIterator<T> {
+public:
+	CArrayIterator(T *s, size_t sz) :
+			source(s), size(sz), i(0)
+	{
+	}
+	;
+	void Open()
+	{
+	}
+	;
+	T Next()
+	{
+		return source[i++];
+	}
+	bool Done()
+	{
+		return (i >= size);
+	}
+
+private:
+	T *source;
+	size_t size;
+	idx i;
 };
 
 template<class T>
-class SliceIterator : public DatumIterator<T> {
-  public:
-    SliceIterator(DatumIterator<T> &b, idx start, idx stop, idx step=1) 
-       : _start(start), _step(step), _stop(stop), i(0), base(b) {};
-    
-    virtual void Open() {
-      base.Open();
-      for (int j=_start; j>0; j--) base.Next();
-    };
-     
-    virtual T Next() { 
-      T d = base.Next();
-      
-      // advance to just before first element
-      idx next = MIN(_start+i*_step, _stop);
-      for (int j=_step-1; j>0; j--) base.Next();
-      i++; 
-      return d;
-    };
-
-    virtual bool Done() {
-      return (_start + i*_step >= _stop) || (base.Done());
-    };
-
-  private:
-    idx _start, _step, _stop;
-    idx i;
-    DatumIterator<T> &base;
+class SliceIterator: public DatumIterator<T> {
+public:
+	SliceIterator(DatumIterator<T> &b, idx start, idx stop, idx step = 1) :
+			_start(start), _step(step), _stop(stop), i(0), base(b)
+	{
+	}
+	;
+
+	virtual void Open()
+	{
+		base.Open();
+		for (int j = _start; j > 0; j--)
+			base.Next();
+	}
+	;
+
+	virtual T Next()
+	{
+		T d = base.Next();
+
+		// advance to just before first element
+		// Unused. jhrg 4/4/14 idx next = MIN(_start+i*_step, _stop);
+		for (int j = _step - 1; j > 0; j--)
+			base.Next();
+		i++;
+		return d;
+	}
+	;
+
+	virtual bool Done()
+	{
+		return (_start + i * _step >= _stop) || (base.Done());
+	}
+	;
+
+private:
+	idx _start, _step, _stop;
+	idx i;
+	DatumIterator<T> &base;
 };
 
 template<class T>
-class PrimitiveIterator : public DatumIterator<T> {
-  public:
-    PrimitiveIterator(DatumIterator<Byte> &b) : base(b) {};
-  
-    void Open() { base.Open(); }
-
-    T Next() { 
-      for (int i=0; i<sizeof(T); i++) {
-        buf[i] = base.Next();
-      }
-      return *(T *) buf;
-    };
-    
-    bool Done() { return base.Done(); };
-    
-  private:
-    Byte buf[sizeof(T)]; 
-    DatumIterator<Byte> &base;
+class PrimitiveIterator: public DatumIterator<T> {
+public:
+	PrimitiveIterator(DatumIterator<Byte> &b) :
+			base(b)
+	{
+	}
+	;
+
+	void Open()
+	{
+		base.Open();
+	}
+
+	T Next()
+	{
+		for (int i = 0; i < sizeof(T); i++) {
+			buf[i] = base.Next();
+		}
+		return *(T *) buf;
+	}
+	;
+
+	bool Done()
+	{
+		return base.Done();
+	}
+	;
+
+private:
+	Byte buf[sizeof(T)];
+	DatumIterator<Byte> &base;
 };
 /*
-template
-class ProjectIterator : public DatumIterator<Byte *> {
-  public:
-    ProjectIterator(DatumIterator
-}
-*/
-
-class MMapIterator : public DatumIterator<Byte> {
-  public:
-    MMapIterator(const std::string &fname, int off, int len) 
-        : i(off), end(len), filename(fname) {};
-        
-    MMapIterator(const std::string &fname, int off=0) 
-        : i(off), end(-1), filename(fname) {}
-
-    void Open() { 
-
-      struct stat sbuf;
-      if ((fd = open(filename.c_str(), O_RDONLY)) == -1) {
-        perror("Open");
-        exit(1);
-      }
-
-      if (stat(filename.c_str(), &sbuf) == -1) {
-        perror("Stat");
-        exit(1);
-      }
-      
+ template
+ class ProjectIterator : public DatumIterator<Byte *> {
+ public:
+ ProjectIterator(DatumIterator
+ }
+ */
+
+class MMapIterator: public DatumIterator<Byte> {
+public:
+	MMapIterator(const std::string &fname, int off, int len) :
+			i(off), end(len), filename(fname)
+	{
+	}
+
+	MMapIterator(const std::string &fname, int off = 0) :
+			i(off), end(-1), filename(fname)
+	{
+	}
+
+	~MMapIterator()
+	{
+	}
+
+	void Open()
+	{
+
+		struct stat sbuf;
+		if ((fd = open(filename.c_str(), O_RDONLY)) == -1) {
+			perror("Open");
+			exit(1);
+		}
+
+		if (stat(filename.c_str(), &sbuf) == -1) {
+			perror("Stat");
+			exit(1);
+		}
+
 #if 0
-      // 'end' is unsigned. jhrg 10/5/11
-      if (end<0) end = sbuf.st_size;
+		// 'end' is unsigned. jhrg 10/5/11
+		if (end<0) end = sbuf.st_size;
 #endif
-      if ((data = (char *) mmap((caddr_t)0, sbuf.st_size, PROT_READ, MAP_SHARED, 
-                     fd, 0)) == (caddr_t)(-1)) {
-         perror("mmap");
-         exit(1);
-      }
-      
-    }
-    
-    void Advance(idx n) { i+=n; }
-    
-    Byte Next() { return data[i++]; }
-
-    bool Done() { return i>=end; }
-    
-  private:
-    idx i;
-    idx end;
-    const std::string filename;
-    int fd;
-    Byte *data;
+		if ((data = (char *) mmap((caddr_t) 0, sbuf.st_size, PROT_READ, MAP_SHARED, fd, 0)) == (caddr_t) (-1)) {
+			perror("mmap");
+			exit(1);
+		}
+
+	}
+
+	void Advance(idx n)
+	{
+		i += n;
+	}
+
+	Byte Next()
+	{
+		return data[i++];
+	}
+
+	bool Done()
+	{
+		return i >= end;
+	}
+
+private:
+	idx i;
+	idx end;
+	const std::string filename;
+	int fd;
+	Byte *data; // Assuming this is a weak pointer and should not be freed. jhrg 4/8/14
 };
 /*
-template<class T>
-class ElcircSurfIterator : public DatumIterator<T> {
-  public:
-    ElcircSurfIterator(MMapIterator mi, ElcircHeader &h) : hdr(h), rdr(mi) {};
-    void Open() { 
-      offset = this->h.hsize + timestep*this->h.ssize + sizeof(int) + sizeof(float);
-      end = 
-      rdr.Advance(offset);
-      // pi = new PrimitiveIterator<T>(rdr)
-    }
-
-    T Next() { return rdr.Next(); };
-    bool Done() { return (i>=end); }
-
-  private:
-    idx end,offset;  
-    ElcircHeader &hdr;
-    MMapIterator &rdr;
-}
-*/
+ template<class T>
+ class ElcircSurfIterator : public DatumIterator<T> {
+ public:
+ ElcircSurfIterator(MMapIterator mi, ElcircHeader &h) : hdr(h), rdr(mi) {};
+ void Open() {
+ offset = this->h.hsize + timestep*this->h.ssize + sizeof(int) + sizeof(float);
+ end =
+ rdr.Advance(offset);
+ // pi = new PrimitiveIterator<T>(rdr)
+ }
+
+ T Next() { return rdr.Next(); };
+ bool Done() { return (i>=end); }
+
+ private:
+ idx end,offset;
+ ElcircHeader &hdr;
+ MMapIterator &rdr;
+ }
+ */
+
+} // namespace GF
+
 #endif
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/accumulate.cc gridfields/clib/src/accumulate.cc
--- tag/gridfieldsclib-0.7/src/accumulate.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/accumulate.cc	2014-05-16 22:57:00.803391865 +0200
@@ -1,3 +1,5 @@
+#include "config_gridfields.h"
+
 #include "accumulate.h"
 #include "fparser.hh"
 #include "gridfield.h"
@@ -8,195 +10,188 @@
 #include <vector>
 #include <math.h>
 
-AccumulateOp::AccumulateOp(GridFieldOperator *op, Dim_t k,
-                           string acc,
-                           string ex,
-                           string sdex) 
-             : UnaryGridFieldOperator(op), position_offset(0), _k(k)
-{
-  this->PreviousOp = op;
-  this->_accumulator = acc;
-  this->unparsedExpr = ex;
-  this->seedExpr = sdex;
-  this->GF = NULL;
- // this->cleanup = false;
-} 
-
-void AccumulateOp::SetOffset(int off) {
-  this->position_offset = off;
-}
-
-void AccumulateOp::Execute() {
-  this->PrepareForExecution();
-  this->Result =  Accumulate(this->GF, this->_k,
-	                     this->_accumulator,
-                             this->unparsedExpr,
-                             this->seedExpr,
-                             this->position_offset);
-}
-
-
-GridField *AccumulateOp::Accumulate(GridField *Gg, Dim_t k,
-			  string accumulator,
-			  string expr,
-                          string seedexpr,
-                          int offset) {
-
-  FunctionParser fp;
-  FunctionParser seedfp;
-  expr = remove_whitespace(expr);
-  
-  vector<string> vars = getVars(expr);
-  vector<string> seedvars = getVars(seedexpr);
-  int card = Gg->Size(k);
-  
-  // check existence of the variables in the expression
-  for (unsigned int j=0; j<vars.size(); j++) {
-    if ( !Gg->IsAttribute(k, vars[j]) && 
-         !(vars[j] == accumulator)) {
-      Warning("Accumulate(%s): %s is not an attribute of this Gridfield.", 
-               expr.c_str(), vars[j].c_str());
-      Gg->GetScheme(k).print();
-      return Gg;
-    }
-  }
-
-  // check the seed expression
-  for (unsigned int j=0; j<seedvars.size(); j++) {
-    if ( !Gg->IsAttribute(k, seedvars[j])) {
-      Warning("Accumulate(%s): %s is not an attribute of this Gridfield.", 
-	      expr.c_str(), seedvars[j].c_str());
-      Gg->GetScheme(k).print();
-      return Gg;
-    }
-  }
-
-  // parse the expression
-  string varstr = getVarStr(vars);
-  if (fp.Parse(expr, varstr) != -1) {
-    Warning("Parse error: %s: '%s' \% (%s) ", 
-            fp.ErrorMsg(),
-	    expr.c_str(), 
-            varstr.c_str());
-    return Gg;
-  }
-
-  //parse the seed expression
-  string seedvarstr = getVarStr(seedvars);
-  if (seedfp.Parse(seedexpr, seedvarstr) != -1) {
-    Warning("Parse error: %s: %s", 
-	    seedexpr.c_str(), seedfp.ErrorMsg());
-    return Gg;
-  }
-  
-  // Evaluate the expression on the GF's attributes
-  double *varVals = new double[vars.size()];
-  double *seedVarVals = new double[seedvars.size()];
-  float *accumulated = new float[card];
-
-  //set the initial value of the new attribute
-  for (unsigned int j=0; j<seedvars.size(); j++) {
-    seedVarVals[j] = AccumulateOp::bindVar(Gg, k, vars[j], 0);
-  }
-
-  int start = MIN(card, MAX(-offset, 1));
-  int end = MIN(-offset+card, card);
-  
-  //set the first -<offset> values to the seed (if offset negative)
-  float seed = (float) seedfp.Eval(seedVarVals);
-  for (int i=0; i<start; i++) {
-    accumulated[i] = seed;
-  }
-
-  //set the last |offset| values to the seed (if offset positive)
-  for (int i=end; i<card; i++) {
-    accumulated[i] = seed;
-  }
-  
-  Scheme s = Gg->GetScheme(k);
-  //Tuple t(&s);
-  //set the rest of the values
-  for (int i=start; i<end; i++) {
-    //Gg->FastBindTuple(i, t);
-    
-    for (unsigned int j=0; j<vars.size(); j++) {
-      
-      if (vars[j] == accumulator) {
-        //previous accumulated value
-        varVals[j] = accumulated[i-1];
-      } else {
-        //regular value from the gridfield
-        varVals[j] = AccumulateOp::bindVar(Gg, k, vars[j], i+offset);
-      }
-      
-    }
-    accumulated[i] = (float) fp.Eval(varVals);
-  }
-  
-  //append the new attribute to the output gridfield
-  Array *arrResult = new Array(
-		 (const char *) accumulator.c_str(), FLOAT);
-  arrResult->copyFloatData(accumulated, card);
-  delete [] accumulated;
-  Gg->Bind(k, arrResult);
-  arrResult->unref();
-  Gg->ref();
-  return Gg;
-  
-}
-
-double AccumulateOp::bindVar(GridField *Gg, Dim_t k, string var, int i) {
-  //bind a variable to the ith value of the gridfield
-  //attribute with the same name
-  Scheme sch = Gg->GetScheme(k);
-  double val = 0;
-  if (sch.getType(var) == INT) {
-    val =  double(*(int *)
-                Gg->GetAttributeValue(k, var, i));
-  } else {
-    val =  double(*(float *)
-                Gg->GetAttributeValue(k, var, i));
-
-  }
-  return val;
-}
-string AccumulateOp::getVarStr(vector<string> varlist) {
-  if (varlist.size() == 0) return "";
-  string retval(varlist[0]);
-  for (size_t i=1; i<varlist.size(); i++) {
-    retval = retval + "," + varlist[i];
-  }
-  return retval;
-}
-
-string getVar(string &expr, size_t &i) {
-  string var = "";
-  while (isalpha(expr[i]) || expr[i] == '_' || isdigit(expr[i])) {
-    var = var + expr[i++];
-  }
-  return var;
-}
-
-vector<string> AccumulateOp::getVars(string expr) {
-  set<string> vars;
-  size_t i=0;
-
-  while (i<expr.length()) {
-    if (isalpha(expr[i])) {
-      vars.insert(getVar(expr, i));
-    } else if (expr[i] == '_') {
-          
-    }
-    i++;
-  }
-  
-  vector<string> retval(vars.size());
-  set<string>::iterator p;
-  
-  for (p=vars.begin(), i=0; p!=vars.end(); i++,p++) {
-    retval[i] = *p;
-  }
+namespace GF {
+
+AccumulateOp::AccumulateOp(GridFieldOperator *op, Dim_t k, string acc, string ex, string sdex) :
+		UnaryGridFieldOperator(op), position_offset(0), _k(k)
+{
+	this->PreviousOp = op;
+	this->_accumulator = acc;
+	this->unparsedExpr = ex;
+	this->seedExpr = sdex;
+	this->GF = NULL;
+	// this->cleanup = false;
+}
+
+void AccumulateOp::SetOffset(int off)
+{
+	this->position_offset = off;
+}
+
+void AccumulateOp::Execute()
+{
+	this->PrepareForExecution();
+	this->Result = Accumulate(this->GF, this->_k, this->_accumulator, this->unparsedExpr, this->seedExpr,
+			this->position_offset);
+}
+
+GridField *AccumulateOp::Accumulate(GridField *Gg, Dim_t k, string accumulator, string expr, string seedexpr,
+		int offset)
+{
+
+	FunctionParser fp;
+	FunctionParser seedfp;
+	expr = remove_whitespace(expr);
+
+	vector<string> vars = getVars(expr);
+	vector<string> seedvars = getVars(seedexpr);
+	int card = Gg->Size(k);
+
+	// check existence of the variables in the expression
+	for (unsigned int j = 0; j < vars.size(); j++) {
+		if (!Gg->IsAttribute(k, vars[j]) && !(vars[j] == accumulator)) {
+			Warning("Accumulate(%s): %s is not an attribute of this Gridfield.", expr.c_str(), vars[j].c_str());
+			Gg->GetScheme(k).print();
+			return Gg;
+		}
+	}
+
+	// check the seed expression
+	for (unsigned int j = 0; j < seedvars.size(); j++) {
+		if (!Gg->IsAttribute(k, seedvars[j])) {
+			Warning("Accumulate(%s): %s is not an attribute of this Gridfield.", expr.c_str(), seedvars[j].c_str());
+			Gg->GetScheme(k).print();
+			return Gg;
+		}
+	}
+
+	// parse the expression
+	string varstr = getVarStr(vars);
+	if (fp.Parse(expr, varstr) != -1) {
+		Warning("Parse error: %s: '%s' \% (%s) ", fp.ErrorMsg(), expr.c_str(), varstr.c_str());
+		return Gg;
+	}
+
+	//parse the seed expression
+	string seedvarstr = getVarStr(seedvars);
+	if (seedfp.Parse(seedexpr, seedvarstr) != -1) {
+		Warning("Parse error: %s: %s", seedexpr.c_str(), seedfp.ErrorMsg());
+		return Gg;
+	}
+
+	// Evaluate the expression on the GF's attributes
+	double *varVals = new double[vars.size()];
+	double *seedVarVals = new double[seedvars.size()];
+	float *accumulated = new float[card];
+
+	//set the initial value of the new attribute
+	for (unsigned int j = 0; j < seedvars.size(); j++) {
+		seedVarVals[j] = AccumulateOp::bindVar(Gg, k, vars[j], 0);
+	}
+
+	int start = MIN(card, MAX(-offset, 1));
+	int end = MIN(-offset+card, card);
+
+	//set the first -<offset> values to the seed (if offset negative)
+	float seed = (float) seedfp.Eval(seedVarVals);
+	for (int i = 0; i < start; i++) {
+		accumulated[i] = seed;
+	}
+
+	//set the last |offset| values to the seed (if offset positive)
+	for (int i = end; i < card; i++) {
+		accumulated[i] = seed;
+	}
+
+	Scheme s = Gg->GetScheme(k);
+	//Tuple t(&s);
+	//set the rest of the values
+	for (int i = start; i < end; i++) {
+		//Gg->FastBindTuple(i, t);
+
+		for (unsigned int j = 0; j < vars.size(); j++) {
+
+			if (vars[j] == accumulator) {
+				//previous accumulated value
+				varVals[j] = accumulated[i - 1];
+			}
+			else {
+				//regular value from the gridfield
+				varVals[j] = AccumulateOp::bindVar(Gg, k, vars[j], i + offset);
+			}
+
+		}
+		accumulated[i] = (float) fp.Eval(varVals);
+	}
+
+	//append the new attribute to the output gridfield
+	Array *arrResult = new Array((const char *) accumulator.c_str(), FLOAT);
+	arrResult->copyFloatData(accumulated, card);
+	delete[] accumulated;
+	Gg->Bind(k, arrResult);
+	arrResult->unref();
+	Gg->ref();
+	return Gg;
+
+}
+
+double AccumulateOp::bindVar(GridField *Gg, Dim_t k, string var, int i)
+{
+	//bind a variable to the ith value of the gridfield
+	//attribute with the same name
+	Scheme sch = Gg->GetScheme(k);
+	double val = 0;
+	if (sch.getType(var) == INT) {
+		val = double(*(int *) Gg->GetAttributeValue(k, var, i));
+	}
+	else {
+		val = double(*(float *) Gg->GetAttributeValue(k, var, i));
+
+	}
+	return val;
+}
+string AccumulateOp::getVarStr(vector<string> varlist)
+{
+	if (varlist.size() == 0) return "";
+	string retval(varlist[0]);
+	for (size_t i = 1; i < varlist.size(); i++) {
+		retval = retval + "," + varlist[i];
+	}
+	return retval;
+}
+
+string getVar(string &expr, size_t &i)
+{
+	string var = "";
+	while (isalpha(expr[i]) || expr[i] == '_' || isdigit(expr[i])) {
+		var = var + expr[i++];
+	}
+	return var;
+}
+
+vector<string> AccumulateOp::getVars(string expr)
+{
+	set<string> vars;
+	size_t i = 0;
+
+	while (i < expr.length()) {
+		if (isalpha(expr[i])) {
+			vars.insert(getVar(expr, i));
+		}
+		else if (expr[i] == '_') {
+
+		}
+		i++;
+	}
+
+	vector<string> retval(vars.size());
+	set<string>::iterator p;
+
+	for (p = vars.begin(), i = 0; p != vars.end(); i++, p++) {
+		retval[i] = *p;
+	}
 
-  return retval;
+	return retval;
 }
 
+} // namespace GF
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/accumulate.h gridfields/clib/src/accumulate.h
--- tag/gridfieldsclib-0.7/src/accumulate.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/accumulate.h	2014-05-16 22:57:00.810058531 +0200
@@ -4,38 +4,42 @@
 #include "gridfieldoperator.h"
 #include <string>
 #include <vector>
-#include <ext/functional>
+// #include <functional>
+// Replaced tr1 functional. Removed include of config.h in a header.
+// jhrg 4/3/14
+// #ifdef HAVE_TR1_FUNCTIONAL
+// #include <tr1/functional>
+// #endif
+// old code jhrg #include <ext/functional>
 #include "cell.h"
 
+namespace GF {
+
 class FunctionParser;
 class GridField;
 
-class AccumulateOp : public UnaryGridFieldOperator {
- public:
-  
-  AccumulateOp(GridFieldOperator *op, Dim_t k,
-               std::string acc,
-               std::string ex,
-               std::string sdex);
-
-  void Execute();
-  static GridField *Accumulate(GridField *Gg, Dim_t k,
-                               std::string resultname,
-                               std::string expr,
-                               std::string seedexpr,
-                               int offset);
-
- void SetOffset(int off);
- int position_offset;
- private:
-  Dim_t _k;
-  std::string unparsedExpr;
-  std::string _accumulator;
-  std::string seedExpr;
-
-  static std::vector<std::string> getVars(std::string expr);
-  static std::string getVarStr(std::vector<std::string> varlist);
-  static double bindVar(GridField *Gg, Dim_t k, std::string var, int i);
+class AccumulateOp: public UnaryGridFieldOperator {
+public:
+
+	AccumulateOp(GridFieldOperator *op, Dim_t k, std::string acc, std::string ex, std::string sdex);
+
+	void Execute();
+	static GridField *Accumulate(GridField *Gg, Dim_t k, std::string resultname, std::string expr, std::string seedexpr,
+			int offset);
+
+	void SetOffset(int off);
+	int position_offset;
+private:
+	Dim_t _k;
+	std::string unparsedExpr;
+	std::string _accumulator;
+	std::string seedExpr;
+
+	static std::vector<std::string> getVars(std::string expr);
+	static std::string getVarStr(std::vector<std::string> varlist);
+	static double bindVar(GridField *Gg, Dim_t k, std::string var, int i);
 };
 
+} // namespace GF
+
 #endif /* ACCUMULATE_H */
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/aggregate.cc gridfields/clib/src/aggregate.cc
--- tag/gridfieldsclib-0.7/src/aggregate.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/aggregate.cc	2014-05-16 22:57:00.753391866 +0200
@@ -1,109 +1,110 @@
+#include "config_gridfields.h"
+
 #include "aggregate.h"
 #include "timing.h"
 #include <math.h>
 #include "array.h"
 
-void debug_set(UnTypedPtr p) {
-  vector<Tuple *> *vec = (vector<Tuple *> *) p;
-  cout << "debug_set: " << vec << ", " << vec->size() << endl;
-  vector<Tuple *>::iterator i;
-  for (i=vec->begin(); i!=vec->end(); i++) {
-    (*i)->print();
-  }
+namespace GF {
+
+void debug_set(UnTypedPtr p)
+{
+	vector<Tuple *> *vec = (vector<Tuple *> *) p;
+	cout << "debug_set: " << vec << ", " << vec->size() << endl;
+	vector<Tuple *>::iterator i;
+	for (i = vec->begin(); i != vec->end(); i++) {
+		(*i)->print();
+	}
 }
 
-AggregateOp::AggregateOp(GridFieldOperator *T, Dim_t i,
-              AssignmentFunction *m,
-              AggregationFunction *f,
-              GridFieldOperator *S, Dim_t j) {
-  this->A = NULL;
-  this->B = NULL;
-  this->LeftOp = T;
-  this->RightOp = S;
-  this->_i = i;
-  this->_j = j;
-  this->m = m;
-  this->f = f;
+AggregateOp::AggregateOp(GridFieldOperator *T, Dim_t i, AssignmentFunction *m, AggregationFunction *f,
+		GridFieldOperator *S, Dim_t j)
+{
+	this->A = NULL;
+	this->B = NULL;
+	this->LeftOp = T;
+	this->RightOp = S;
+	this->_i = i;
+	this->_j = j;
+	this->m = m;
+	this->f = f;
 }
 
-void AggregateOp::Execute() {
-  this->PrepareForExecution();
-  Result =  Aggregate(this->A, 
-                      this->_i,
-     		      *this->m, 
-     		      *this->f, 
-		      this->B,
-                      this->_j);
+void AggregateOp::Execute()
+{
+	this->PrepareForExecution();
+	Result = Aggregate(this->A, this->_i, *this->m, *this->f, this->B, this->_j);
 }
 
-GridField *AggregateOp::Aggregate(GridField *Tt, Dim_t _i,
- 				  AssignmentFunction &m, 
- 				  AggregationFunction &f,
-				  GridField *Ss, Dim_t _j) {
-  Grid *T = Tt->GetGrid();
-  Grid *S = Ss->GetGrid();
-  int j;
-
-  string gname = newName(T->name, S->name);
-
-  GridField *Out;
-  Out = new GridField(Tt);
-  
-  Scheme *ssch = new Scheme(Ss->GetScheme(_j));
-  
-  f.setScheme(ssch);
-  
-  //allocate space for any new attributes being created.
-  Scheme *outscheme = f.getOutScheme();
-  //cout << "scheme: " << Tt->GetGrid()->Size(_i) << endl; 
-  Out->CoerceScheme(_i, outscheme, Tt->GetGrid()->Size(_i));
-  Scheme finalscheme = Out->GetScheme(_i);
-  
-  m.setEnvironment(Out, _i, Ss, _j);
-
-  vector<CellId> cs;
-  vector<Tuple> vs;
-
-  vector<Tuple>::iterator tp;
-  vector<CellId>::iterator cp;
-
-  //target tuple holder
-  Tuple t(&finalscheme);
-  //source tuple holder
-  Tuple s(ssch);
-  
-  const Dataset &ds = Out->GetDataset(_i);
-  const Dataset &sourceds = Ss->GetDataset(_j);
-  
-  for (size_t i=0; i<Out->Size(_i); i++) {
-    m(i, cs);
-
-    if (vs.size() != cs.size()) {
-      vs.resize(cs.size(), s);
-    }
-    
-    j=0;
-    FOR(vector<CellId>, c, cs) {
-      sourceds.FastBindTuple(*c, vs[j++]);
-    }
+GridField *AggregateOp::Aggregate(GridField *Tt, Dim_t _i, AssignmentFunction &m, AggregationFunction &f, GridField *Ss,
+		Dim_t _j)
+{
+	Grid *T = Tt->GetGrid();
+	Grid *S = Ss->GetGrid();
+	int j;
+
+	string gname = newName(T->name, S->name);
+
+	GridField *Out;
+	Out = new GridField(Tt);
+
+	Scheme *ssch = new Scheme(Ss->GetScheme(_j));
+
+	f.setScheme(ssch);
+
+	//allocate space for any new attributes being created.
+	Scheme *outscheme = f.getOutScheme();
+	//cout << "scheme: " << Tt->GetGrid()->Size(_i) << endl;
+	Out->CoerceScheme(_i, outscheme, Tt->GetGrid()->Size(_i));
+	Scheme finalscheme = Out->GetScheme(_i);
+
+	m.setEnvironment(Out, _i, Ss, _j);
+
+	vector<CellId> cs;
+	vector<Tuple> vs;
+
+	vector<Tuple>::iterator tp;
+	vector<CellId>::iterator cp;
+
+	//target tuple holder
+	Tuple t(&finalscheme);
+	//source tuple holder
+	Tuple s(ssch);
+
+	const Dataset &ds = Out->GetDataset(_i);
+	const Dataset &sourceds = Ss->GetDataset(_j);
+
+	for (size_t i = 0; i < Out->Size(_i); i++) {
+		m(i, cs);
+
+		if (vs.size() != cs.size()) {
+			vs.resize(cs.size(), s);
+		}
+
+		j = 0;
+		FOR(vector<CellId>, c, cs) {
+			sourceds.FastBindTuple(*c, vs[j++]);
+		}
 #if 0
-    Ss->BindTuples(cs, vs);
+		Ss->BindTuples(cs, vs);
 #endif
-    ds.FastBindTuple(i, t);
-    f(vs, t);
+		ds.FastBindTuple(i, t);
+		f(vs, t);
 #if 0
-    //t.print();
-    //getchar();
+		//t.print();
+		//getchar();
 #endif
-    cs.clear();
-  }
+		cs.clear();
+	}
 
-  return Out;
+	return Out;
 }
 
-string AggregateOp::newName(string Tname, string Sname) {
+string AggregateOp::newName(string Tname, string Sname)
+{
 
-  string gname = "a(" + Tname + ", " + Sname + ")";
-  return gname;
+	string gname = "a(" + Tname + ", " + Sname + ")";
+	return gname;
 }
 
+} // namespace GF
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/aggregate.h gridfields/clib/src/aggregate.h
--- tag/gridfieldsclib-0.7/src/aggregate.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/aggregate.h	2014-05-16 22:57:00.783391865 +0200
@@ -1,84 +1,101 @@
 #ifndef _AGGREGATE_H
 #define _AGGREGATE_H
 
+// #include "config.h"
+
 #include <iostream>
+//#include <functional>
 #include "tuple.h"
 #include "gridfield.h"
 #include "gridfieldoperator.h"
-#include <ext/functional>
+// #ifdef HAVE_TR1_FUNCTIONAL
+// #include <tr1/functional>
+// #endif
+// old code jhrg #include <ext/functional>
 #include <string>
 
+namespace GF {
+
 //typedef pointer_to_unary_function<Cell, Tuple *> GridFunction;
 
 void debug_set(UnTypedPtr p);
-class AssignmentFunction : 
- virtual public unary_function<CellId&, vector<Cell>&> {
- public:
- 
-  virtual ~AssignmentFunction() {}; 
-  GridField *T;
-  GridField *S;
-  Dim_t _i, _j;
-  const Dataset *dstarget, *dssource;
-  Scheme schtarget;
-  Scheme schsource;
-  
-  virtual void setEnvironment(GridField *t, Dim_t i, GridField *s, Dim_t j) { 
-    T=t; S=s; _i=i; _j=j;
-    dstarget = &T->GetDataset(_i);
-    dssource = &S->GetDataset(_j);
-    schtarget = dstarget->GetScheme();
-    schsource = dssource->GetScheme();
-  }
-  virtual void operator()(const CellId &, vector<CellId> &) = 0;
-  
+class AssignmentFunction: virtual public unary_function<CellId&, vector<Cell>&> {
+public:
+
+	virtual ~AssignmentFunction()
+	{
+	}
+	;
+	GridField *T;
+	GridField *S;
+	Dim_t _i, _j;
+	const Dataset *dstarget, *dssource;
+	Scheme schtarget;
+	Scheme schsource;
+
+	virtual void setEnvironment(GridField *t, Dim_t i, GridField *s, Dim_t j)
+	{
+		T = t;
+		S = s;
+		_i = i;
+		_j = j;
+		dstarget = &T->GetDataset(_i);
+		dssource = &S->GetDataset(_j);
+		schtarget = dstarget->GetScheme();
+		schsource = dssource->GetScheme();
+	}
+	virtual void operator()(const CellId &, vector<CellId> &) = 0;
+
 };
 
-class AggregationFunction : 
- virtual public unary_function<vector<Tuple>&, Tuple> {
- public:
-
-  virtual ~AggregationFunction() {}; 
-  void setScheme(Scheme *sch) { 
-    inscheme = sch; 
-    outscheme = getOutScheme(inscheme); 
-  }
-  Scheme *getOutScheme() { return outscheme; }
-  virtual Scheme *getOutScheme(Scheme *inscheme) = 0;
-
-  virtual void operator()(vector<Tuple> &, Tuple &) = 0;
-/*
-  ~AggregationFunction() {
-    delete outscheme;
-  }
-*/
- private:
-  Scheme *inscheme;
-  Scheme *outscheme;
+class AggregationFunction: virtual public unary_function<vector<Tuple>&, Tuple> {
+public:
+
+	virtual ~AggregationFunction()
+	{
+	}
+	;
+	void setScheme(Scheme *sch)
+	{
+		inscheme = sch;
+		outscheme = getOutScheme(inscheme);
+	}
+	Scheme *getOutScheme()
+	{
+		return outscheme;
+	}
+	virtual Scheme *getOutScheme(Scheme *inscheme) = 0;
+
+	virtual void operator()(vector<Tuple> &, Tuple &) = 0;
+	/*
+	 ~AggregationFunction() {
+	 delete outscheme;
+	 }
+	 */
+private:
+	Scheme *inscheme;
+	Scheme *outscheme;
 };
 
-class AggregateOp : public BinaryGridFieldOperator {
- public:
-  
-  AggregateOp(GridFieldOperator *T, Dim_t i,
-              AssignmentFunction *m, 
-              AggregationFunction *f, 
-              GridFieldOperator *S,
-              Dim_t j);
-  
-  static GridField *Aggregate(GridField *T, Dim_t i,
-     			      AssignmentFunction &m, 
-     			      AggregationFunction &f,
-			      GridField *S, Dim_t j);
- protected:
-  AssignmentFunction *m;
-  AggregationFunction *f;
-  Dim_t _i,_j;
-  
-  void Execute(); 
- private:
-  static string newName(string Aname, string Bname);
+class AggregateOp: public BinaryGridFieldOperator {
+public:
+
+	AggregateOp(GridFieldOperator *T, Dim_t i, AssignmentFunction *m, AggregationFunction *f, GridFieldOperator *S,
+			Dim_t j);
+
+	static GridField *Aggregate(GridField *T, Dim_t i, AssignmentFunction &m, AggregationFunction &f, GridField *S,
+			Dim_t j);
+protected:
+	AssignmentFunction *m;
+	AggregationFunction *f;
+	Dim_t _i, _j;
+
+	void Execute();
+private:
+	static string newName(string Aname, string Bname);
 
 };
 
+} // namespace GF
+
 #endif /* AGGREGATE_H */
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/aggregations.cc gridfields/clib/src/aggregations.cc
--- tag/gridfieldsclib-0.7/src/aggregations.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/aggregations.cc	2014-05-16 22:57:00.736725199 +0200
@@ -1,60 +1,58 @@
+#include "config_gridfields.h"
 
 #include <math.h>
 #include "aggregations.h"
 
-
-float Aggregate::euclid(float x1, float y1, float x2, float y2) {
-  return sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));
+float Aggregate::euclid(float x1, float y1, float x2, float y2)
+{
+	return sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
 }
 
-float Aggregate::euclid3D(float x1, float y1, float z1, float x2, float y2, float z2) {
-  return sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1) + (z2-z1)*(z2-z1));
+float Aggregate::euclid3D(float x1, float y1, float z1, float x2, float y2, float z2)
+{
+	return sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) + (z2 - z1) * (z2 - z1));
 }
 
-
-void Aggregate::interpolate3D::operator()(vector<Tuple> &tupset, Tuple &out)  {
-    int s = tupset.size();
-    float dist[s];
-    float x, y, z, v[s][attrs.size()];
-    float px, py, pz, *val;
-    float sum = 0;
-    
-   
-    
-    Tuple *t = &out;
-    px = *(float *) t->get("x");
-    py = *(float *) t->get("y");
-    pz = *(float *) t->get("z");
-    
-    
-    val = new float[attrs.size()];
-    float null = -9999.0;
-    if (s==0) {
-      for (size_t j=0; j<attrs.size(); j++) {
-        out.set(attrs[j], &null);
-      }
-    }
-    
-    for (int i=0; i<s; i++) { 
-      x = *(float *)tupset[i].get("x");
-      y = *(float *)tupset[i].get("y");
-      z = *(float *)tupset[i].get("z");
-      for (size_t j=0; j<attrs.size(); j++) {
-        v[i][j] = *(float *)tupset[i].get(attrs[j]);
-      }
-      dist[i] = euclid3D(x,y,z,px,py,pz);
-      sum += dist[i];
-    }
-
-    //cout << "s=" << s << endl;
-    for (size_t j=0; j< attrs.size(); j++) {
-      val[j] = 0;
-      for (int i=0; i<s; i++) { 
-        val[j] += (dist[i]/sum) * v[i][j];
-      }
-      (*(float *) out.get(attrs[j])) = val[j];
-      //out.set(attrs[j], &val[j]);
-      //cout << "val: " << attrs[j] << "=" << *(float*) &val[j]    << endl;
-    }
-    
+void Aggregate::interpolate3D::operator()(vector<Tuple> &tupset, Tuple &out)
+{
+	int s = tupset.size();
+	float dist[s];
+	float x, y, z, v[s][attrs.size()];
+	float px, py, pz, *val;
+	float sum = 0;
+
+	Tuple *t = &out;
+	px = *(float *) t->get("x");
+	py = *(float *) t->get("y");
+	pz = *(float *) t->get("z");
+
+	val = new float[attrs.size()];
+	float null = -9999.0;
+	if (s == 0) {
+		for (size_t j = 0; j < attrs.size(); j++) {
+			out.set(attrs[j], &null);
+		}
+	}
+
+	for (int i = 0; i < s; i++) {
+		x = *(float *) tupset[i].get("x");
+		y = *(float *) tupset[i].get("y");
+		z = *(float *) tupset[i].get("z");
+		for (size_t j = 0; j < attrs.size(); j++) {
+			v[i][j] = *(float *) tupset[i].get(attrs[j]);
+		}
+		dist[i] = euclid3D(x, y, z, px, py, pz);
+		sum += dist[i];
+	}
+
+	//cout << "s=" << s << endl;
+	for (size_t j = 0; j < attrs.size(); j++) {
+		val[j] = 0;
+		for (int i = 0; i < s; i++) {
+			val[j] += (dist[i] / sum) * v[i][j];
+		}
+		(*(float *) out.get(attrs[j])) = val[j];
+		//out.set(attrs[j], &val[j]);
+		//cout << "val: " << attrs[j] << "=" << *(float*) &val[j]    << endl;
+	}
 }
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/aggregations.h gridfields/clib/src/aggregations.h
--- tag/gridfieldsclib-0.7/src/aggregations.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/aggregations.h	2014-05-16 22:57:00.770058532 +0200
@@ -6,1176 +6,1272 @@
 
 namespace Aggregate {
 
+using namespace GF;
+
 float euclid(float x1, float y1, float x2, float y2);
 float euclid3D(float x1, float y1, float z1, float x2, float y2, float z2);
 
-class dotwo : public AggregationFunction {
-  private:
-    AggregationFunction &left;
-    AggregationFunction &right;
-    Scheme *leftsch;
-    Scheme *rightsch;
-    Scheme outsch;
-    
-  public:
-    dotwo(AggregationFunction &left, AggregationFunction &right) :
-         left(left), right(right) {};
-
-    void operator()(vector<Tuple> &tupset, Tuple &out) {
-      
-      Tuple lefttup(leftsch);
-      Tuple righttup(rightsch);
-
-      mergeTuples(out, lefttup, leftsch, "left_");
-      mergeTuples(out, righttup, rightsch, "right_");
-
-      left(tupset, lefttup);
-      right(tupset, righttup);
-
-    };
-
-    void mergeTuples(Tuple &out, Tuple &lefttup,
-                     Scheme *leftsch, string prefix) {
-      
-      for (unsigned int i=0; i<leftsch->size(); i++) {
-        string attr = leftsch->getAttribute(i);
-        if (outsch.isAttribute(attr)) 
-          lefttup.set(attr, out.get(attr));
-        else
-          lefttup.set(attr, out.get(prefix + attr));
-      }
-      
-    }
-    
-    void mergeSchemes(Scheme *sch, Scheme *leftsch, 
-                      Scheme *rightsch, string prefix) {
-      
-      for (unsigned int i=0; i<leftsch->size(); i++) {
-        string attr = leftsch->getAttribute(i);
-        Type type = leftsch->getType(i);
-        
-        if (rightsch->isAttribute(attr))
-          sch->addAttribute(prefix + attr, type);
-        else
-          sch->addAttribute(attr, type);
-      } 
-    };
-    
-    Scheme *getOutScheme(Scheme *insch) {
-      outsch.clear();
-      leftsch = left.getOutScheme(insch);
-      rightsch = right.getOutScheme(insch);
+class dotwo: public AggregationFunction {
+private:
+	AggregationFunction &left;
+	AggregationFunction &right;
+	Scheme *leftsch;
+	Scheme *rightsch;
+	Scheme outsch;
+
+public:
+	dotwo(AggregationFunction &left, AggregationFunction &right) :
+			left(left), right(right)
+	{
+	}
+	;
+
+	void operator()(vector<Tuple> &tupset, Tuple &out)
+	{
+
+		Tuple lefttup(leftsch);
+		Tuple righttup(rightsch);
+
+		mergeTuples(out, lefttup, leftsch, "left_");
+		mergeTuples(out, righttup, rightsch, "right_");
+
+		left(tupset, lefttup);
+		right(tupset, righttup);
+
+	}
+	;
+
+	void mergeTuples(Tuple &out, Tuple &lefttup, Scheme *leftsch, string prefix)
+	{
+
+		for (unsigned int i = 0; i < leftsch->size(); i++) {
+			string attr = leftsch->getAttribute(i);
+			if (outsch.isAttribute(attr))
+				lefttup.set(attr, out.get(attr));
+			else
+				lefttup.set(attr, out.get(prefix + attr));
+		}
+
+	}
 
-      mergeSchemes(&outsch, leftsch, rightsch, "left_");
-      mergeSchemes(&outsch, rightsch, leftsch, "right_");
+	void mergeSchemes(Scheme *sch, Scheme *leftsch, Scheme *rightsch, string prefix)
+	{
 
-      return &outsch;
-    };
+		for (unsigned int i = 0; i < leftsch->size(); i++) {
+			string attr = leftsch->getAttribute(i);
+			Type type = leftsch->getType(i);
+
+			if (rightsch->isAttribute(attr))
+				sch->addAttribute(prefix + attr, type);
+			else
+				sch->addAttribute(attr, type);
+		}
+	}
+	;
+
+	Scheme *getOutScheme(Scheme *insch)
+	{
+		outsch.clear();
+		leftsch = left.getOutScheme(insch);
+		rightsch = right.getOutScheme(insch);
+
+		mergeSchemes(&outsch, leftsch, rightsch, "left_");
+		mergeSchemes(&outsch, rightsch, leftsch, "right_");
+
+		return &outsch;
+	}
+	;
 };
 /*
-class AggregationFunction {
-  public:
-    constructor(string, null_value=NULL_VALUE)
-    initialize()=0
-    step()=0
-    finalize()=0
-    getscheme() 
-}
-*/
+ class AggregationFunction {
+ public:
+ constructor(string, null_value=NULL_VALUE)
+ initialize()=0
+ step()=0
+ finalize()=0
+ getscheme()
+ }
+ */
 
 template<typename NumericType>
-class triGradient : public AggregationFunction {
-  public:
-    triGradient(string as) : null_value(NULL_VALUE) { 
-      split(as, " ;,", attrs); 
-    }
-    triGradient(string as, NumericType nv) : null_value(nv) { 
-      split(as, " ;,", attrs); 
-    }
-    
-    void operator()(vector<Tuple> &tupset, Tuple &out) {
-      if (tupset.size() != 3) {
-        Fatal("triGrad Aggregation function only works on triangles; %i vertices were passed in.", tupset.size());
-      }
-
-      float *area = (float *) out.get("area");
-      *area = 0;
-      for (unsigned int i=0; i<attrs.size(); i++) {
-        if (outsch.isAttribute("gradx"+attrs[i])) {
-          float *gradx = (float *) out.get("gradx"+attrs[i]);
-          float *grady = (float *) out.get("grady"+attrs[i]);
-           
-          this->trigrad(tupset, attrs[i], area, gradx, grady);
-        }
-      }
-    }
-   
-    void trigrad(vector<Tuple> &tupset, string &attr, 
-                float *area, float *gradx, float *grady) {
-     float x[3];
-     float y[3];
-     NumericType u[3];
-
-     for (unsigned int i=0; i<3; i++) {
-       x[i] = *(float*) tupset[i].get("x");
-       y[i] = *(float*) tupset[i].get("y");
-       u[i] = *(NumericType*) tupset[i].get(attr);
-     }
-     
-     float tmp_x = (y[1]-y[2])*u[0] + (y[2]-y[0])*u[1] + (y[0]-y[1])*u[2]; 
-     float tmp_y = (x[2]-x[1])*u[0] + (x[0]-x[2])*u[1] + (x[1]-x[0])*u[2]; 
-     
-     *area = (x[1]*(y[2] - y[0]) + x[0]*(y[1] - y[2]) + x[2]*(y[0] - y[1])) / 2;
-     
-     *gradx = tmp_x; // / ( 2 * (*area) * (*area) ); 
-     *grady = tmp_y; // / ( 2 * (*area) * (*area) );
-   }
-    
-   Scheme *getOutScheme(Scheme *insch) {
-     outsch.clear();
-     outsch.addAttribute("area", FLOAT);
-     for (unsigned int i=0; i<attrs.size(); i++) {
-       if (insch->isAttribute(attrs[i])) {
-         outsch.addAttribute("gradx"+attrs[i], FLOAT);
-         outsch.addAttribute("grady"+attrs[i], FLOAT);
-       }
-     }
-     return &outsch;
-   }
-   
-   private:
-    Scheme outsch;
-    NumericType null_value;
-    vector<string> attrs;
-    vector<NumericType> totals;
+class triGradient: public AggregationFunction {
+public:
+	triGradient(string as) :
+			null_value(NULL_VALUE)
+	{
+		split(as, " ;,", attrs);
+	}
+	triGradient(string as, NumericType nv) :
+			null_value(nv)
+	{
+		split(as, " ;,", attrs);
+	}
+
+	void operator()(vector<Tuple> &tupset, Tuple &out)
+	{
+		if (tupset.size() != 3) {
+			Fatal("triGrad Aggregation function only works on triangles; %i vertices were passed in.", tupset.size());
+		}
+
+		float *area = (float *) out.get("area");
+		*area = 0;
+		for (unsigned int i = 0; i < attrs.size(); i++) {
+			if (outsch.isAttribute("gradx" + attrs[i])) {
+				float *gradx = (float *) out.get("gradx" + attrs[i]);
+				float *grady = (float *) out.get("grady" + attrs[i]);
+
+				this->trigrad(tupset, attrs[i], area, gradx, grady);
+			}
+		}
+	}
+
+	void trigrad(vector<Tuple> &tupset, string &attr, float *area, float *gradx, float *grady)
+	{
+		float x[3];
+		float y[3];
+		NumericType u[3];
+
+		for (unsigned int i = 0; i < 3; i++) {
+			x[i] = *(float*) tupset[i].get("x");
+			y[i] = *(float*) tupset[i].get("y");
+			u[i] = *(NumericType*) tupset[i].get(attr);
+		}
+
+		float tmp_x = (y[1] - y[2]) * u[0] + (y[2] - y[0]) * u[1] + (y[0] - y[1]) * u[2];
+		float tmp_y = (x[2] - x[1]) * u[0] + (x[0] - x[2]) * u[1] + (x[1] - x[0]) * u[2];
+
+		*area = (x[1] * (y[2] - y[0]) + x[0] * (y[1] - y[2]) + x[2] * (y[0] - y[1])) / 2;
+
+		*gradx = tmp_x; // / ( 2 * (*area) * (*area) );
+		*grady = tmp_y; // / ( 2 * (*area) * (*area) );
+	}
+
+	Scheme *getOutScheme(Scheme *insch)
+	{
+		outsch.clear();
+		outsch.addAttribute("area", FLOAT);
+		for (unsigned int i = 0; i < attrs.size(); i++) {
+			if (insch->isAttribute(attrs[i])) {
+				outsch.addAttribute("gradx" + attrs[i], FLOAT);
+				outsch.addAttribute("grady" + attrs[i], FLOAT);
+			}
+		}
+		return &outsch;
+	}
+
+private:
+	Scheme outsch;
+	NumericType null_value;
+	vector<string> attrs;
+	vector<NumericType> totals;
 
 };
 
-class Any : public AggregationFunction {
-  public:
-    Any(string acheck, string aset, int tag) 
-              : tag(tag), setattr(aset), checkattr(acheck) {}
-    
-    Any(string a, int tag=1) 
-           : tag(tag), setattr(a), checkattr(a) {}
-
-    void operator()(vector<Tuple> &tupset, Tuple &out) {
-      int *valptr;
-      valptr = (int *) out.get(setattr);
-
-      for (unsigned int i=0; i<tupset.size(); i++) {
-        int val = *(int *) tupset[0].get(checkattr);
-        cout << val << endl;
-        if (val) {
-          *valptr = tag;
-          return;
-        }
-      }
-      *valptr = 0;
+class Any: public AggregationFunction {
+public:
+	Any(string acheck, string aset, int tag) :
+			tag(tag), setattr(aset), checkattr(acheck)
+	{
+	}
+
+	Any(string a, int tag = 1) :
+			tag(tag), setattr(a), checkattr(a)
+	{
+	}
+
+	void operator()(vector<Tuple> &tupset, Tuple &out)
+	{
+		int *valptr;
+		valptr = (int *) out.get(setattr);
+
+		for (unsigned int i = 0; i < tupset.size(); i++) {
+			int val = *(int *) tupset[0].get(checkattr);
+			cout << val << endl;
+			if (val) {
+				*valptr = tag;
+				return;
+			}
+		}
+		*valptr = 0;
 #if 0
-      cout << "none" << endl;
+		cout << "none" << endl;
 #endif
-      return;
-    }
-    Scheme *getOutScheme(Scheme * /*insch unused jhrg 10/5/11*/) {
-      outsch.clear();
-      outsch.addAttribute(setattr, INT);
-      return &outsch;
-    } 
-  private:
-   Scheme outsch;
-   int tag;
-   string setattr, checkattr;
+		return;
+	}
+	Scheme *getOutScheme(Scheme * /*insch unused jhrg 10/5/11*/)
+	{
+		outsch.clear();
+		outsch.addAttribute(setattr, INT);
+		return &outsch;
+	}
+private:
+	Scheme outsch;
+	int tag;
+	string setattr, checkattr;
 };
 
 template<typename NumericType>
-class gradient : public AggregationFunction {
-  public:
-    gradient(string as) : null_value(NULL_VALUE) { 
-      split(as, " ;,", attrs); 
-    }
-    gradient(string as, NumericType nv) : null_value(nv) { 
-      split(as, " ;,", attrs); 
-    }
-    
-    void operator()(vector<Tuple> &tupset, Tuple &out) {
-      float x = *(float *) out.get("x");
-      float y = *(float *) out.get("y");
-
-      for (unsigned int i=0; i<attrs.size(); i++) {
-        if (outsch.isAttribute("gradx"+attrs[i])) {
-          float *gradx = (float *) out.get("gradx"+attrs[i]);
-          float *grady = (float *) out.get("grady"+attrs[i]);
-          NumericType u = 
-              *(NumericType *) out.get(attrs[i]);
-           
-          this->gradLeastSquares(x, y, u, 
-                                 attrs[i], tupset, 
-                                 gradx, grady);
-        }
-      }
-    }
-   
-   
-   void gradLeastSquares(float x0, float y0, NumericType u0,
-                 string attr, vector<Tuple> &tupset,
-                 float *gradx, float *grady) {
-     // based on 
-     // "Revisiting the Leaset Squares Procedure
-     //   for gradient estimation on unstructured meshes"
-     // Dmitri Mavriplis
-     // NASA Technical Report, NIA Report No. 2003-06
-     
-     // weights are euclidean distance (or 1 if fast)
-
-     bool fast = false;
-     
-     float a=0, b=0, c=0, d=0, e=0;
-
-     if (tupset.empty()) {
-       *gradx = 0;
-       *grady = 0;
-       return;
-     }
-     
-     float w2 = 1; 
-     
-     for (unsigned int i=0; i<tupset.size(); i++) {
-       float xi = *(float *) tupset[i].get("x");
-       float yi = *(float *) tupset[i].get("y");
-       NumericType ui = *(NumericType *) tupset[i].get(attr);
-       NumericType du = ui - u0;
-  
-       float dx = xi - x0;
-       float dy = yi - y0;
-       if (dx==0 || dy==0) continue;
-
-       // (inverse distance)^2 = weight^2
-       if (!fast)
-         w2 = 1 / (pow( dx, 2 ) + pow( dy, 2 ));
-         
-       a += w2 * pow(dx, 2);
-       b += w2 * dx * dy;
-       c += w2 * pow(dy, 2);
-       d += w2 * du * dx;
-       e += w2 * du * dy;
-       
-     }
-     
-     // Cramer's rule
-     float det = a*c - pow(b,2);
-     assert(det != 0);
-     
-     *gradx = (d*c - b*e) / det;
-     *grady = (a*e - d*b) / det;
-     
-   }
-    
-   void gradnorm(float x0, float y0, NumericType f0,
-                 string attr, vector<Tuple> &tupset,
-                 float *gradx, float *grady) {
-     
-     float maxdfdu = 0;
-     
-     *gradx = float(null_value);
-     *grady = float(null_value);
-
-     for (unsigned int i=0; i<tupset.size(); i++) {
-       float xi = *(float *) tupset[i].get("x");
-       float yi = *(float *) tupset[i].get("y");
-       NumericType fi = *(NumericType *) tupset[i].get(attr);
-       
-       float norm = sqrt( pow( (xi-x0), 2 ) + pow( (yi-y0), 2 ) );
-       
-       float dfdu = (fi - f0) / norm;
-       
-       
-       if (i==0) {
-         *gradx = dfdu * ( (xi - x0) / norm );
-         *grady = dfdu * ( (yi - y0) / norm );
-         maxdfdu = dfdu;
-       } else {
-         if ( (dfdu > maxdfdu) ) {
-           *gradx = dfdu * ( (xi - x0) / norm );
-           *grady = dfdu * ( (yi - y0) / norm );
-           maxdfdu = dfdu;
-         }
-       }
-     }
-   }
-
-   Scheme *getOutScheme(Scheme *insch) {
-     outsch.clear();
-     for (unsigned int i=0; i<attrs.size(); i++) {
-       if (insch->isAttribute(attrs[i])) {
-         outsch.addAttribute("gradx"+attrs[i], FLOAT);
-         outsch.addAttribute("grady"+attrs[i], FLOAT);
-       }
-     }
-     return &outsch;
-   }
-   
-   private:
-    Scheme outsch;
-    NumericType null_value;
-    vector<string> attrs;
-    vector<NumericType> totals;
+class gradient: public AggregationFunction {
+public:
+	gradient(string as) :
+			null_value(NULL_VALUE)
+	{
+		split(as, " ;,", attrs);
+	}
+	gradient(string as, NumericType nv) :
+			null_value(nv)
+	{
+		split(as, " ;,", attrs);
+	}
+
+	void operator()(vector<Tuple> &tupset, Tuple &out)
+	{
+		float x = *(float *) out.get("x");
+		float y = *(float *) out.get("y");
+
+		for (unsigned int i = 0; i < attrs.size(); i++) {
+			if (outsch.isAttribute("gradx" + attrs[i])) {
+				float *gradx = (float *) out.get("gradx" + attrs[i]);
+				float *grady = (float *) out.get("grady" + attrs[i]);
+				NumericType u = *(NumericType *) out.get(attrs[i]);
+
+				this->gradLeastSquares(x, y, u, attrs[i], tupset, gradx, grady);
+			}
+		}
+	}
+
+	void gradLeastSquares(float x0, float y0, NumericType u0, string attr, vector<Tuple> &tupset, float *gradx,
+			float *grady)
+	{
+		// based on
+		// "Revisiting the Leaset Squares Procedure
+		//   for gradient estimation on unstructured meshes"
+		// Dmitri Mavriplis
+		// NASA Technical Report, NIA Report No. 2003-06
+
+		// weights are euclidean distance (or 1 if fast)
+
+		bool fast = false;
+
+		float a = 0, b = 0, c = 0, d = 0, e = 0;
+
+		if (tupset.empty()) {
+			*gradx = 0;
+			*grady = 0;
+			return;
+		}
+
+		float w2 = 1;
+
+		for (unsigned int i = 0; i < tupset.size(); i++) {
+			float xi = *(float *) tupset[i].get("x");
+			float yi = *(float *) tupset[i].get("y");
+			NumericType ui = *(NumericType *) tupset[i].get(attr);
+			NumericType du = ui - u0;
+
+			float dx = xi - x0;
+			float dy = yi - y0;
+			if (dx == 0 || dy == 0) continue;
+
+			// (inverse distance)^2 = weight^2
+			if (!fast) w2 = 1 / (pow(dx, 2) + pow(dy, 2));
+
+			a += w2 * pow(dx, 2);
+			b += w2 * dx * dy;
+			c += w2 * pow(dy, 2);
+			d += w2 * du * dx;
+			e += w2 * du * dy;
+
+		}
+
+		// Cramer's rule
+		float det = a * c - pow(b, 2);
+		assert(det != 0);
+
+		*gradx = (d * c - b * e) / det;
+		*grady = (a * e - d * b) / det;
+
+	}
+
+	void gradnorm(float x0, float y0, NumericType f0, string attr, vector<Tuple> &tupset, float *gradx, float *grady)
+	{
+
+		float maxdfdu = 0;
+
+		*gradx = float(null_value);
+		*grady = float(null_value);
+
+		for (unsigned int i = 0; i < tupset.size(); i++) {
+			float xi = *(float *) tupset[i].get("x");
+			float yi = *(float *) tupset[i].get("y");
+			NumericType fi = *(NumericType *) tupset[i].get(attr);
+
+			float norm = sqrt(pow((xi - x0), 2) + pow((yi - y0), 2));
+
+			float dfdu = (fi - f0) / norm;
+
+			if (i == 0) {
+				*gradx = dfdu * ((xi - x0) / norm);
+				*grady = dfdu * ((yi - y0) / norm);
+				maxdfdu = dfdu;
+			}
+			else {
+				if ((dfdu > maxdfdu)) {
+					*gradx = dfdu * ((xi - x0) / norm);
+					*grady = dfdu * ((yi - y0) / norm);
+					maxdfdu = dfdu;
+				}
+			}
+		}
+	}
+
+	Scheme *getOutScheme(Scheme *insch)
+	{
+		outsch.clear();
+		for (unsigned int i = 0; i < attrs.size(); i++) {
+			if (insch->isAttribute(attrs[i])) {
+				outsch.addAttribute("gradx" + attrs[i], FLOAT);
+				outsch.addAttribute("grady" + attrs[i], FLOAT);
+			}
+		}
+		return &outsch;
+	}
+
+private:
+	Scheme outsch;
+	NumericType null_value;
+	vector<string> attrs;
+	vector<NumericType> totals;
 };
 
 template<typename NumericType>
-class gradient3D : public AggregationFunction {
-  public:
-    gradient3D(string as) : null_value(NULL_VALUE) { 
-      split(as, " ;,", attrs); 
-    }
-    gradient3D(string as, NumericType nv) : null_value(nv) { 
-      split(as, " ;,", attrs); 
-    }
-    
-    void operator()(vector<Tuple> &tupset, Tuple &out) {
-      float x = *(float *) out.get("x");
-      float y = *(float *) out.get("y");
-      float z = *(float *) out.get("z");
-      for (unsigned int i=0; i<attrs.size(); i++) {
-        float *gradx = (float *) out.get("gradx"+attrs[i]);
-        float *grady = (float *) out.get("grady"+attrs[i]);
-        float *gradz = (float *) out.get("gradz"+attrs[i]);
-        NumericType u = 
-            *(NumericType *) out.get(attrs[i]);
-           
-        this->gradLeastSquares(x, y, z, u, 
-                               v_poss[i], tupset, 
-                               gradx, grady, gradz);
-      }
-    }
-   
-   
-   void gradLeastSquares(float x0, float y0, float z0, NumericType u0,
-                 int attr_pos, vector<Tuple> &tupset,
-                 float *gradx, float *grady, float *gradz) {
-     // based on 
-     // "Revisiting the Leaset Squares Procedure
-     //   for gradient estimation on unstructured meshes"
-     // Dmitri Mavriplis
-     // NASA Technical Report, NIA Report No. 2003-06
-     
-     // weights are euclidean distance (or 1 if fast)
-
-     bool fast = false;
-     
-     float a=0, b=0, c=0, d=0, e=0, f=0, g=0, h=0, i=0;
-
-     if (tupset.empty()) {
-       *gradx = 0;
-       *grady = 0;
-       *gradz = 0;
-       return;
-     }
-     
-     float w2 = 1; 
-     for (unsigned int k=0; k<tupset.size(); k++) {
-       float xk = *(float *) tupset[k].get(x_pos);
-       float yk = *(float *) tupset[k].get(y_pos);
-       float zk = *(float *) tupset[k].get(z_pos);
-       //cout << xk << ", " << yk << ", " << zk << endl;
-       NumericType uk = *(NumericType *) tupset[k].get(attr_pos);
-       NumericType du = uk - u0;
-  
-       float dx = xk - x0;
-       float dy = yk - y0;
-       float dz = zk - z0;
-
-       // inverse distance weights
-       if (!fast)
-         w2 = 1 / pow( pow(dx, 2) + pow(dy, 2) + pow(dz, 2), 2 );
-         
-       
-        //  | a  b  c | | ux |   | g  |
-        //  | b  d  e | | uy | = | h  |
-        //  | c  e  f | | uz |   | i  |
-         
-       a += w2 * pow(dx, 2);
-       b += w2 * dx * dy;
-       c += w2 * dx * dz;
-       
-       d += w2 * pow(dy, 2);
-       e += w2 * dy * dz;
-       
-       f += w2 * pow(dz, 2);
-       
-       g += w2 * du * dx;
-       h += w2 * du * dy;
-       i += w2 * du * dz;
-     }
-     
-     // Cramer's rule
-     float det = a*d*f - a*e*e + b*e*c - b*b*f + c*b*e - c*d*c;
-     assert(det != 0);
-     
-     
-      // g b c
-      // h d e
-      // i e f
-      
-     *gradx = (g*d*f - g*e*e + b*e*i - b*h*f + c*h*e - c*d*i) / det;
-     
-     
-      // a g c
-      // b h e
-      // c i f
-      
-     *grady = (a*h*f - a*e*i + g*e*c - g*b*f + c*b*i - c*h*c) / det;
-     
-     
-      // a b g
-      // b d h
-      // c e i
-      
-     *gradz = (a*d*i - a*h*e + b*h*c - b*b*i + g*b*e - g*d*c) / det;
-     
-   }
-    
-   Scheme *getOutScheme(Scheme *insch) {
-     outsch.clear();
-     
-     v_poss.clear();
-     x_pos = insch->getPosition("x");
-     y_pos = insch->getPosition("y");
-     z_pos = insch->getPosition("z");
-
-     for (unsigned int i=0; i<attrs.size(); i++) {
-       if (insch->isAttribute(attrs[i])) {
-         v_poss.push_back(insch->getPosition(attrs[i]));
-         outsch.addAttribute("gradx"+attrs[i], FLOAT);
-         outsch.addAttribute("grady"+attrs[i], FLOAT);
-         outsch.addAttribute("gradz"+attrs[i], FLOAT);
-       } else {
-         Fatal("%s is not an attribute of the source gridfield's scheme: %s",
-                attrs[i].c_str(), insch->asString().c_str());
-       }
-     }
-     return &outsch;
-   }
-   
-   private:
-    int x_pos, y_pos, z_pos;
-    vector<int> v_poss;
-    Scheme outsch;
-    NumericType null_value;
-    vector<string> attrs;
-    vector<NumericType> totals;
-};
+class gradient3D: public AggregationFunction {
+public:
+	gradient3D(string as) :
+			null_value(NULL_VALUE)
+	{
+		split(as, " ;,", attrs);
+	}
+	gradient3D(string as, NumericType nv) :
+			null_value(nv)
+	{
+		split(as, " ;,", attrs);
+	}
 
+	void operator()(vector<Tuple> &tupset, Tuple &out)
+	{
+		float x = *(float *) out.get("x");
+		float y = *(float *) out.get("y");
+		float z = *(float *) out.get("z");
+		for (unsigned int i = 0; i < attrs.size(); i++) {
+			float *gradx = (float *) out.get("gradx" + attrs[i]);
+			float *grady = (float *) out.get("grady" + attrs[i]);
+			float *gradz = (float *) out.get("gradz" + attrs[i]);
+			NumericType u = *(NumericType *) out.get(attrs[i]);
 
+			this->gradLeastSquares(x, y, z, u, v_poss[i], tupset, gradx, grady, gradz);
+		}
+	}
 
-template<typename NumericType>
-class _sum : public AggregationFunction {
-  public:
-    _sum(string as) : null_value(NULL_VALUE) { 
-      split(as, " ;,", attrs); 
-    }
-    _sum(string as, NumericType nv) : null_value(nv) { 
-      split(as, " ;,", attrs); 
-    }
-
-    void operator()(vector<Tuple> &tupset, Tuple &out) {
-      NumericType *valptr;
-      vector<string>::iterator a;
-      for (unsigned int i=0; i<attrs.size(); i++) {
-        if (outsch.isAttribute("sum"+attrs[i])) {
-          valptr = (NumericType *) out.get("sum"+attrs[i]);
-          *valptr = sum(attrs[i], tupset);
-        }
-      }
-    }
- 
-   NumericType sum(string attr, vector<Tuple> &tupset) {
-     //cout << tupset.size() << endl;
-     if (tupset.size() == 0) return null_value;
-     NumericType total=0;
-     NumericType val;
-     for (unsigned int i=0; i<tupset.size(); i++) {
-       val = *(NumericType *) tupset[i].get(attr);
-       if (val == null_value) continue; // return null_value;
-       total += val;
-     }
-     return total;
-   }
-    
-   Scheme *getOutScheme(Scheme *insch) {
-     outsch.clear();
-     for (unsigned int i=0; i<attrs.size(); i++) {
-       if (insch->isAttribute(attrs[i])) {
-         outsch.addAttribute("sum"+attrs[i], insch->getType(attrs[i]));
-       }
-     }
-     return &outsch;
-   }
-    
-  private:
-    Scheme outsch;
-    NumericType null_value;
-    vector<string> attrs;
-    vector<NumericType> totals;
+	void gradLeastSquares(float x0, float y0, float z0, NumericType u0, int attr_pos, vector<Tuple> &tupset,
+			float *gradx, float *grady, float *gradz)
+	{
+		// based on
+		// "Revisiting the Leaset Squares Procedure
+		//   for gradient estimation on unstructured meshes"
+		// Dmitri Mavriplis
+		// NASA Technical Report, NIA Report No. 2003-06
+
+		// weights are euclidean distance (or 1 if fast)
+
+		bool fast = false;
+
+		float a = 0, b = 0, c = 0, d = 0, e = 0, f = 0, g = 0, h = 0, i = 0;
+
+		if (tupset.empty()) {
+			*gradx = 0;
+			*grady = 0;
+			*gradz = 0;
+			return;
+		}
+
+		float w2 = 1;
+		for (unsigned int k = 0; k < tupset.size(); k++) {
+			float xk = *(float *) tupset[k].get(x_pos);
+			float yk = *(float *) tupset[k].get(y_pos);
+			float zk = *(float *) tupset[k].get(z_pos);
+			//cout << xk << ", " << yk << ", " << zk << endl;
+			NumericType uk = *(NumericType *) tupset[k].get(attr_pos);
+			NumericType du = uk - u0;
+
+			float dx = xk - x0;
+			float dy = yk - y0;
+			float dz = zk - z0;
+
+			// inverse distance weights
+			if (!fast) w2 = 1 / pow(pow(dx, 2) + pow(dy, 2) + pow(dz, 2), 2);
+
+			//  | a  b  c | | ux |   | g  |
+			//  | b  d  e | | uy | = | h  |
+			//  | c  e  f | | uz |   | i  |
+
+			a += w2 * pow(dx, 2);
+			b += w2 * dx * dy;
+			c += w2 * dx * dz;
+
+			d += w2 * pow(dy, 2);
+			e += w2 * dy * dz;
+
+			f += w2 * pow(dz, 2);
+
+			g += w2 * du * dx;
+			h += w2 * du * dy;
+			i += w2 * du * dz;
+		}
+
+		// Cramer's rule
+		float det = a * d * f - a * e * e + b * e * c - b * b * f + c * b * e - c * d * c;
+		assert(det != 0);
+
+		// g b c
+		// h d e
+		// i e f
+
+		*gradx = (g * d * f - g * e * e + b * e * i - b * h * f + c * h * e - c * d * i) / det;
+
+		// a g c
+		// b h e
+		// c i f
+
+		*grady = (a * h * f - a * e * i + g * e * c - g * b * f + c * b * i - c * h * c) / det;
+
+		// a b g
+		// b d h
+		// c e i
+
+		*gradz = (a * d * i - a * h * e + b * h * c - b * b * i + g * b * e - g * d * c) / det;
+
+	}
+
+	Scheme *getOutScheme(Scheme *insch)
+	{
+		outsch.clear();
+
+		v_poss.clear();
+		x_pos = insch->getPosition("x");
+		y_pos = insch->getPosition("y");
+		z_pos = insch->getPosition("z");
+
+		for (unsigned int i = 0; i < attrs.size(); i++) {
+			if (insch->isAttribute(attrs[i])) {
+				v_poss.push_back(insch->getPosition(attrs[i]));
+				outsch.addAttribute("gradx" + attrs[i], FLOAT);
+				outsch.addAttribute("grady" + attrs[i], FLOAT);
+				outsch.addAttribute("gradz" + attrs[i], FLOAT);
+			}
+			else {
+				Fatal("%s is not an attribute of the source gridfield's scheme: %s", attrs[i].c_str(),
+						insch->asString().c_str());
+			}
+		}
+		return &outsch;
+	}
+
+private:
+	int x_pos, y_pos, z_pos;
+	vector<int> v_poss;
+	Scheme outsch;
+	NumericType null_value;
+	vector<string> attrs;
+	vector<NumericType> totals;
 };
 
 template<typename NumericType>
-class _average : public AggregationFunction {
+class _sum: public AggregationFunction {
+public:
+	_sum(string as) :
+			null_value(NULL_VALUE)
+	{
+		split(as, " ;,", attrs);
+	}
+	_sum(string as, NumericType nv) :
+			null_value(nv)
+	{
+		split(as, " ;,", attrs);
+	}
+
+	void operator()(vector<Tuple> &tupset, Tuple &out)
+	{
+		NumericType *valptr;
+		vector<string>::iterator a;
+		for (unsigned int i = 0; i < attrs.size(); i++) {
+			if (outsch.isAttribute("sum" + attrs[i])) {
+				valptr = (NumericType *) out.get("sum" + attrs[i]);
+				*valptr = sum(attrs[i], tupset);
+			}
+		}
+	}
 
-  public:
-    _average(string as) { 
-      split(as, " ;,", attrs); 
-    }
-    _average(string as, NumericType nv) : null_value(nv) { 
-      split(as, " ;,", attrs); 
-    }
-
-    void operator()(vector<Tuple> &tupset, Tuple &out){
-      float *valptr;
-      vector<string>::iterator a;
-      for (unsigned int i=0; i<attrs.size(); i++) {
-        if (outsch.isAttribute("avg"+attrs[i])) {
-          valptr = (float *) out.get("avg"+attrs[i]);
-          *valptr = average(attrs[i], tupset);
-        }
-      }
-    }
-
-    float average(string attr, vector<Tuple> &tupset) {
-      NumericType total=0;
-      NumericType val;
-      int count=0;
-      for (unsigned int i=0; i<tupset.size(); i++) {
-        val = *(NumericType *) tupset[i].get(attr);
-        if (val == null_value) {
-          continue; //return null_value;
-       	}
-        count = count + 1;
-        total += val;
-      }
-      if (count > 0) {
-        return total/count;
-      } else {
-        return null_value;
-      }
-    }
-
-   Scheme *getOutScheme(Scheme *insch) {
-     outsch.clear();
-     for (unsigned int i=0; i<attrs.size(); i++) {
-       if (insch->isAttribute(attrs[i])) {
-         outsch.addAttribute("avg" + attrs[i], FLOAT);
-       }
-     }
-     return &outsch;
-   }
-  
-  private:
-    Scheme outsch;
-    NumericType null_value;
-    vector<string> attrs;
-    vector<NumericType> totals;
+	NumericType sum(string attr, vector<Tuple> &tupset)
+	{
+		//cout << tupset.size() << endl;
+		if (tupset.size() == 0) return null_value;
+		NumericType total = 0;
+		NumericType val;
+		for (unsigned int i = 0; i < tupset.size(); i++) {
+			val = *(NumericType *) tupset[i].get(attr);
+			if (val == null_value) continue; // return null_value;
+			total += val;
+		}
+		return total;
+	}
+
+	Scheme *getOutScheme(Scheme *insch)
+	{
+		outsch.clear();
+		for (unsigned int i = 0; i < attrs.size(); i++) {
+			if (insch->isAttribute(attrs[i])) {
+				outsch.addAttribute("sum" + attrs[i], insch->getType(attrs[i]));
+			}
+		}
+		return &outsch;
+	}
+
+private:
+	Scheme outsch;
+	NumericType null_value;
+	vector<string> attrs;
+	vector<NumericType> totals;
 };
 
 template<typename NumericType>
-class _min : public AggregationFunction {
+class _average: public AggregationFunction {
 
-  public:
-    _min(string as) : null_value(NULL_VALUE) { 
-      split(as, " ;,", attrs); 
-    }
-    _min(string as, NumericType nv) : null_value(nv) { 
-      split(as, " ;,", attrs); 
-    }
-
-    void operator()(vector<Tuple> &tupset, Tuple &out) {
-      NumericType *valptr;
-      vector<string>::iterator a;
-      for (unsigned int i=0; i<attrs.size(); i++) {
-        if (outsch.isAttribute("min"+attrs[i])) {
-          valptr = (NumericType *) out.get("min"+attrs[i]);
-          *valptr = min(attrs[i], tupset);
-        }
-      }
-    }
-  
-    NumericType min(string attr, vector<Tuple> &tupset) {
-      if (tupset.size() == 0) return null_value;
-      NumericType minv = *(NumericType *) tupset[0].get(attr);
-      NumericType v;
-      for (unsigned int i=0; i<tupset.size(); i++) {
-        v = *(NumericType *) tupset[i].get(attr);
-	if (v == null_value) continue; //return null_value;
-        if (minv > v) minv = v;
-      }
-      return minv;
-    }
-  
-    Scheme *getOutScheme(Scheme *insch) {
-      outsch.clear();
-      for (unsigned int i=0; i<attrs.size(); i++) {
-        if (insch->isAttribute(attrs[i])) {
-          outsch.addAttribute("min" + attrs[i], FLOAT);
-        }
-      }
-      return &outsch;
-    }
-
-  private:
-    Scheme outsch;
-    NumericType null_value;
-    vector<string> attrs;
-    vector<NumericType> totals;
-};
+public:
+	_average(string as)
+	{
+		split(as, " ;,", attrs);
+	}
+	_average(string as, NumericType nv) :
+			null_value(nv)
+	{
+		split(as, " ;,", attrs);
+	}
 
+	void operator()(vector<Tuple> &tupset, Tuple &out)
+	{
+		float *valptr;
+		vector<string>::iterator a;
+		for (unsigned int i = 0; i < attrs.size(); i++) {
+			if (outsch.isAttribute("avg" + attrs[i])) {
+				valptr = (float *) out.get("avg" + attrs[i]);
+				*valptr = average(attrs[i], tupset);
+			}
+		}
+	}
 
-template<typename NumericType>
-class _max : public AggregationFunction {
+	float average(string attr, vector<Tuple> &tupset)
+	{
+		NumericType total = 0;
+		NumericType val;
+		int count = 0;
+		for (unsigned int i = 0; i < tupset.size(); i++) {
+			val = *(NumericType *) tupset[i].get(attr);
+			if (val == null_value) {
+				continue; //return null_value;
+			}
+			count = count + 1;
+			total += val;
+		}
+		if (count > 0) {
+			return total / count;
+		}
+		else {
+			return null_value;
+		}
+	}
+
+	Scheme *getOutScheme(Scheme *insch)
+	{
+		outsch.clear();
+		for (unsigned int i = 0; i < attrs.size(); i++) {
+			if (insch->isAttribute(attrs[i])) {
+				outsch.addAttribute("avg" + attrs[i], FLOAT);
+			}
+		}
+		return &outsch;
+	}
 
-  public:
-    _max(string as) : null_value(NULL_VALUE) {
-      split(as, " ;,", attrs);
-    }
-
-    _max(string as, NumericType nv) : null_value(nv) { 
-      split(as, " ;,", attrs); 
-    }
-
-    void operator()(vector<Tuple> &tupset, Tuple &out) {
-      NumericType *valptr;
-      vector<string>::iterator a;
-      for (unsigned int i=0; i<attrs.size(); i++) {
-        if (outsch.isAttribute("max"+attrs[i])) {
-          valptr = (NumericType *) out.get("max"+attrs[i]);
-          *valptr = max(attrs[i], tupset);
-        }
-      }
-    }
-  
-    NumericType max(string attr, vector<Tuple> &tupset) {
-      if (tupset.size() == 0) return null_value;
-      NumericType maxv = *(NumericType *) tupset[0].get(attr);
-      NumericType v;
-      for (unsigned int i=0; i<tupset.size(); i++) {
-        v = *(NumericType *) tupset[i].get(attr);
-	if (v == null_value) continue; //return null_value;
-        if (maxv < v) maxv = v;
-      }
-      return maxv;
-    }
-    
-    Scheme *getOutScheme(Scheme *insch) {
-      outsch.clear();
-      for (unsigned int i=0; i<attrs.size(); i++) {
-        if (insch->isAttribute(attrs[i])) {
-          outsch.addAttribute("max"+attrs[i], insch->getType(attrs[i]));
-        }
-      }
-      return &outsch;
-    }
-  private:
-    Scheme outsch;
-    NumericType null_value;
-    vector<string> attrs;
-    vector<NumericType> totals;
+private:
+	Scheme outsch;
+	NumericType null_value;
+	vector<string> attrs;
+	vector<NumericType> totals;
 };
 
-class Count : public AggregationFunction {
+template<typename NumericType>
+class _min: public AggregationFunction {
+
+public:
+	_min(string as) :
+			null_value(NULL_VALUE)
+	{
+		split(as, " ;,", attrs);
+	}
+	_min(string as, NumericType nv) :
+			null_value(nv)
+	{
+		split(as, " ;,", attrs);
+	}
 
-  public:
+	void operator()(vector<Tuple> &tupset, Tuple &out)
+	{
+		NumericType *valptr;
+		vector<string>::iterator a;
+		for (unsigned int i = 0; i < attrs.size(); i++) {
+			if (outsch.isAttribute("min" + attrs[i])) {
+				valptr = (NumericType *) out.get("min" + attrs[i]);
+				*valptr = min(attrs[i], tupset);
+			}
+		}
+	}
 
-  void operator()(vector<Tuple> &tupset, Tuple &out) {
-    int *valptr;
-    valptr = (int *) out.get("count");
-    *valptr = tupset.size();
-  }
-  
-  Scheme *getOutScheme(Scheme */*insch*/) {
-    outsch.clear();
-    outsch.addAttribute("count", INT);
-    return &outsch;
-  }
-  private:
-    Scheme outsch;
-    vector<string> attrs;
-  
+	NumericType min(string attr, vector<Tuple> &tupset)
+	{
+		if (tupset.size() == 0) return null_value;
+		NumericType minv = *(NumericType *) tupset[0].get(attr);
+		NumericType v;
+		for (unsigned int i = 0; i < tupset.size(); i++) {
+			v = *(NumericType *) tupset[i].get(attr);
+			if (v == null_value) continue; //return null_value;
+			if (minv > v) minv = v;
+		}
+		return minv;
+	}
+
+	Scheme *getOutScheme(Scheme *insch)
+	{
+		outsch.clear();
+		for (unsigned int i = 0; i < attrs.size(); i++) {
+			if (insch->isAttribute(attrs[i])) {
+				outsch.addAttribute("min" + attrs[i], FLOAT);
+			}
+		}
+		return &outsch;
+	}
+
+private:
+	Scheme outsch;
+	NumericType null_value;
+	vector<string> attrs;
+	vector<NumericType> totals;
 };
 
-/*
-class makepolygf : public AggregationFunction {
-  
-  public:
-  int dim;
-  makegridfield(int d) { dim = d; }
-
-  void operator()(vector<Tuple> &tupset, Tuple &out) {
-    int s = tupset.size();
-
-    if (s==0) return;
-    Grid *g = new Grid();
-    g->setImplicit0Cells(s); 
-    
-    for (int i=0; i<tupset.size(); i++) {
-    }
-  }
-
-  Scheme *getOutScheme(Scheme *insch) {
-    Scheme *outsch = new Scheme(*insch);
-    outsch->addAttribute("gf", FLOAT);
-    return outsch;
-  }
+template<typename NumericType>
+class _max: public AggregationFunction {
 
-}
-*/
+public:
+	_max(string as) :
+			null_value(NULL_VALUE)
+	{
+		split(as, " ;,", attrs);
+	}
+
+	_max(string as, NumericType nv) :
+			null_value(nv)
+	{
+		split(as, " ;,", attrs);
+	}
+
+	void operator()(vector<Tuple> &tupset, Tuple &out)
+	{
+		NumericType *valptr;
+		vector<string>::iterator a;
+		for (unsigned int i = 0; i < attrs.size(); i++) {
+			if (outsch.isAttribute("max" + attrs[i])) {
+				valptr = (NumericType *) out.get("max" + attrs[i]);
+				*valptr = max(attrs[i], tupset);
+			}
+		}
+	}
+
+	NumericType max(string attr, vector<Tuple> &tupset)
+	{
+		if (tupset.size() == 0) return null_value;
+		NumericType maxv = *(NumericType *) tupset[0].get(attr);
+		NumericType v;
+		for (unsigned int i = 0; i < tupset.size(); i++) {
+			v = *(NumericType *) tupset[i].get(attr);
+			if (v == null_value) continue; //return null_value;
+			if (maxv < v) maxv = v;
+		}
+		return maxv;
+	}
+
+	Scheme *getOutScheme(Scheme *insch)
+	{
+		outsch.clear();
+		for (unsigned int i = 0; i < attrs.size(); i++) {
+			if (insch->isAttribute(attrs[i])) {
+				outsch.addAttribute("max" + attrs[i], insch->getType(attrs[i]));
+			}
+		}
+		return &outsch;
+	}
+private:
+	Scheme outsch;
+	NumericType null_value;
+	vector<string> attrs;
+	vector<NumericType> totals;
+};
+
+class Count: public AggregationFunction {
+
+public:
+
+	void operator()(vector<Tuple> &tupset, Tuple &out)
+	{
+		int *valptr;
+		valptr = (int *) out.get("count");
+		*valptr = tupset.size();
+	}
+
+	Scheme *getOutScheme(Scheme */*insch*/)
+	{
+		outsch.clear();
+		outsch.addAttribute("count", INT);
+		return &outsch;
+	}
+private:
+	Scheme outsch;
+	vector<string> attrs;
 
-class area : public AggregationFunction {
-  public:
-    area(string a) { attr = a; }
-   
-    void operator()(vector<Tuple> &tupset, Tuple &out) {
-      float *area = (float *) out.get(attr);
-      if (tupset.size() < 3) *area = 0;
-      *area = 0;
-      unsigned int i, j;
-      for (i=0, j=tupset.size()-1; i<tupset.size(); j = i++) {
-        float x1 = *(float *) tupset[j].get("x"); 
-        float y1 = *(float *) tupset[j].get("y");
-        float x2 = *(float *) tupset[i].get("x");
-        float y2 = *(float *) tupset[i].get("y");
-        *area += x1*y2 - x2*y1;
-      }
-      *area =*area/2;
-    }
-     
-    Scheme *getOutScheme(Scheme */*insch*/) {
-      outsch.clear();
-      outsch.addAttribute(attr, FLOAT);
-      return &outsch;
-    }
-    
-  private:
-    string attr;
-    Scheme outsch;
 };
 
-class mkvector : public AggregationFunction {
-  public:
-    string attr;
-    mkvector(string a) { attr = a; }
-    
-    void operator()(vector<Tuple> &tupset, Tuple &out) {
-      //if (tupset.size() > 0) {
-      //  tupset[0].print();
-      //}
-
-      vector<Tuple> **val = (vector<Tuple> **) out.get(attr);
-      if (val == NULL) {
-        Fatal("Attribute %s not found during aggregation", attr.c_str());
-      }
-      
-      // how can I clean up this vector?
-      *val = new vector<Tuple>(tupset);
-      //counted_ptr<vector<Tuple> > p(*val);
 /*
-      if ((**val).size() > 4) getchar();
-      Tuple *t = &(**val)[0];
-      cout << "tuple: ";
-      cout << *val << endl;
-      t->print();
-      */
-      //cout << "tuple: " << *(float *) (((*val)[0]).get("x")) << endl;
-    }
-  
-    Scheme *getOutScheme(Scheme */*insch*/) {
-    outsch.clear();
-    outsch.addAttribute(attr, OBJ);
-    return &outsch;
-  }
-  private:
-    Scheme outsch;
+ class makepolygf : public AggregationFunction {
+
+ public:
+ int dim;
+ makegridfield(int d) { dim = d; }
+
+ void operator()(vector<Tuple> &tupset, Tuple &out) {
+ int s = tupset.size();
+
+ if (s==0) return;
+ Grid *g = new Grid();
+ g->setImplicit0Cells(s);
+
+ for (int i=0; i<tupset.size(); i++) {
+ }
+ }
+
+ Scheme *getOutScheme(Scheme *insch) {
+ Scheme *outsch = new Scheme(*insch);
+ outsch->addAttribute("gf", FLOAT);
+ return outsch;
+ }
+
+ }
+ */
+
+class area: public AggregationFunction {
+public:
+	area(string a)
+	{
+		attr = a;
+	}
+
+	void operator()(vector<Tuple> &tupset, Tuple &out)
+	{
+		float *area = (float *) out.get(attr);
+		if (tupset.size() < 3) *area = 0;
+		*area = 0;
+		unsigned int i, j;
+		for (i = 0, j = tupset.size() - 1; i < tupset.size(); j = i++) {
+			float x1 = *(float *) tupset[j].get("x");
+			float y1 = *(float *) tupset[j].get("y");
+			float x2 = *(float *) tupset[i].get("x");
+			float y2 = *(float *) tupset[i].get("y");
+			*area += x1 * y2 - x2 * y1;
+		}
+		*area = *area / 2;
+	}
+
+	Scheme *getOutScheme(Scheme */*insch*/)
+	{
+		outsch.clear();
+		outsch.addAttribute(attr, FLOAT);
+		return &outsch;
+	}
+
+private:
+	string attr;
+	Scheme outsch;
 };
 
+class mkvector: public AggregationFunction {
+public:
+	string attr;
+	mkvector(string a)
+	{
+		attr = a;
+	}
+
+	void operator()(vector<Tuple> &tupset, Tuple &out)
+	{
+		//if (tupset.size() > 0) {
+		//  tupset[0].print();
+		//}
+
+		vector<Tuple> **val = (vector<Tuple> **) out.get(attr);
+		if (val == NULL) {
+			Fatal("Attribute %s not found during aggregation", attr.c_str());
+		}
+
+		// how can I clean up this vector?
+		*val = new vector<Tuple>(tupset);
+		//counted_ptr<vector<Tuple> > p(*val);
+		/*
+		 if ((**val).size() > 4) getchar();
+		 Tuple *t = &(**val)[0];
+		 cout << "tuple: ";
+		 cout << *val << endl;
+		 t->print();
+		 */
+		//cout << "tuple: " << *(float *) (((*val)[0]).get("x")) << endl;
+	}
 
-class triweights : public AggregationFunction {
-  // UNTESTED
-  public:
-    
-  void operator()(vector<Tuple> &tupset, Tuple &out) {
-    unsigned int s = tupset.size();
-    float dist[s];
-    float x, y;
-    float px, py, w[s];
-    float sum = 0;
-    
-    Tuple *t = &out;
-    px = *(float *) t->get("x");
-    py = *(float *) t->get("y");
-    
-    for (unsigned int i=0; i<s; i++) { 
-      x = *(float *)tupset[i].get("x");
-      y = *(float *)tupset[i].get("y");
-      dist[i] = euclid(x,y,px,py);
-      sum += dist[i];
-    }
-    for (unsigned int i=0; i<s; i++) { 
-      w[i] = (dist[i]/sum);
-    }
-    out.set("w1", *(UnTypedPtr*) &w[0]);
-    out.set("w2", *(UnTypedPtr*) &w[1]);
-    out.set("w3", *(UnTypedPtr*) &w[2]);
-  }
-  
-  Scheme *getOutScheme(Scheme *insch) {
-    Scheme *outsch = new Scheme(*insch);
-    outsch->addAttribute("w1", FLOAT);
-    outsch->addAttribute("w2", FLOAT);
-    outsch->addAttribute("w3", FLOAT);
-    return outsch;
-  }
+	Scheme *getOutScheme(Scheme */*insch*/)
+	{
+		outsch.clear();
+		outsch.addAttribute(attr, OBJ);
+		return &outsch;
+	}
+private:
+	Scheme outsch;
 };
 
+class triweights: public AggregationFunction {
+	// UNTESTED
+public:
+
+	void operator()(vector<Tuple> &tupset, Tuple &out)
+	{
+		unsigned int s = tupset.size();
+		float dist[s];
+		float x, y;
+		float px, py, w[s];
+		float sum = 0;
+
+		Tuple *t = &out;
+		px = *(float *) t->get("x");
+		py = *(float *) t->get("y");
+
+		for (unsigned int i = 0; i < s; i++) {
+			x = *(float *) tupset[i].get("x");
+			y = *(float *) tupset[i].get("y");
+			dist[i] = euclid(x, y, px, py);
+			sum += dist[i];
+		}
+		for (unsigned int i = 0; i < s; i++) {
+			w[i] = (dist[i] / sum);
+		}
+		out.set("w1", (UnTypedPtr) &w[0]);
+		out.set("w2", (UnTypedPtr) &w[1]);
+		out.set("w3", (UnTypedPtr) &w[2]);
+	}
 
+	Scheme *getOutScheme(Scheme *insch)
+	{
+		Scheme *outsch = new Scheme(*insch);
+		outsch->addAttribute("w1", FLOAT);
+		outsch->addAttribute("w2", FLOAT);
+		outsch->addAttribute("w3", FLOAT);
+		return outsch;
+	}
+};
 
 template<typename ValueType>
-class setunion : public AggregationFunction {
-  private:
-    Scheme *outsch;
-    Scheme *sch;
-  public:
-    string vecattr;
-    string valattr;
-    Type type;
-
-    setunion(string a1, string a2, Type t) 
-         : vecattr(a1), valattr(a2), type(t) { 
-      this->outsch = new Scheme();
-      outsch->addAttribute(vecattr, OBJ);
-      this->sch = new Scheme();
-      sch->addAttribute(valattr, type);
-    };
-
-    virtual void operator()(vector<Tuple> &tupset, Tuple &out) {
-      
-      vector<Tuple>::iterator p,q;
-
-      map<ValueType, UnTypedPtr> outset;
-      vector<Tuple> *clump;
-      UnTypedPtr ptr;
-      for (p=tupset.begin(); p!=tupset.end(); p++) {
-        clump = (vector<Tuple> *) (*p).get(vecattr);
-        for (q=clump->begin(); q!=clump->end(); q++) {
-          ptr = (*q).get(valattr);
-          outset[*(ValueType *) ptr] = ptr;
-        }
-      }     
-
-      typename map<ValueType, UnTypedPtr>::iterator j;
-
-      // guaranteed leak - no way to clean up this memory.
-      // Aggregate operator and the type system needs a
-      // major overhaul
-      vector<Tuple> *unioned = new vector<Tuple>;
-      Tuple t(sch);
-      
-      for (j=outset.begin(); j!=outset.end(); j++) {
-        t.set(valattr,(*j).second);
-        unioned->push_back(t);
-      }
-      out.set(vecattr, unioned);
-    }
-  
-  Scheme *getOutScheme(Scheme *insch) {
-    return outsch;
-  }
+class setunion: public AggregationFunction {
+private:
+	Scheme *outsch;
+	Scheme *sch;
+public:
+	string vecattr;
+	string valattr;
+	Type type;
+
+	setunion(string a1, string a2, Type t) :
+			vecattr(a1), valattr(a2), type(t)
+	{
+		this->outsch = new Scheme();
+		outsch->addAttribute(vecattr, OBJ);
+		this->sch = new Scheme();
+		sch->addAttribute(valattr, type);
+	}
+	;
+
+	virtual void operator()(vector<Tuple> &tupset, Tuple &out)
+	{
+
+		vector<Tuple>::iterator p, q;
+
+		map<ValueType, UnTypedPtr> outset;
+		vector<Tuple> *clump;
+		UnTypedPtr ptr;
+		for (p = tupset.begin(); p != tupset.end(); p++) {
+			clump = (vector<Tuple> *) (*p).get(vecattr);
+			for (q = clump->begin(); q != clump->end(); q++) {
+				ptr = (*q).get(valattr);
+				outset[*(ValueType *) ptr] = ptr;
+			}
+		}
+
+		typename map<ValueType, UnTypedPtr>::iterator j;
+
+		// guaranteed leak - no way to clean up this memory.
+		// Aggregate operator and the type system needs a
+		// major overhaul
+		vector<Tuple> *unioned = new vector<Tuple>;
+		Tuple t(sch);
+
+		for (j = outset.begin(); j != outset.end(); j++) {
+			t.set(valattr, (*j).second);
+			unioned->push_back(t);
+		}
+		out.set(vecattr, unioned);
+	}
+
+	Scheme *getOutScheme(Scheme *insch)
+	{
+		return outsch;
+	}
 };
 
+class interpolate3D: public AggregationFunction {
+	// simple linear interpolation
+	// assumes attributes include x,y,z,<attr>
+	// where <attr> is a scalar to be interpolated
+public:
+	vector<string> attrs;
+	interpolate3D(string a)
+	{
+		split(a, ";, :/-", attrs);
+	}
 
-class interpolate3D : public AggregationFunction {
-  // simple linear interpolation 
-  // assumes attributes include x,y,z,<attr>
-  // where <attr> is a scalar to be interpolated
-  public:
-  vector<string> attrs;
-  interpolate3D(string a) { 
-    split(a, ";, :/-", attrs); 
-  }
-
-  interpolate3D(vector<string> &as) {
-    attrs.insert(attrs.begin(), as.begin(), as.end());
-  }
-    
-  void operator()(vector<Tuple> &tupset, Tuple &out);
-  
-  Scheme *getOutScheme(Scheme */*insch*/) {
-    outsch.clear();
-    for (unsigned int j=0; j<attrs.size(); j++) {
-      outsch.addAttribute(attrs[j], FLOAT);
-    }
-    return &outsch;
-  }
+	interpolate3D(vector<string> &as)
+	{
+		attrs.insert(attrs.begin(), as.begin(), as.end());
+	}
 
-  private:
-    Scheme outsch;
+	void operator()(vector<Tuple> &tupset, Tuple &out);
+
+	Scheme *getOutScheme(Scheme */*insch*/)
+	{
+		outsch.clear();
+		for (unsigned int j = 0; j < attrs.size(); j++) {
+			outsch.addAttribute(attrs[j], FLOAT);
+		}
+		return &outsch;
+	}
+
+private:
+	Scheme outsch;
 };
 
+class interpolate2D: public AggregationFunction {
+	// simple linear interpolation
+	// assumes attributes include x,y,<attr>
+	// where <attr> is a scalar to be interpolated
+public:
+	string attr;
+	interpolate2D(string a)
+	{
+		attr = a;
+	}
 
-class interpolate2D : public AggregationFunction {
-  // simple linear interpolation 
-  // assumes attributes include x,y,<attr>
-  // where <attr> is a scalar to be interpolated
-  public:
-  string attr;
-  interpolate2D(string a) { attr = a; }
-    
-  void operator()(vector<Tuple> &tupset, Tuple &out) {
-    unsigned int s = tupset.size();
-    float dist[s];
-    float x, y, v[s];
-    float px, py, *val;
-    float sum = 0;
-    
-    Tuple *t = &out;
-    px = *(float *) t->get("x");
-    py = *(float *) t->get("y");
-    
-    val = new float(0);
-    int null = -99;
-    if (s==0) out.set(attr, &null);
-    
-    for (unsigned int i=0; i<s; i++) { 
-      x = *(float *)tupset[i].get("x");
-      y = *(float *)tupset[i].get("y");
-      v[i] = *(float *)tupset[i].get(attr);
-      dist[i] = euclid(x,y,px,py);
-      sum += dist[i];
+	void operator()(vector<Tuple> &tupset, Tuple &out)
+	{
+		unsigned int s = tupset.size();
+		float dist[s];
+		float x, y, v[s];
+		float px, py, *val;
+		float sum = 0;
+
+		Tuple *t = &out;
+		px = *(float *) t->get("x");
+		py = *(float *) t->get("y");
+
+		val = new float(0);
+		int null = -99;
+		if (s == 0) out.set(attr, &null);
+
+		for (unsigned int i = 0; i < s; i++) {
+			x = *(float *) tupset[i].get("x");
+			y = *(float *) tupset[i].get("y");
+			v[i] = *(float *) tupset[i].get(attr);
+			dist[i] = euclid(x, y, px, py);
+			sum += dist[i];
 //      cout << x << ", " << y << ", " << v[i] << ", " << dist[i] << ", " << sum << endl;
-    }
-    for (unsigned int i=0; i<s; i++) { 
-      *val += (dist[i]/sum) * v[i];
-    }
-    
-    
-    out.set(attr, val);
-    //cout << "val: " << *(float*)out.get(attr) << endl;
-  }
-  
-  Scheme *getOutScheme(Scheme */*insch*/) {
-    Scheme *outsch = new Scheme();
-    outsch->addAttribute(attr, FLOAT);
-    return outsch;
-  }
+		}
+		for (unsigned int i = 0; i < s; i++) {
+			*val += (dist[i] / sum) * v[i];
+		}
+
+		out.set(attr, val);
+		//cout << "val: " << *(float*)out.get(attr) << endl;
+	}
+
+	Scheme *getOutScheme(Scheme */*insch*/)
+	{
+		Scheme *outsch = new Scheme();
+		outsch->addAttribute(attr, FLOAT);
+		return outsch;
+	}
 };
 
 template<typename NumericType>
-class interpolate1D : public AggregationFunction {
-  public:
-    interpolate1D(string xT, string xS, string vs)
-	     : x_attrT(xT), x_attrS(xS), null_value(NULL_VALUE) {
-      split(vs, " ;,", attrs); 
-    }
-    interpolate1D(string xT, string xS, string vs, NumericType null) 
-	     : x_attrT(xT), x_attrS(xS), null_value(null) {
-      split(vs, " ;,", attrs); 
-    }
-
-    void operator()(vector<Tuple> &tupset, Tuple &out) {
-      NumericType *valptr;
-      NumericType xT = *(NumericType *)out.get(x_attrT);
-      NumericType foo = *(NumericType *)out.get("hpos");
-      
-      for (unsigned int i=0; i<attrs.size(); i++) {
-        if (outsch.isAttribute(attrs[i])) {
-          valptr = (NumericType *) out.get(attrs[i]);
-          *valptr = interp(xT, attrs[i], tupset, foo);
-        }
-      }
-    }
-    
-    NumericType interp(NumericType xT, string attr, vector<Tuple> &tupset, NumericType foo) {
-	    
-      NumericType total=0;
-      NumericType answer=0;
-      vector<NumericType> weight(tupset.size());
-      vector<NumericType> val(tupset.size());
-      vector<NumericType> x(tupset.size());
-      
-      // inverse-distance interpolation
-      for (unsigned int i=0; i<tupset.size(); i++) {
-        x[i]   = *(NumericType *)tupset[i].get(x_attrS);
-	val[i] = *(NumericType *)tupset[i].get(attr);
-	
-        weight[i] = 1 / abs(xT-x[i]);
-	
-	if (weight[i] > (1/TOLERANCE)) return val[i];
-	
-        total += weight[i];
-      }
-      
-      // linear regression
-      if (tupset.size() == 2) {
-        //cout << "INTERPOLATE: " << xT << ", " << val[1] << ", " << val[0] << ", " << x[1] << ", " << x[0] << endl;
-        return (val[1] - val[0])/(x[1] - x[0]) * (xT-x[0]) + val[0];
-      }
-      
-      for (unsigned int i=0; i<tupset.size(); i++) {
-        answer += (weight[i]/total) * val[i];
-      }   
-      
-      if (tupset.size() == 0) answer = null_value;
-
-      return answer;
-    }
-    
-    Scheme *getOutScheme(Scheme *insch) {
-      outsch.clear();
-      for (unsigned int i=0; i<attrs.size(); i++) {
-        if (insch->isAttribute(attrs[i])) {
-          outsch.addAttribute(attrs[i], insch->getType(attrs[i]));
-        }
-      }
-      return &outsch;
-    }
-    
-  private:
-    Scheme outsch;
-    string x_attrT, x_attrS;
-    NumericType null_value;
-    vector<string> attrs;
-};
+class interpolate1D: public AggregationFunction {
+public:
+	interpolate1D(string xT, string xS, string vs) :
+			x_attrT(xT), x_attrS(xS), null_value(NULL_VALUE)
+	{
+		split(vs, " ;,", attrs);
+	}
+	interpolate1D(string xT, string xS, string vs, NumericType null) :
+			x_attrT(xT), x_attrS(xS), null_value(null)
+	{
+		split(vs, " ;,", attrs);
+	}
 
+	void operator()(vector<Tuple> &tupset, Tuple &out)
+	{
+		NumericType *valptr;
+		NumericType xT = *(NumericType *) out.get(x_attrT);
+		NumericType foo = *(NumericType *) out.get("hpos");
+
+		for (unsigned int i = 0; i < attrs.size(); i++) {
+			if (outsch.isAttribute(attrs[i])) {
+				valptr = (NumericType *) out.get(attrs[i]);
+				*valptr = interp(xT, attrs[i], tupset, foo);
+			}
+		}
+	}
 
-class first : public AggregationFunction {
-  public:
-    first(string as) : null_value(NULL_VALUE) { 
-      split(as, " ;,", attrs); 
-      all = false;
-    }
-    first(string as, float nv) : null_value(nv) { 
-      split(as, " ;,", attrs); 
-      all = false;
-    }
-    first(float nv) : null_value(nv) { 
-      all = true;
-    }
-    first() : null_value(0) { 
-      all = true;
-    }
-
-  void operator()(vector<Tuple> &tupset, Tuple &out) {
-    for (unsigned int i=0; i<attrs.size(); i++) {
-      float *v = (float *) out.get(attrs[i]);
-      if (tupset.size() == 0) {
-        *v = null_value;
-       } else {
-        *v = *(float *) tupset[0].get(attrs[i]);
-       }
-    }
-  }
-  
-  Scheme *getOutScheme(Scheme *insch) {
-      outsch.clear();
-      if (all) {
-        attrs.clear();
-        for (unsigned int i=0; i<insch->size(); i++) {
-          attrs.push_back(insch->getAttribute(i));
-	}
-      }
-      for (unsigned int i=0; i<attrs.size(); i++) {
-        if (insch->isAttribute(attrs[i])) {
-          outsch.addAttribute(attrs[i], insch->getType(attrs[i]));
-        }
-      }
-      return &outsch;
-  }
-  private:
-    bool all;
-    Scheme outsch;
-    float null_value;
-    vector<string> attrs;
-};
+	NumericType interp(NumericType xT, string attr, vector<Tuple> &tupset, NumericType foo)
+	{
+
+		NumericType total = 0;
+		NumericType answer = 0;
+		vector<NumericType> weight(tupset.size());
+		vector<NumericType> val(tupset.size());
+		vector<NumericType> x(tupset.size());
+
+		// inverse-distance interpolation
+		for (unsigned int i = 0; i < tupset.size(); i++) {
+			x[i] = *(NumericType *) tupset[i].get(x_attrS);
+			val[i] = *(NumericType *) tupset[i].get(attr);
+
+			weight[i] = 1 / abs(xT - x[i]);
+
+			if (weight[i] > (1 / TOLERANCE)) return val[i];
 
-class statistics : public AggregationFunction {
-  //compute max, min, sum, avg for a given atttribute
-  //this version only works for ints
-  
-  string attr;
-  
-  public:
-  statistics(string att) { attr = att; };
-  
-  void operator()(vector<Tuple> &tupset, Tuple &out) {
-
-    typedef int valtype;
-    
-    valtype max;
-    valtype min;
-    valtype sum;
-    valtype avg;
-    unsigned int cnt = tupset.size();
-    valtype v;
-
-    //assert(tupset.size() > 0);
-    if (tupset.size() < 1) {
-      max = min = sum = 0;
-      cnt = 1;
-    } else {
-      max = min = sum = *(valtype *) tupset[0].get(attr);
-    }
-    for (unsigned int i=1; i<cnt; i++) {
-      v = *(valtype *) tupset[i].get(attr);
-      sum += v;
-      if (max < v) max = v;
-      if (min > v) min = v;
-    }
-    avg = sum/cnt;
-    out.set("max"+attr, new valtype(max));
-    out.set("min"+attr, new valtype(min));
-    out.set("sum"+attr, new valtype(sum));
-    out.set("avg"+attr, new valtype(avg));
-    out.set("cnt"+attr, new int(cnt));
-  }
-  
-  Scheme *getOutScheme(Scheme */*insch*/) {
-    Scheme *sch = new Scheme();
-    sch->addAttribute("max"+attr, FLOAT);
-    sch->addAttribute("min"+attr, FLOAT);
-    sch->addAttribute("sum"+attr, FLOAT);
-    sch->addAttribute("avg"+attr, FLOAT);
-    sch->addAttribute("cnt"+attr, INT);
-    return sch;
-  }
+			total += weight[i];
+		}
+
+		// linear regression
+		if (tupset.size() == 2) {
+			//cout << "INTERPOLATE: " << xT << ", " << val[1] << ", " << val[0] << ", " << x[1] << ", " << x[0] << endl;
+			return (val[1] - val[0]) / (x[1] - x[0]) * (xT - x[0]) + val[0];
+		}
+
+		for (unsigned int i = 0; i < tupset.size(); i++) {
+			answer += (weight[i] / total) * val[i];
+		}
+
+		if (tupset.size() == 0) answer = null_value;
+
+		return answer;
+	}
+
+	Scheme *getOutScheme(Scheme *insch)
+	{
+		outsch.clear();
+		for (unsigned int i = 0; i < attrs.size(); i++) {
+			if (insch->isAttribute(attrs[i])) {
+				outsch.addAttribute(attrs[i], insch->getType(attrs[i]));
+			}
+		}
+		return &outsch;
+	}
+
+private:
+	Scheme outsch;
+	string x_attrT, x_attrS;
+	NumericType null_value;
+	vector<string> attrs;
 };
 
-class project : public AggregationFunction {
-  
-  public:
-  std::vector<string> attrs; 
-  project(std::vector<string> att) { attrs = att; };
-  project(string str_attrs) { split(str_attrs, "; ,", attrs); };
-  
-  void operator()(vector<Tuple> &tupset, Tuple &out) {
-    assert(tupset.size() == 1);
-    for (unsigned int i=0; i<attrs.size(); i++) {
-      out.set(attrs[i], tupset[0].get(attrs[i]));
-    }
-  }
-  
-  Scheme *getOutScheme(Scheme *insch) {
-    Scheme *sch = new Scheme();
-    for (unsigned int i=0; i<attrs.size(); i++) {
-      sch->addAttribute(attrs[i], insch->getType(attrs[i]));
-    }
-    return sch;
-  }
-  
+class first: public AggregationFunction {
+public:
+	first(string as) :
+			null_value(NULL_VALUE)
+	{
+		split(as, " ;,", attrs);
+		all = false;
+	}
+	first(string as, float nv) :
+			null_value(nv)
+	{
+		split(as, " ;,", attrs);
+		all = false;
+	}
+	first(float nv) :
+			null_value(nv)
+	{
+		all = true;
+	}
+	first() :
+			null_value(0)
+	{
+		all = true;
+	}
+
+	void operator()(vector<Tuple> &tupset, Tuple &out)
+	{
+		for (unsigned int i = 0; i < attrs.size(); i++) {
+			float *v = (float *) out.get(attrs[i]);
+			if (tupset.size() == 0) {
+				*v = null_value;
+			}
+			else {
+				*v = *(float *) tupset[0].get(attrs[i]);
+			}
+		}
+	}
+
+	Scheme *getOutScheme(Scheme *insch)
+	{
+		outsch.clear();
+		if (all) {
+			attrs.clear();
+			for (unsigned int i = 0; i < insch->size(); i++) {
+				attrs.push_back(insch->getAttribute(i));
+			}
+		}
+		for (unsigned int i = 0; i < attrs.size(); i++) {
+			if (insch->isAttribute(attrs[i])) {
+				outsch.addAttribute(attrs[i], insch->getType(attrs[i]));
+			}
+		}
+		return &outsch;
+	}
+private:
+	bool all;
+	Scheme outsch;
+	float null_value;
+	vector<string> attrs;
+};
+
+class statistics: public AggregationFunction {
+	//compute max, min, sum, avg for a given atttribute
+	//this version only works for ints
+
+	string attr;
+
+public:
+	statistics(string att)
+	{
+		attr = att;
+	}
+	;
+
+	void operator()(vector<Tuple> &tupset, Tuple &out)
+	{
+
+		typedef int valtype;
+
+		valtype max;
+		valtype min;
+		valtype sum;
+		valtype avg;
+		unsigned int cnt = tupset.size();
+		valtype v;
+
+		//assert(tupset.size() > 0);
+		if (tupset.size() < 1) {
+			max = min = sum = 0;
+			cnt = 1;
+		}
+		else {
+			max = min = sum = *(valtype *) tupset[0].get(attr);
+		}
+		for (unsigned int i = 1; i < cnt; i++) {
+			v = *(valtype *) tupset[i].get(attr);
+			sum += v;
+			if (max < v) max = v;
+			if (min > v) min = v;
+		}
+		avg = sum / cnt;
+		out.set("max" + attr, new valtype(max));
+		out.set("min" + attr, new valtype(min));
+		out.set("sum" + attr, new valtype(sum));
+		out.set("avg" + attr, new valtype(avg));
+		out.set("cnt" + attr, new int(cnt));
+	}
+
+	Scheme *getOutScheme(Scheme */*insch*/)
+	{
+		Scheme *sch = new Scheme();
+		sch->addAttribute("max" + attr, FLOAT);
+		sch->addAttribute("min" + attr, FLOAT);
+		sch->addAttribute("sum" + attr, FLOAT);
+		sch->addAttribute("avg" + attr, FLOAT);
+		sch->addAttribute("cnt" + attr, INT);
+		return sch;
+	}
 };
 
+class project: public AggregationFunction {
+
+public:
+	std::vector<string> attrs;
+	project(std::vector<string> att)
+	{
+		attrs = att;
+	}
+	;
+	project(string str_attrs)
+	{
+		split(str_attrs, "; ,", attrs);
+	}
+	;
+
+	void operator()(vector<Tuple> &tupset, Tuple &out)
+	{
+		assert(tupset.size() == 1);
+		for (unsigned int i = 0; i < attrs.size(); i++) {
+			out.set(attrs[i], tupset[0].get(attrs[i]));
+		}
+	}
+
+	Scheme *getOutScheme(Scheme *insch)
+	{
+		Scheme *sch = new Scheme();
+		for (unsigned int i = 0; i < attrs.size(); i++) {
+			sch->addAttribute(attrs[i], insch->getType(attrs[i]));
+		}
+		return sch;
+	}
+
+};
 
 /*
-class alter : public AggregationFunction {
+ class alter : public AggregationFunction {
  public:
-  alter() {
-  }
-};
-*/
+ alter() {
+ }
+ };
+ */
 }
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/apply.cc gridfields/clib/src/apply.cc
--- tag/gridfieldsclib-0.7/src/apply.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/apply.cc	2014-05-16 22:57:00.780058532 +0200
@@ -1,3 +1,5 @@
+#include "config_gridfields.h"
+
 #include "apply.h"
 #include "timing.h"
 #include "gridfield.h"
@@ -7,39 +9,44 @@
 #include <sstream>
 #include <math.h>
 
+namespace GF {
+
 /*
-ApplyOp::ApplyOp(GridFieldOperator *op, string tupleexpr, Scheme *outscheme) 
-   : UnaryGridFieldOperator(op), unparsedExpr(tupleexpr), _sch(outscheme)
+ ApplyOp::ApplyOp(GridFieldOperator *op, string tupleexpr, Scheme *outscheme)
+ : UnaryGridFieldOperator(op), unparsedExpr(tupleexpr), _sch(outscheme)
+ {
+ this->SaveReservedWords();
+ this->cleanup = false;
+ }
+ */
+
+ApplyOp::ApplyOp(string tupleexpr, Dim_t k, GridFieldOperator *op) :
+		UnaryGridFieldOperator(op), k(k), unparsedExpr(tupleexpr)
 {
-  this->SaveReservedWords();
-  this->cleanup = false;
+	//this->cleanup = false;
 }
-*/
 
-ApplyOp::ApplyOp(string tupleexpr, Dim_t k, GridFieldOperator *op) 
-   : UnaryGridFieldOperator(op), k(k), unparsedExpr(tupleexpr)
+void ApplyOp::Execute()
 {
-  //this->cleanup = false;
-}
 
-void ApplyOp::Execute() {
-  
-  this->PrepareForExecution();
+	this->PrepareForExecution();
 #if 0
-  // jhrg 10/5/11
-  float start = gettime();
+	// jhrg 10/5/11
+	float start = gettime();
 #endif
-  DEBUG << "ApplyOperator" << endl;
-  this->Result =  Apply(this->unparsedExpr, this->k,
-                        this->GF);
+	DEBUG << "ApplyOperator" << endl;
+	this->Result = Apply(this->unparsedExpr, this->k, this->GF);
 }
 
-GridField *ApplyOp::Apply(string expr, Dim_t k, GridField *Gg) {
-  GridField *Out = new GridField(Gg);
-  if (Gg->Card(k) == 0) return Out;
-  Out->Apply(expr, k); 
-  DEBUG << "Apply(" << k << ", " << expr << ")" << endl;
-  //Gg->ref();
-  return Out;
+GridField *ApplyOp::Apply(string expr, Dim_t k, GridField *Gg)
+{
+	GridField *Out = new GridField(Gg);
+	if (Gg->Card(k) == 0) return Out;
+	Out->Apply(expr, k);
+	DEBUG << "Apply(" << k << ", " << expr << ")" << endl;
+	//Gg->ref();
+	return Out;
 }
 
+} // namespace GF
+
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/apply.h gridfields/clib/src/apply.h
--- tag/gridfieldsclib-0.7/src/apply.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/apply.h	2014-05-16 22:57:00.833391864 +0200
@@ -1,28 +1,46 @@
 #ifndef _APPLY_H
 #define _APPLY_H
 
+//#include "config.h"
+
 #include <iostream>
+// #include <functional>
 #include "gridfield.h"
 #include "gridfieldoperator.h"
-#include <ext/functional>
+//#ifdef HAVE_TR1_FUNCTIONAL
+//#include <tr1/functional>
+//#endif
+// old code jhrg #include <ext/functional>
 #include <string>
 
-class ApplyOp : public UnaryGridFieldOperator {
- public:
+namespace GF {
+
+class ApplyOp: public UnaryGridFieldOperator {
+public:
 //  ApplyOp(GridFieldOperator *op, string tupleexpr, Scheme *outscheme);
-  ApplyOp(string tupleexpr, Dim_t k, GridFieldOperator *op);
-  void Execute();
-  static GridField *Apply(string tupleexpr, Dim_t k, GridField *Gg);
-
- void SetExpression(const string &expr) { 
-    unparsedExpr = expr; Update(); 
- };
- void SetRank(Dim_t _k) { k=_k; Update();};
-  
- private:
-  Dim_t k;
-  string unparsedExpr;
+	ApplyOp(string tupleexpr, Dim_t k, GridFieldOperator *op);
+	void Execute();
+	static GridField *Apply(string tupleexpr, Dim_t k, GridField *Gg);
+
+	void SetExpression(const string &expr)
+	{
+		unparsedExpr = expr;
+		Update();
+	}
+	;
+	void SetRank(Dim_t _k)
+	{
+		k = _k;
+		Update();
+	}
+	;
+
+private:
+	Dim_t k;
+	string unparsedExpr;
 
 };
 
+} // namespace GF
+
 #endif /* APPLY_H */
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/array.cc gridfields/clib/src/array.cc
--- tag/gridfieldsclib-0.7/src/array.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/array.cc	2014-05-16 22:57:00.826725198 +0200
@@ -1,3 +1,5 @@
+#include "config_gridfields.h"
+
 #include <iostream>
 #include "array.h"
 #include "access.h"
@@ -8,686 +10,760 @@
 #include <vector>
 using namespace std;
 
+namespace GF {
+
 //#define DEBUG 0
 /*
-Array::Array(string nm, Scheme *sch, int sz) {
-  if (sch->size() == 1) {
-    init(nm, sch->getType(0));
-    switch (t) {
-      case INT:
-        this->ints = new int[sz];
-        break;
-      case FLOAT:
-        this->floats = new float[sz];
-        break;
-      case OBJ:
-        this->objs = new UnTypedPtr[sz];
-        break;
-    }
-  } else {
-    init(nm, OBJ);
-    this->objs = new UnTypedPtr[sz];
-  }
-  _size = sz;
-  _sch = sch;
-  this->full = true;
-}
-*/
-
-Array::Array(string nm, Type t, int sz) {
-  init(nm.c_str(), t);
-  switch (t) {
-    case INT:
-      this->ints = new int[sz];
-      break;
-    case FLOAT:
-      this->floats = new float[sz];
-      break;
-    case OBJ:
-      this->objs = new UnTypedPtr[sz];
-      break;
-    case TUPLE:
-    case GRIDFIELD:
-      // jhrg 10/5/11
-      cerr << "TUPLE or GRIDFIELD found in Array::Array; objs is likely invalid" << endl;
-  }
-  _size = sz;
-  this->full = true;
-}
-
-Array::Array(const char *nm, Type t) {
-  init(nm, t);
-}
-Array::Array(string nm, Type t) {
-  init(nm.c_str(), t);
-}
-void Array::fill(DatumIterator<int> &d) {
-  assert(type==INT);
-  d.Open();
-  int i=0;
-  while (i<this->size() && !d.Done()) {
-    ints[i++] = d.Next();
-    cout << i << ", " << ints[i-1] << endl;
-  }
-}
-                                                                       
-void Array::fill(DatumIterator<float> &d) {
-  assert(type==FLOAT);
-  d.Open();
-  int i=0;
-  while (i<size() && !d.Done()) {
-    floats[i++] = d.Next();
-    cout << i << ", " << floats[i-1] << endl;
-  }
-}
-
-
-Array::Array(Array *a, string nm) {
-  // If 'a' is a tuple-valued array, this method copies 
-  // the given attribute out of the tuples and creates a new array
-  Type t=TUPLE;
-  if (a->type == OBJ) {
-    Scheme *sch = a->getScheme();
-    if (sch->isAttribute(nm)) {
-      t = sch->getType(nm);
-      init(nm.c_str(), t);
-      this->_sch = sch;
-      this->_size = a->_size;
+ Array::Array(string nm, Scheme *sch, int sz) {
+ if (sch->size() == 1) {
+ init(nm, sch->getType(0));
+ switch (t) {
+ case INT:
+ this->ints = new int[sz];
+ break;
+ case FLOAT:
+ this->floats = new float[sz];
+ break;
+ case OBJ:
+ this->objs = new UnTypedPtr[sz];
+ break;
+ }
+ } else {
+ init(nm, OBJ);
+ this->objs = new UnTypedPtr[sz];
+ }
+ _size = sz;
+ _sch = sch;
+ this->full = true;
+ }
+ */
+
+Array::Array(string nm, Type t, int sz)
+{
+	init(nm.c_str(), t);
+	switch (t) {
+	case INT:
+		this->ints = new int[sz];
+		break;
+	case FLOAT:
+		this->floats = new float[sz];
+		break;
+	case OBJ:
+		this->objs = new UnTypedPtr[sz];
+		break;
+	case TUPLE:
+	case GRIDFIELD:
+		// jhrg 10/5/11
+		cerr << "TUPLE or GRIDFIELD found in Array::Array; objs is likely invalid" << endl;
+	}
+	_size = sz;
+	this->full = true;
+}
+
+Array::Array(const char *nm, Type t)
+{
+	init(nm, t);
+}
+Array::Array(string nm, Type t)
+{
+	init(nm.c_str(), t);
+}
+void Array::fill(DatumIterator<int> &d)
+{
+	assert(type == INT);
+	d.Open();
+	int i = 0;
+	while (i < this->size() && !d.Done()) {
+		ints[i++] = d.Next();
+		// cout << i << ", " << ints[i-1] << endl;
+	}
+}
+
+void Array::fill(DatumIterator<float> &d)
+{
+	assert(type == FLOAT);
+	d.Open();
+	int i = 0;
+	while (i < size() && !d.Done()) {
+		floats[i++] = d.Next();
+		// cout << i << ", " << floats[i-1] << endl;
+	}
+}
+
+Array::Array(Array *a, string nm)
+{
+	// If 'a' is a tuple-valued array, this method copies
+	// the given attribute out of the tuples and creates a new array
+	Type t = TUPLE;
+	if (a->type == OBJ) {
+		Scheme *sch = a->getScheme();
+		if (sch->isAttribute(nm)) {
+			t = sch->getType(nm);
+			init(nm.c_str(), t);
+			this->_sch = sch;
+			this->_size = a->_size;
 //    } else {
 //      Fatal("Array Copy: %s not a sub-attribute of this array");
-    }
-    //   copy the data to the new array
-    Tuple *tup;
-    if (t == INT) {
-      this->ints = new int[_size];
-      for (int i=0; i<this->_size; i++) {
-        tup = (Tuple *) a->getValPtr(i);
-        this->ints[i] = *(int *)tup->get(nm);
-      }
-    } else if (t == FLOAT) {
-      this->floats = new float[_size];
-      for (int i=0; i<this->_size; i++) {
-        tup = (Tuple *) a->getValPtr(i);
-        this->floats[i] = *(float *)tup->get(nm);
-      }
-    } else if (t == OBJ) {
-      this->objs = new UnTypedPtr[_size];
-      for (int i=0; i<this->_size; i++) {
-        this->objs[i] = ((Tuple *) a->getValPtr(i))->get(nm);
-      }
-    } else {
-        Fatal("array Copy: Unkown type");
-    }
-  } else {
-    Fatal("Array Copy: Not a tuple typed array.");
-  }
-  this->full = 1;
-  this->ref();
-}
-
-Array::Array(const char *nm, Scheme *sch) {
-  if (sch->size() == 1)
-    init(nm, sch->getType(0));
-  else
-    init(nm, OBJ);
-  _sch = sch;
-}
-Array::Array(string nm, Scheme *sch) {
-  if (sch->size() == 1)
-    init(nm.c_str(), sch->getType(0));
-  else
-    init(nm.c_str(), OBJ);
-  _sch = sch;
-}
-
-void Array::init(const char *nm, Type t) {
-  _size = 0;
-  int x = strlen(nm) + 1;
-  name = new char[x];
-  _sch = NULL;
-  strcpy(name, nm);
-  type = t;
-  share = false;
-  full = 0;
-  //increment reference count
-  this->ref();
-}
-
-void Array::getData(void **&out) {
-  Type t = OBJ;
-  if (type == t) {
-    out = objs;
-  } else {
-    Warning("Array %s has type %i, not type %i", name, type, t);
-    out =  NULL;
-  }
-}
-void Array::getData(float *&out) {
-  Type t = FLOAT;
-  if (type == t) {
-    out = floats;
-  } else {
-    Warning("Array %s has type %i, not type %i", name, type, t);
-    out = NULL;
-  }
-}
-void Array::getData(int *&out) {
-  Type t = INT;
-  if (type == t) {
-    out = ints;
-  } else {
-    Warning("Array has type %i, not type %i", name, type, t);
-    out = NULL;
-  }
-}
-
-void Array::copyIntData(int *data, int s) {
-  Array *arr = this;
-  arr->clear();
-  arr->setType(INT);
-  arr->_size = s;  
-  if (data == NULL) return; 
-  arr->ints = new int[s];
-  arr->share = false;
-  memcpy(arr->ints, data, sizeof(int)*s);
-  arr->full = 1;
-}
-
-void Array::shareIntData(int *data, int s) {
-  Array *arr = this;
-  arr->share = true;
-  arr->clear();
-  arr->setType(INT);
-  arr->_size = s;  
-  if (data == NULL) return; 
-  arr->ints = data;
-  arr->full = 1;
-}
-
-void Array::copyFloatData(float *data, int s) {
-  Array *arr = this;
-  arr->share = false;
-  arr->clear();
-  arr->setType(FLOAT);
-  arr->_size = s;
-  if (data == NULL) return; 
-  arr->floats = new float[s];
-  memcpy(arr->floats, data, sizeof(float)*s);
-  arr->share = false;
-  arr->full = 1;
-}
-
-void Array::shareFloatData(float *data, int s) {
-  Array *arr = this;
-  arr->share = true;
-  arr->clear();
-  arr->setType(FLOAT);
-  arr->floats = data;
-  arr->_size = s;
-  arr->full = 1;
-}
-
-void Array::copyObjData(UnTypedPtr *data, int s) {
-  Array *arr = this;
-  arr->share = false;
-  arr->clear();
-  //cout << arr->name << endl;
-  if (type == FLOAT) {
-    arr->floats = new float[s];
-    for (int i=0; i<s; i++) {
-      arr->floats[i] = *(float *)data[i];
-    }
-  } else if (type == INT) {
-    arr->ints = new int[s];
-    arr->ints[0] = -1;
-    for (int i=0; i<s; i++) {
-      arr->ints[i] = *(int *)data[i];
-    }    
-  } else if (type == OBJ) {
-    arr->objs = new UnTypedPtr[s];
-    for (int i=0; i<s; i++) {
-      arr->objs[i] = data[i];
-    }    
-  } 
-  arr->_size = s;
-  arr->share = false;
-  if (data==NULL) return;
-}
-
-void Array::shareObjData(void **data, int _size) {
-  Array *arr = this;
-  arr->share = true;
-  arr->clear();
-  arr->setType(OBJ);
-  arr->_size = _size;
-  arr->objs = data;
-  arr->full = 1;
+		}
+		//   copy the data to the new array
+		Tuple *tup;
+		if (t == INT) {
+			this->ints = new int[_size];
+			for (int i = 0; i < this->_size; i++) {
+				tup = (Tuple *) a->getValPtr(i);
+				this->ints[i] = *(int *) tup->get(nm);
+			}
+		}
+		else if (t == FLOAT) {
+			this->floats = new float[_size];
+			for (int i = 0; i < this->_size; i++) {
+				tup = (Tuple *) a->getValPtr(i);
+				this->floats[i] = *(float *) tup->get(nm);
+			}
+		}
+		else if (t == OBJ) {
+			this->objs = new UnTypedPtr[_size];
+			for (int i = 0; i < this->_size; i++) {
+				this->objs[i] = ((Tuple *) a->getValPtr(i))->get(nm);
+			}
+		}
+		else {
+			Fatal("array Copy: Unkown type");
+		}
+	}
+	else {
+		Fatal("Array Copy: Not a tuple typed array.");
+	}
+	this->full = 1;
+	this->ref();
 }
 
-Array *Array::copy() {
-  Array *arr = this;
+Array::Array(const char *nm, Scheme *sch)
+{
+	if (sch->size() == 1)
+		init(nm, sch->getType(0));
+	else
+		init(nm, OBJ);
+	_sch = sch;
+}
+Array::Array(string nm, Scheme *sch)
+{
+	if (sch->size() == 1)
+		init(nm.c_str(), sch->getType(0));
+	else
+		init(nm.c_str(), OBJ);
+	_sch = sch;
+}
+
+void Array::init(const char *nm, Type t)
+{
+	_size = 0;
+	int x = strlen(nm) + 1;
+	name = new char[x];
+	_sch = NULL;
+	strcpy(name, nm);
+	type = t;
+	share = false;
+	full = 0;
+	//increment reference count
+	this->ref();
+}
+
+void Array::getData(void **&out)
+{
+	Type t = OBJ;
+	if (type == t) {
+		out = objs;
+	}
+	else {
+		Warning("Array %s has type %i, not type %i", name, type, t);
+		out = NULL;
+	}
+}
+void Array::getData(float *&out)
+{
+	Type t = FLOAT;
+	if (type == t) {
+		out = floats;
+	}
+	else {
+		Warning("Array %s has type %i, not type %i", name, type, t);
+		out = NULL;
+	}
+}
+void Array::getData(int *&out)
+{
+	Type t = INT;
+	if (type == t) {
+		out = ints;
+	}
+	else {
+		Warning("Array has type %i, not type %i", name, type, t);
+		out = NULL;
+	}
+}
+
+void Array::copyIntData(int *data, int s)
+{
+	Array *arr = this;
+	arr->clear();
+	arr->setType(INT);
+	arr->_size = s;
+	if (data == NULL) return;
+	arr->ints = new int[s];
+	arr->share = false;
+	memcpy(arr->ints, data, sizeof(int) * s);
+	arr->full = 1;
+}
+
+void Array::shareIntData(int *data, int s)
+{
+	Array *arr = this;
+	arr->share = true;
+	arr->clear();
+	arr->setType(INT);
+	arr->_size = s;
+	if (data == NULL) return;
+	arr->ints = data;
+	arr->full = 1;
+}
+
+void Array::copyFloatData(float *data, int s)
+{
+	Array *arr = this;
+	arr->share = false;
+	arr->clear();
+	arr->setType(FLOAT);
+	arr->_size = s;
+	if (data == NULL) return;
+	arr->floats = new float[s];
+	memcpy(arr->floats, data, sizeof(float) * s);
+	arr->share = false;
+	arr->full = 1;
+}
+
+void Array::shareFloatData(float *data, int s)
+{
+	Array *arr = this;
+	arr->share = true;
+	arr->clear();
+	arr->setType(FLOAT);
+	arr->floats = data;
+	arr->_size = s;
+	arr->full = 1;
+}
+
+void Array::copyObjData(UnTypedPtr *data, int s)
+{
+	Array *arr = this;
+	arr->share = false;
+	arr->clear();
+	//cout << arr->name << endl;
+	if (type == FLOAT) {
+		arr->floats = new float[s];
+		for (int i = 0; i < s; i++) {
+			arr->floats[i] = *(float *) data[i];
+		}
+	}
+	else if (type == INT) {
+		arr->ints = new int[s];
+		arr->ints[0] = -1;
+		for (int i = 0; i < s; i++) {
+			arr->ints[i] = *(int *) data[i];
+		}
+	}
+	else if (type == OBJ) {
+		arr->objs = new UnTypedPtr[s];
+		for (int i = 0; i < s; i++) {
+			arr->objs[i] = data[i];
+		}
+	}
+	arr->_size = s;
+	arr->share = false;
+	if (data == NULL) return;
+}
+
+void Array::shareObjData(void **data, int _size)
+{
+	Array *arr = this;
+	arr->share = true;
+	arr->clear();
+	arr->setType(OBJ);
+	arr->_size = _size;
+	arr->objs = data;
+	arr->full = 1;
+}
+
+Array *Array::copy()
+{
+	Array *arr = this;
 #if 0
-  int i;
+	int i;
 #endif
-  Array *newarr;
-  UnTypedPtr vals = arr->getVals();
+	Array *newarr;
+	UnTypedPtr vals = arr->getVals();
 
-  //One of many places that makes bad assumptions about datum _sizes
-  UnTypedPtr newvals = (UnTypedPtr) new UnTypedVal[_size];
+	//One of many places that makes bad assumptions about datum _sizes
+	UnTypedPtr newvals = (UnTypedPtr) new UnTypedVal[_size];
 
-  newarr = new Array(arr->name, arr->type);
-  memcpy(newvals, vals, arr->_size*sizeof(UnTypedPtr));    
-  newarr->setVals(newvals, _size);
-
-  return newarr;
-}
-
-void Array::setVals(UnTypedPtr vals, int _size) {
-  Array *arr = this;
-  arr->_size = _size;
-
-  arr->clear();
-  switch (arr->type) {
-  case INT:
-    arr->ints = (int *) vals;
-    break;
-  case FLOAT:
-    arr->floats = (float *) vals;
-    break;
-  case OBJ:
-    arr->objs = (UnTypedPtr *) vals;
-    break;
-  default:
-    Warning("Unknown type: %i", type);
-    break;
-  }
-  this->full = 1;
-}
-
-Scheme *Array::getScheme() {
-  if (_sch) return _sch;
-  _sch = new Scheme();
-  _sch->addAttribute(this->name, this->type);
-  return _sch;
-}
-
-Array *Array::copyAndFilter(bool *filter) {
-  Array *arr;
-  arr = this;
-  Array *newarr;
+	newarr = new Array(arr->name, arr->type);
+	memcpy(newvals, vals, arr->_size * sizeof(UnTypedPtr));
+	newarr->setVals(newvals, _size);
+
+	return newarr;
+}
+
+void Array::setVals(UnTypedPtr vals, int _size)
+{
+	Array *arr = this;
+	arr->_size = _size;
+
+	arr->clear();
+	switch (arr->type) {
+	case INT:
+		arr->ints = (int *) vals;
+		break;
+	case FLOAT:
+		arr->floats = (float *) vals;
+		break;
+	case OBJ:
+		arr->objs = (UnTypedPtr *) vals;
+		break;
+	default:
+		Warning("Unknown type: %i", type);
+		break;
+	}
+	this->full = 1;
+}
+
+Scheme *Array::getScheme()
+{
+	if (_sch) return _sch;
+	_sch = new Scheme();
+	_sch->addAttribute(this->name, this->type);
+	return _sch;
+}
+
+Array *Array::copyAndFilter(bool *filter)
+{
+	Array *arr;
+	arr = this;
+	Array *newarr;
 #if 0
-  UnTypedPtr newvals;
-  UnTypedPtr vals;
+	UnTypedPtr newvals;
+	UnTypedPtr vals;
 #endif
-  int i;
-  int j = 0;;
-  int new_size=0;
-
-  if (filter == NULL) {
-    newarr = arr->copy();
-  } else {
-
-    newarr = new Array(arr->name, arr->type);
-    for (i=0; i<arr->_size; i++) {
-      if (filter[i]) { new_size++; }
-    }
-
-    //    UnTypedPtr newvals = (UnTypedPtr) new UnTypedVal[_size];
-
-    switch (arr->type) {
-    case INT: {
-      int *newvals = new int[new_size];
-      int *vals = (int *) arr->getVals();
-      for (i=0; i<arr->_size; i++) {
-	if (filter[i]) {
-	  newvals[j++] = vals[i];
-	}
-      }    
-      newarr->setVals(newvals, new_size);
-      break;
-    }
-    case FLOAT: {
-      float *newvals = new float[new_size];
-      float *vals = (float *) arr->getVals();
-      for (i=0; i<arr->_size; i++) {
-	if (filter[i]) {
-	  newvals[j++] = vals[i];
-	}
-      }   
-      newarr->setVals(newvals, new_size);
-      break;
-    }
-    case OBJ: {
-      UnTypedPtr *newvals = new UnTypedPtr[new_size];
-      UnTypedPtr *vals = (UnTypedPtr *) arr->getVals();
-      for (i=0; i<arr->_size; i++) {
-	if (filter[i]) {
-	  newvals[j++] = vals[i];
-	}
-      }   
-      newarr->setVals(newvals, new_size);
-      break;
-    }
-    default:
-      Warning("unknown Type.");
-    }
-    
-  }
-  
-  assert(newarr->share == false);
-  return newarr;
-};
-
-void Array::UnSafeCast(Type t) {
-  Array *arr = this;
-  switch (arr->type) {
-  case INT:
-    if (t==INT) return;
-    else if (t==OBJ) break;
-    arr->floats = (float *)arr->ints;
-    arr->type = t;
-    return;
-    break;
-  case FLOAT:
-    if (t==FLOAT) return;
-    else if (t==OBJ) break;
-    arr->ints = (int *)arr->floats;
-    arr->type = t;
-    return;
-    break;
-  default:
-    break;
-  }
-  Warning("Can only cast ints and floats");
-
-}
-
-void Array::cast(Type t) {
-
-  if (t != INT && t!= FLOAT) {
-    Warning("Can only cast numeric types");
-    return;
-  }
-  Array *arr = this;
-  
-  switch (arr->type) {
-  case INT:
-    if (t==INT) return;
-    arr->floats = new float[arr->_size];
-    for (int i=0; i<arr->_size; i++) {
-      floats[i] = float(arr->ints[i]);
-    }
-    arr->type = t;
-    if (arr->share) {
-      ints = NULL;
-    } else { 
-      delete [] ints;
-    }
-    break;
-  case FLOAT:
-    if (t==FLOAT) return;
-    arr->ints = new int[arr->_size];
-    for (int i=0; i<arr->_size; i++) {
-      ints[i] =  int(arr->floats[i]);
-    }
-    arr->type = t;
-    if (arr->share) {
-      floats = NULL;
-    } else { 
-      delete [] floats;
-    }
-    break;
-  default:
-    Warning("Can only cast ints and floats");
-  }
-}
-
-void Array::clear() {
-  Array *arr = this;
-  if (!arr->full) return;
-  if (arr->share) return;
-  switch (arr->type) {
-  case INT:
-    if (arr->ints != NULL) delete [] arr->ints;
-    break;
-  case FLOAT:
-    if (arr->floats != NULL) delete [] arr->floats;
-    break;
-  case OBJ:
-      if (arr->objs != NULL) delete [] arr->objs;
-      break;
-  default:
-    Warning("clear: unknown type");
-  }
-  arr->ints = NULL;
-  arr->floats = NULL;
-  arr->objs = NULL;
-  arr->full = 0;
-}
-
-void Array::setType(Type type) {
-  Array *arr = this;
-  if (arr->type != type)
-    Warning("Changing array type from %i to %i",arr->type, type);
-  
-  arr->type = type;
+	int i;
+	int j = 0;
+	;
+	int new_size = 0;
+
+	if (filter == NULL) {
+		newarr = arr->copy();
+	}
+	else {
+
+		newarr = new Array(arr->name, arr->type);
+		for (i = 0; i < arr->_size; i++) {
+			if (filter[i]) {
+				new_size++;
+			}
+		}
+
+		//    UnTypedPtr newvals = (UnTypedPtr) new UnTypedVal[_size];
+
+		switch (arr->type) {
+		case INT: {
+			int *newvals = new int[new_size];
+			int *vals = (int *) arr->getVals();
+			for (i = 0; i < arr->_size; i++) {
+				if (filter[i]) {
+					newvals[j++] = vals[i];
+				}
+			}
+			newarr->setVals(newvals, new_size);
+			break;
+		}
+		case FLOAT: {
+			float *newvals = new float[new_size];
+			float *vals = (float *) arr->getVals();
+			for (i = 0; i < arr->_size; i++) {
+				if (filter[i]) {
+					newvals[j++] = vals[i];
+				}
+			}
+			newarr->setVals(newvals, new_size);
+			break;
+		}
+		case OBJ: {
+			UnTypedPtr *newvals = new UnTypedPtr[new_size];
+			UnTypedPtr *vals = (UnTypedPtr *) arr->getVals();
+			for (i = 0; i < arr->_size; i++) {
+				if (filter[i]) {
+					newvals[j++] = vals[i];
+				}
+			}
+			newarr->setVals(newvals, new_size);
+			break;
+		}
+		default:
+			Warning("unknown Type.");
+		}
+
+	}
+
+	assert(newarr->share == false);
+	return newarr;
+}
+;
+
+void Array::UnSafeCast(Type t)
+{
+	Array *arr = this;
+	switch (arr->type) {
+	case INT:
+		if (t == INT)
+			return;
+		else if (t == OBJ) break;
+		arr->floats = (float *) arr->ints;
+		arr->type = t;
+		return;
+		break;
+	case FLOAT:
+		if (t == FLOAT)
+			return;
+		else if (t == OBJ) break;
+		arr->ints = (int *) arr->floats;
+		arr->type = t;
+		return;
+		break;
+	default:
+		break;
+	}
+	Warning("Can only cast ints and floats");
+
+}
+
+void Array::cast(Type t)
+{
+
+	if (t != INT && t != FLOAT) {
+		Warning("Can only cast numeric types");
+		return;
+	}
+	Array *arr = this;
+
+	switch (arr->type) {
+	case INT:
+		if (t == INT) return;
+		arr->floats = new float[arr->_size];
+		for (int i = 0; i < arr->_size; i++) {
+			floats[i] = float(arr->ints[i]);
+		}
+		arr->type = t;
+		if (arr->share) {
+			ints = NULL;
+		}
+		else {
+			delete[] ints;
+		}
+		break;
+	case FLOAT:
+		if (t == FLOAT) return;
+		arr->ints = new int[arr->_size];
+		for (int i = 0; i < arr->_size; i++) {
+			ints[i] = int(arr->floats[i]);
+		}
+		arr->type = t;
+		if (arr->share) {
+			floats = NULL;
+		}
+		else {
+			delete[] floats;
+		}
+		break;
+	default:
+		Warning("Can only cast ints and floats");
+	}
+}
+
+void Array::clear()
+{
+	Array *arr = this;
+	if (!arr->full) return;
+	if (arr->share) return;
+	switch (arr->type) {
+	case INT:
+		if (arr->ints != NULL) delete[] arr->ints;
+		break;
+	case FLOAT:
+		if (arr->floats != NULL) delete[] arr->floats;
+		break;
+	case OBJ:
+		if (arr->objs != NULL) delete[] arr->objs;
+		break;
+	default:
+		Warning("clear: unknown type");
+	}
+	arr->ints = NULL;
+	arr->floats = NULL;
+	arr->objs = NULL;
+	arr->full = 0;
+}
+
+void Array::setType(Type type)
+{
+	Array *arr = this;
+	if (arr->type != type) Warning("Changing array type from %i to %i", arr->type, type);
+
+	arr->type = type;
+}
+
+UnTypedPtr Array::getValPtr(int i)
+{
+//  assert(i<_size);
+	Array *arr;
+	arr = this;
+
+	switch (arr->type) {
+	case INT:
+		return (UnTypedPtr) &arr->ints[i];
+		break;
+	case FLOAT:
+		return (UnTypedPtr) &arr->floats[i];
+		break;
+	case OBJ:
+		return (UnTypedPtr) &arr->objs[i];
+		break;
+	default:
+		Warning("Unknown type: %i", arr->type);
+		break;
+	}
+
+	return NULL;
 }
 
- 
-UnTypedPtr Array::getValPtr(int i) {
+int Array::getValInt(int i)
+{
 //  assert(i<_size);
-  Array *arr;
-  arr = this;
+	Array *arr;
+	arr = this;
 
-  switch (arr->type) {
-  case INT:
-    return (UnTypedPtr) &arr->ints[i];
-    break;
-  case FLOAT:
-    return (UnTypedPtr) &arr->floats[i];
-    break;
-  case OBJ:
-    return (UnTypedPtr) &arr->objs[i];
-    break; 
-  default:
-    Warning("Unknown type: %i", arr->type);
-    break;
-  }
+	switch (arr->type) {
+	case INT:
+		return arr->ints[i];
+		break;
+	default:
+		break;
+	}
 
-  return NULL;  
+	return 0; // jhrg 2/13/14 NULL;
 }
 
-int Array::getValInt(int i) {
+float Array::getValfloat(int i)
+{
 //  assert(i<_size);
-  Array *arr;
-  arr = this;
+	Array *arr;
+	arr = this;
 
-  switch (arr->type) {
-  case INT:
-    return arr->ints[i];
-    break;
-  default:
-    break;
-  }
-
-  return NULL;  
-}
-
-UnTypedPtr Array::getVals() {
-  Array *arr;
-  arr = this;
-  switch (arr->type) {
-  case INT:
-    return (UnTypedPtr) arr->ints;
-    break;
-  case FLOAT:
-    return (UnTypedPtr) arr->floats;
-    break;
-  case OBJ:
-    return (UnTypedPtr) arr->objs;
-    break;
-  default:
-    Warning("Unknown type: %i", arr->type);
-    break;
-  }
-
-  return NULL;
-
-}
-
-Array *Array::expand(int n) {
-  Array *out = new Array(name, type);
-  int tsize = typesize(this->type);
-  int arraysize = _size*tsize;
-  char *newvals = new char[n*arraysize];
-  char *oldvals = (char *) getVals();
-  for (int j=0; j<_size; j++) {
-    for (int i=0; i<n; i++) {
-      for (int k=0; k<tsize; k++) { 
-        char c = oldvals[j*tsize + k];
-        newvals[i*tsize + j*n*tsize + k] = c;
-      }
-    }
-  }
-  out->setVals((UnTypedPtr *) newvals, n*_size);
-  out->share = false;
-  return out;
-}
-
-Array *Array::repeat(int n) {
-  Array *out = new Array(name, type);
-  int tsize = typesize(this->type);
-  int arraysize = _size*tsize;
-  char *newvals = new char[n*arraysize];
-  char *oldvals = (char *) getVals();
-  for (int i=0; i<n; i++) {
-    for (int j=0; j<arraysize; j++) {
-      newvals[i*arraysize + j] = oldvals[j];
-    }
-  }
-  out->setVals((UnTypedPtr *) newvals, n*_size);
-  out->share = false;
-  return out;
-}
-
-vector<int> Array::makeArray(){
-
-  Array *arr;
-
-  arr = this;
-  int i;
-  //vector<int>* array=new vector<int>;
-  vector<int> array;
-  cout<<"this "<<_size<<" "<<arr->type<<endl;
-  array.reserve(_size);
-  switch (arr->type) {
-  case 1:
-    for (i=0; i<(_size); i++) {
-      array.push_back(arr->ints[i]);
-    }
-    break;
-  default:
-    cout << "unknown type";
-    i = _size;			// 'i' can be used uninitialized jhrg 10/5/11 
-  }
-  cout<<array.at(_size-1)<<endl;
-  return array;
-}
-
-vector<double> Array::makeArrayf(){
-
-  Array *arr;
-
-  arr = this;
-  int i;
-  //vector<int>* array=new vector<int>;
-  vector<double> array;
-  cout<<"this "<<_size<<" "<<arr->type<<endl;
-  array.reserve(_size);
-  switch (arr->type) {
-  case 2:
-    for (i=0; i<(_size); i++) {
-      array.push_back(arr->floats[i]);
-    }
-    break;
-  default:
-    cout << "unknown type";
-    i = _size;			// 'i' can be used uninitialized jhrg 10/5/11 
-  }
-  cout<<array.at(_size-1)<<endl;
-  return array;
-}
-
-void Array::print() {
-  Array *arr;
-  arr = this;
-  int i;
-
-  cout << "address: " << arr << "\n";
-  cout << "name: " << arr->name << "\n";
-  cout << "_size: " << arr->_size << "\n";
-  cout << "type: " << arr->type << "\n";
-  cout << "data: " << "\n";
-  
-  switch (arr->type) {
-  case INT:
-    for (i=0; i<MIN(_size,100); i++) {
-      cout << " " << arr->ints[i];
-      if (i%10 == 100) cout <<"\n";
-    }
-    break;
-  case FLOAT:
-    for (i=0; i<MIN(100,_size); i++) {
-      cout << " " << arr->floats[i];
-      if (i%100 == 100) cout <<"\n";
-    }
-    break;
-  case OBJ:
-    for (i=0; i<MIN(100,_size); i++) {
-      cout << " " << arr->objs[i] ;
-      if (i%100 == 100) cout <<"\n";
-    }
-    break;
-  default:
-    cout << "unknown type";
-    i = _size;			// 'i' can be used uninitialized jhrg 10/5/11
-  }
-  if (i < _size) cout << "...";
-  cout << "\n";
+	switch (arr->type) {
+	case FLOAT:
+		return arr->floats[i];
+		break;
+	default:
+		break;
+	}
 
+	return 0; // jhrg 2/13/14 NULL;
 }
 
-void Array::ref() {
+UnTypedPtr Array::getVals()
+{
+	Array *arr;
+	arr = this;
+	switch (arr->type) {
+	case INT:
+		return (UnTypedPtr) arr->ints;
+		break;
+	case FLOAT:
+		return (UnTypedPtr) arr->floats;
+		break;
+	case OBJ:
+		return (UnTypedPtr) arr->objs;
+		break;
+	default:
+		Warning("Unknown type: %i", arr->type);
+		break;
+	}
+
+	return NULL;
+
+}
+
+Array *Array::expand(int n)
+{
+	Array *out = new Array(name, type);
+	int tsize = typesize(this->type);
+	int arraysize = _size * tsize;
+	char *newvals = new char[n * arraysize];
+	char *oldvals = (char *) getVals();
+	for (int j = 0; j < _size; j++) {
+		for (int i = 0; i < n; i++) {
+			for (int k = 0; k < tsize; k++) {
+				char c = oldvals[j * tsize + k];
+				newvals[i * tsize + j * n * tsize + k] = c;
+			}
+		}
+	}
+	out->setVals((UnTypedPtr) newvals, n * _size);
+	out->share = false;
+	return out;
+}
+
+Array *Array::repeat(int n)
+{
+	Array *out = new Array(name, type);
+	int tsize = typesize(this->type);
+	int arraysize = _size * tsize;
+	char *newvals = new char[n * arraysize];
+	char *oldvals = (char *) getVals();
+	for (int i = 0; i < n; i++) {
+		for (int j = 0; j < arraysize; j++) {
+			newvals[i * arraysize + j] = oldvals[j];
+		}
+	}
+	out->setVals((UnTypedPtr) newvals, n * _size);
+	out->share = false;
+	return out;
+}
+
+vector<int> Array::makeArray()
+{
+
+	Array *arr;
+
+	arr = this;
+	// int i;
+	//vector<int>* array=new vector<int>;
+	vector<int> array;
+	// cout<<"this "<<_size<<" "<<arr->type<<endl;
+	array.reserve(_size);
+	switch (arr->type) {
+	case 1:
+		for (int i = 0; i < (_size); i++) {
+			array.push_back(arr->ints[i]);
+		}
+		break;
+	default:
+		cout << "unknown type";
+		// i = _size;
+	}
+	// cout<<array.at(_size-1)<<endl;
+	return array;
+}
+
+vector<double> Array::makeArrayf()
+{
+
+	Array *arr;
+
+	arr = this;
+	// int i;
+	//vector<int>* array=new vector<int>;
+	vector<double> array;
+	// cout<<"this "<<_size<<" "<<arr->type<<endl;
+	array.reserve(_size);
+	switch (arr->type) {
+	case 2:
+		for (int i = 0; i < (_size); i++) {
+			array.push_back(arr->floats[i]);
+		}
+		break;
+	default:
+		cout << "unknown type";
+		// i = _size;
+	}
+	// cout<<array.at(_size-1)<<endl;
+	return array;
+}
+
+void Array::print()
+{
+	Array *arr;
+	arr = this;
+	int i;
+
+	cout << "address: " << arr << "\n";
+	cout << "name: " << arr->name << "\n";
+	cout << "_size: " << arr->_size << "\n";
+	cout << "type: " << arr->type << "\n";
+	cout << "data: " << "\n";
+
+	switch (arr->type) {
+	case INT:
+		for (i = 0; i < MIN(_size,100); i++) {
+			cout << " " << arr->ints[i];
+			if (i % 10 == 100) cout << "\n";
+		}
+		break;
+	case FLOAT:
+		for (i = 0; i < MIN(100,_size); i++) {
+			cout << " " << arr->floats[i];
+			if (i % 100 == 100) cout << "\n";
+		}
+		break;
+	case OBJ:
+		for (i = 0; i < MIN(100,_size); i++) {
+			cout << " " << arr->objs[i];
+			if (i % 100 == 100) cout << "\n";
+		}
+		break;
+	default:
+		cout << "unknown type";
+		i = _size;			// 'i' can be used uninitialized jhrg 10/5/11
+	}
+	if (i < _size) cout << "...";
+	cout << "\n";
+
+}
+
+void Array::ref()
+{
 //  int old = refcount;
-  //if (strcmp(name, "mag") == 0) cout << "increment " << name << endl;
-  Object::ref();
-  //cout << "array " << this->name << ", ref: " << old << " -> " << this->refcount << endl;
-}
-
-void Array::unref() {
-  //  if (strcmp(name, "mag") == 0) cout << "decrement " << name << endl;
-  //int old = refcount;
-  Object::unref();
-  //cout << "array " << this->name << ", unref: " << old << " -> " << this->refcount << endl;
-  if (this->norefs()) {
-    //cout << "deleting " << this->name << "..." << endl;
-    delete this;
-  }
-}
-
-Array::~Array() {
-  //cout << "~Array: " << this << endl;
-  Array *arr;
-  arr = this;
-  //if (strcmp(name, "mag") == 0) cout << *(int *)NULL << endl;
-  delete [] arr->name;
-  if (arr->share == false) {
-    arr->clear();
-    arr->name = NULL;
-  }
+	//if (strcmp(name, "mag") == 0) cout << "increment " << name << endl;
+	Object::ref();
+	//cout << "array " << this->name << ", ref: " << old << " -> " << this->refcount << endl;
+}
+
+void Array::unref()
+{
+	//  if (strcmp(name, "mag") == 0) cout << "decrement " << name << endl;
+	//int old = refcount;
+	Object::unref();
+	//cout << "array " << this->name << ", unref: " << old << " -> " << this->refcount << endl;
+	if (this->norefs()) {
+		//cout << "deleting " << this->name << "..." << endl;
+		delete this;
+	}
+}
+
+Array::~Array()
+{
+	//cout << "~Array: " << this << endl;
+	Array *arr;
+	arr = this;
+	//if (strcmp(name, "mag") == 0) cout << *(int *)NULL << endl;
+	delete[] arr->name;
+	if (arr->share == false) {
+		arr->clear();
+		arr->name = NULL;
+	}
 }
 
 int *__dfi;
 CArrayIterator<int> __di(__dfi, 0);
 float *__dfp;
 CArrayIterator<float> __df(__dfp, 0);
+
+} // namespace GF
+
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/array.h gridfields/clib/src/array.h
--- tag/gridfieldsclib-0.7/src/array.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/array.h	2014-05-16 22:57:00.743391866 +0200
@@ -8,101 +8,138 @@
 #include <vector>
 #include <string>
 
+namespace GF {
+
 class Scheme;
-template <class T> class DatumIterator;
-class Array : public Object {
+template<class T> class DatumIterator;
+class Array: public Object {
 
- public:
-  Array(std::string nm, Type t);
-  Array(std::string nm, Type t, int size);
-  Array(Array *a, std::string attr);
-  Array(const char *nm, Type t);
-  Array(std::string nm, Scheme *sch);
-  Array(const char *nm, Scheme *sch);
-  vector<int> makeArray();
-  vector<double> makeArrayf();
-  void unref();
-  void ref();
-  virtual ~Array();
-
-  virtual void fill(DatumIterator<int> &d);
-  virtual void fill(DatumIterator<float> &d);
-
-  virtual Array *copyAndFilter(bool *filter);
-  virtual Array *copy();
-
-  virtual void copyIntData(int *data, int s);
-  virtual void shareIntData(int *data, int s);
-
-  virtual void copyFloatData(float *data, int s);
-  virtual void shareFloatData(float *data, int s);
-
-  virtual void copyObjData(void **data, int s);
-  virtual void shareObjData(void **data, int s);
-
-  virtual void getData(int *&out);
-  virtual void getData(float *&out);
-  virtual void getData(void **&out);
-
-  virtual void set(unsigned int i, int val) {this->ints[i] = val; };
-  virtual void set(unsigned int i, float val) {this->floats[i] = val; };
-  virtual void set(unsigned int i, UnTypedPtr val) {this->objs[i] = val; }
-
-  int size() { return _size; }
-  Type gettype() { return type; }
-  virtual string sname() { return string(this->name); }
-  
-  virtual void setVals(UnTypedPtr vals, int s);
-  virtual UnTypedPtr getVals();
-  virtual UnTypedPtr getValPtr(int i);
-  virtual int getValInt(int i);
-
-  virtual inline void next(UnTypedPtr *p) { 
-    plusplus(p, type);
-  };
-
-  virtual Array *expand(int n);
-  virtual Array *repeat(int n);
-  virtual void cast(Type t);
-  virtual void UnSafeCast(Type t);
-
-  virtual void print();
-  virtual string getName() { return string(this->name); };
-  virtual void deleteName() { delete [] name; name = NULL; };
-
-  virtual void clear();
-
-  Type type;
-
-  virtual Scheme *getScheme();
- protected:
-  int _size;
- private:
-  char *name;
-  int share;
-  int full;
-  int *ints;
-  float *floats;
-  short *bytes;
-  void **objs;
+public:
+	Array(std::string nm, Type t);
+	Array(std::string nm, Type t, int size);
+	Array(Array *a, std::string attr);
+	Array(const char *nm, Type t);
+	Array(std::string nm, Scheme *sch);
+	Array(const char *nm, Scheme *sch);
+	vector<int> makeArray();
+	vector<double> makeArrayf();
+	void unref();
+	void ref();
+	virtual ~Array();
+
+	virtual void fill(DatumIterator<int> &d);
+	virtual void fill(DatumIterator<float> &d);
+
+	virtual Array *copyAndFilter(bool *filter);
+	virtual Array *copy();
+
+	virtual void copyIntData(int *data, int s);
+	virtual void shareIntData(int *data, int s);
+
+	virtual void copyFloatData(float *data, int s);
+	virtual void shareFloatData(float *data, int s);
+
+	virtual void copyObjData(void **data, int s);
+	virtual void shareObjData(void **data, int s);
+
+	virtual void getData(int *&out);
+	virtual void getData(float *&out);
+	virtual void getData(void **&out);
+
+	virtual void set(unsigned int i, int val)
+	{
+		this->ints[i] = val;
+	}
+	;
+	virtual void set(unsigned int i, float val)
+	{
+		this->floats[i] = val;
+	}
+	;
+	virtual void set(unsigned int i, UnTypedPtr val)
+	{
+		this->objs[i] = val;
+	}
+
+	int size()
+	{
+		return _size;
+	}
+	Type gettype()
+	{
+		return type;
+	}
+	virtual string sname()
+	{
+		return string(this->name);
+	}
+
+	virtual void setVals(UnTypedPtr vals, int s);
+	virtual UnTypedPtr getVals();
+	virtual UnTypedPtr getValPtr(int i);
+	virtual int getValInt(int i);
+	virtual float getValfloat(int i);
+
+	virtual inline void next(UnTypedPtr *p)
+	{
+		plusplus(p, type);
+	}
+	;
+
+	virtual Array *expand(int n);
+	virtual Array *repeat(int n);
+	virtual void cast(Type t);
+	virtual void UnSafeCast(Type t);
+
+	virtual void print();
+	virtual string getName()
+	{
+		return string(this->name);
+	}
+	;
+	virtual void deleteName()
+	{
+		delete[] name;
+		name = NULL;
+	}
+	;
+
+	virtual void clear();
+
+	Type type;
+
+	virtual Scheme *getScheme();
+protected:
+	int _size;
+private:
+	char *name;
+	int share;
+	int full;
+	int *ints;
+	float *floats;
+	// unused. jhrg 4/4/14 short *bytes;
+	void **objs;
 
-  void setType(Type type);
-  void init(const char *nm, Type t);
+	void setType(Type type);
+	void init(const char *nm, Type t);
 
-  Scheme *_sch;
+	Scheme *_sch;
 };
 
 /*
 
 
 
-class ArrayOfVector : public Array, private vector<Tuple> {
+ class ArrayOfVector : public Array, private vector<Tuple> {
  public:
 
-   ArrayOfVector(Scheme *sch, int sz);
+ ArrayOfVector(Scheme *sch, int sz);
 
  private:
- 
-}
-*/
+
+ }
+ */
+
+} // namespace GF
+
 #endif /* _ARRAY_H */
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/arrayreader.cc gridfields/clib/src/arrayreader.cc
--- tag/gridfieldsclib-0.7/src/arrayreader.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/arrayreader.cc	2014-05-16 22:57:00.730058533 +0200
@@ -1,3 +1,5 @@
+#include "config_gridfields.h"
+
 #include <fstream>
 #include <stdio.h>
 #include "arrayreader.h"
@@ -9,379 +11,397 @@
 #include <sstream>
 using namespace std;
 
-ArrayReader::~ArrayReader() {
+namespace GF {
+
+ArrayReader::~ArrayReader()
+{
 }
 
-FileArrayReader::~FileArrayReader() {
-  if (this->f != NULL) { 
-    this->f->close(); 
-    delete this->f;
-  } 
+FileArrayReader::~FileArrayReader()
+{
+	if (this->f != NULL) {
+		this->f->close();
+		delete this->f;
+	}
 }
 
 FileArrayReader::FileArrayReader(string fn, long off) :
-  filename(fn), f(NULL)
-{ 
-  offset = off;
-  addrAttribute = "";
-  mode = ios::binary; 
-  this->prepFile();
-  this->setStream(this->f);
-}
-
-FileArrayReader::FileArrayReader(string fn, long off, string pa) : 
-  filename(fn), f(NULL)
-{ 
-  offset = off;
-  addrAttribute = pa;
-  mode = ios::binary; 
-  this->prepFile();
-  this->setStream(this->f);
+		filename(fn), f(NULL)
+{
+	offset = off;
+	addrAttribute = "";
+	mode = ios::binary;
+	this->prepFile();
+	this->setStream(this->f);
+}
+
+FileArrayReader::FileArrayReader(string fn, long off, string pa) :
+		filename(fn), f(NULL)
+{
+	offset = off;
+	addrAttribute = pa;
+	mode = ios::binary;
+	this->prepFile();
+	this->setStream(this->f);
 }
 
 FileArrayReader::FileArrayReader(ifstream *f) :
- ArrayReader(f, f->tellg()), filename(""),f(f), mode(ios::binary)
+		ArrayReader(f, f->tellg()), filename(""), f(f), mode(ios::binary)
 {
 }
 
-void FileArrayReader::setFilename(string &filename) {
-  if (filename != this->filename) {
-    this->filename = filename;
-    this->f->close();
-    this->prepFile();
-  }
-}
-
-void FileArrayReader::prepFile() {
- 
-  if (this->f == NULL) 
-    this->f = new ifstream((const char *) this->filename.c_str(), 
-                           this->mode | ios::in);
-  
-  
-  if (!this->f->is_open()) {
-    this->f->open(this->filename.c_str());
-  }
-  
-  if (f->fail()) { 
-    for (int i=0; i< 1000000000; i++) {
-      
-    }
-    cout << "Problem accessing file...retrying." << endl;
-    this->f->clear();
-    if (f->fail()) { 
-      cout << "Still failed after clear?" << endl;
-    }
-    this->f->clear();
-    usleep(2000);
-    delete this->f;
-    this->f = new ifstream((const char *) this->filename.c_str(),
-                           this->mode | ios::in);
-
-    if (f->fail()) { 
-      cout << "Still failed with brand new stream." << endl;
-    }
-
-    if (f->good()) {
-      cout << "File is good." << endl;
-    }
-
-    if (!this->f->is_open()) this->f->open(this->filename.c_str());
-  }
-
-  if (f->fail()) { 
-    Fatal("Unable to open file %s.", filename.c_str());
-  }
-
-  long start = f->tellg();
-  //cout << "seekto " << start + offset << endl;
-  this->f->seekg(start + this->offset, fstream::beg); 
-}
-
-void ArrayReader::Read(GridField *Gf, int k, Array *arr) {
-
-  size_t size = Gf->Card(k);
-
-  bool cleanup = true;
-  int *positions;
-
-  // Look for the attribute that tells us how to read the array
-  if (Gf->IsAttribute(k, addrAttribute)) {
-    Array *addr = Gf->GetAttribute(k, addrAttribute);
-    if (addr->type == INT) {
-
-      addr->getData(positions);
-      cleanup = false;
-    } else {
-      //Warning("address attribute '%s' found, but type is not INT", addrAttribute.c_str());
-      positions = new int[size];
-      float *fpos;
-      addr->getData(fpos);
-      for (size_t i=0; i<size; i++) {
-	positions[i] = int(fpos[i]);
-      }
-    }               
-  } else if (addrAttribute == "") {
-    //assume ordinal positions
-    positions = new int[size];
-    for (size_t i = 0; i<size; i++) positions[i] = i;
-  } else {
-    Fatal("'%s' is not an attribute of this Gridfield.", addrAttribute.c_str());
-  }
-
-  char *data = (char *) arr->getVals();
-  
-  Scheme *sch = arr->getScheme();
-  if (sch->size() > 1) {
-    ReadTuples(*s, positions, size, sch, (UnTypedPtr *) data);
-  }  else {
-    ReadPrimitives(*s, positions, size, arr->type, data);
-  }
-
-  if (cleanup) delete [] positions;
-}
-
-void ArrayReader::setOffset(long offset) {
-  //this->f->close();
-  this->offset = offset;
-  //this->prepFile();
-}
-
-void TextFileArrayReader::ReadPrimitives(ifstream &f, int *positions, int size, Type t, char *data) {
- 
-  int line = 0; 
-  char textline[256];
-  //float x;
+void FileArrayReader::setFilename(string &filename)
+{
+	if (filename != this->filename) {
+		this->filename = filename;
+		this->f->close();
+		this->prepFile();
+	}
+}
+
+void FileArrayReader::prepFile()
+{
+
+	if (this->f == NULL) this->f = new ifstream((const char *) this->filename.c_str(), this->mode | ios::in);
+
+	if (!this->f->is_open()) {
+		this->f->open(this->filename.c_str());
+	}
+
+	if (f->fail()) {
+		for (int i = 0; i < 1000000000; i++) {
+
+		}
+		cout << "Problem accessing file...retrying." << endl;
+		this->f->clear();
+		if (f->fail()) {
+			cout << "Still failed after clear?" << endl;
+		}
+		this->f->clear();
+		usleep(2000);
+		delete this->f;
+		this->f = new ifstream((const char *) this->filename.c_str(), this->mode | ios::in);
+
+		if (f->fail()) {
+			cout << "Still failed with brand new stream." << endl;
+		}
+
+		if (f->good()) {
+			cout << "File is good." << endl;
+		}
+
+		if (!this->f->is_open()) this->f->open(this->filename.c_str());
+	}
+
+	if (f->fail()) {
+		Fatal("Unable to open file %s.", filename.c_str());
+	}
+
+	long start = f->tellg();
+	//cout << "seekto " << start + offset << endl;
+	this->f->seekg(start + this->offset, fstream::beg);
+}
+
+void ArrayReader::Read(GridField *Gf, int k, Array *arr)
+{
+
+	size_t size = Gf->Card(k);
+
+	bool cleanup = true;
+	int *positions;
+
+	// Look for the attribute that tells us how to read the array
+	if (Gf->IsAttribute(k, addrAttribute)) {
+		Array *addr = Gf->GetAttribute(k, addrAttribute);
+		if (addr->type == INT) {
+
+			addr->getData(positions);
+			cleanup = false;
+		}
+		else {
+			//Warning("address attribute '%s' found, but type is not INT", addrAttribute.c_str());
+			positions = new int[size];
+			float *fpos;
+			addr->getData(fpos);
+			for (size_t i = 0; i < size; i++) {
+				positions[i] = int(fpos[i]);
+			}
+		}
+	}
+	else if (addrAttribute == "") {
+		//assume ordinal positions
+		positions = new int[size];
+		for (size_t i = 0; i < size; i++)
+			positions[i] = i;
+	}
+	else {
+		Fatal("'%s' is not an attribute of this Gridfield.", addrAttribute.c_str());
+	}
+
+	char *data = (char *) arr->getVals();
+
+	Scheme *sch = arr->getScheme();
+	if (sch->size() > 1) {
+		ReadTuples(*s, positions, size, sch, (UnTypedPtr*) data);
+	}
+	else {
+		ReadPrimitives(*s, positions, size, arr->type, data);
+	}
+
+	if (cleanup) delete[] positions;
+}
+
+void ArrayReader::setOffset(long offset)
+{
+	//this->f->close();
+	this->offset = offset;
+	//this->prepFile();
+}
+
+// FIXME Replace the scanf() calls with stringstream
+// jhrg 4/4/14
+void TextFileArrayReader::ReadPrimitives(/*ifstream: see note in the header. jhrg 4/4/14 */istream &f, int *positions,
+		int size, Type t, char *data)
+{
+
+	int line = 0;
+	char textline[256];
+	//float x;
 //  stringstream ss;
- 
-//  long o = offset; 
-  //assume offset is in lines instead of bytes 
-  for (int x=0; x<offset; x++) {
-    f.getline(textline,256);
+
+//  long o = offset;
+	//assume offset is in lines instead of bytes
+	for (int x = 0; x < offset; x++) {
+		f.getline(textline, 256);
 //    cout << "skipped(" << offset << "): " << textline << endl;
-  }
-  
-  switch (t) {
-    case INT:
-      
-      for (int i=0; i<size; i++) {
-        while (line <= positions[i]) {
-          f.getline(textline, 256);
-          line++;
-        }
-        sscanf(textline, "%i", (int *) &data[i]);
-        line++;
-      }
-      break;
-      
-    case FLOAT:
-      for (int i=0; i<size; i++) {
-        while (line < positions[i]) {
-          f.getline(textline, 256);
-          line++;
-        }
-        f.getline(textline, 256);
-      //  cout << textline << endl;
-        sscanf(textline, "%f", (float *) &data[i]);
-        line++;
-        
-      }
-      break;
-      
-    default:
-      
-      Fatal("ArrayReader: only ints and floats for now...");
-  }
-  
-}
-
-void ArrayReader::ReadPrimitives(istream &f, int *positions, int size, Type , char *data) {
-  int i = 0;
-  int index = 0;
-  int block = 0;
-  int pos = 0;
-
-  //if (!f.is_open()) this->prepFile();
-  if (size == 0) return;
-   
-  // NOT PORTABLE
-  int valsize = sizeof(int);
-  f.seekg(positions[0] * valsize + this->offset, ifstream::beg);
-  if (f.eof()) {
-    Fatal("Seek to (%i*%i + %i) past end of file while reading array.", positions[0], valsize, this->offset);
-    f.clear();
-  }
-  
-  // Read the data in big chunks if possible
-  
-  while (i<size) {
-    index = i;
-    pos = positions[i];
-    block = 1;
-    while (true) {
-      if (i+1 >= size) break;
-      if (positions[i + 1] != positions[i] + 1) break;
-      ++block;
-      ++i;
-    }
-    f.seekg( offset + pos * valsize, ifstream::beg );
-    f.read(&(data[index*valsize]), block * valsize);
-    //cout << "value: " << *(float *) &data[index] << ",  " << *(int *) &data[index] << endl;
-    i++;
-  }
-}
-
-void TextFileArrayReader::ReadTuples(ifstream &f, int *positions, int size, Scheme *sch, UnTypedPtr *tupptrs) {
-  
-  string format = "";
-  Tuple *t;
-  //int s = sch->size();
-
-  int line = 0;
-  char textline[256];
-  
-  //assume offset is in lines instead of bytes 
-  for (int x=0; x<offset; x++) {
-    f.getline(textline, 256);
-  }
-  
-  for (int i=0; i<size; i++) {
-    t = new Tuple(sch);
-    
-    //cout << "reading position " << positions[i] << endl;
-    while (line < positions[i]) {
-      f.getline(textline, 256);
-      //cout << "eat tup: " << textline << endl;
-      line++;
-    }
-    
-    t->Read(f);
-    
-    line++;
-    
-    tupptrs[i] = (UnTypedPtr) t; 
-    //((Tuple *) tupptrs[i])->print();
-  }
-  
-}
-
-void ProjectArrayReader::ReadPrimitives(istream &f, int *positions, int size, Type t, char *data) {
-  int i = 0;
-  int index = 0;
-  int block = 0;
-  int pos = 0;
-
-
-  int valsize = typesize(t);
-  int tuplesize=this->sch.bytesize();
-  int tupleoffset = this->sch.byteposition(this->attr);
-  
-  char *scratch = new char[size*tuplesize];
-
-  //cout << "Reading primitives: " << this->attr << ": " << tuplesize << ", " << tupleoffset << endl;
-  
-  // Copy the projectedright data in big chunks if possible
-  while (i<size) {
-    index = i;
-    pos = positions[i];
-    block = 1;
-    while (true) {
-      if (i+1 >= size) break;
-      if (positions[i + 1] != positions[i] + 1) break;
-      ++block;
-      ++i;
-    }
-    //float r = gettime(); 
-    f.seekg(offset + pos * tuplesize, ifstream::beg );
-    f.read((char *) &scratch[index*tuplesize], block * tuplesize);
-    //float a = gettime();
-    //cout << "read call: " << block << ", " << index << ", " << r <<" , " << a << ", " << a - r << endl;
-    for (int j=0; j<block; j++) {
-      for(int k=0; k<valsize; k++) {
-        data[(index+j)*valsize + k] = scratch[(index+j)*tuplesize+tupleoffset+k];
-      }
-     // cout << *(float *)&data[(index+j)*valsize] << ", "
-    }
-    i++;
-  }
-
-  delete [] scratch;
-}
-
-void ProjectArrayReader::ReadTuples(istream &, int *, int , Scheme *, UnTypedPtr *) {
-  Fatal("ReadTuples is deprecated; Arrays with complex schemes are deprecated.");
-
-}
-
-
-void ArrayReader::ReadTuples(istream &f, int *positions, int size, Scheme *sch, UnTypedPtr *tupptrs) {
-  int i = 0;
-  int index = 0;
-  int block = 0;
-  int pos = 0;
-
-
-  //for each gridfield in the tuple, seek past it and save the location
-  //so: gridfields must store location
-  // need catalog information.
-  // users will find gridfield compoennts based on metadata
-  // mapping metadata to physical locations is a RDBMS job
-  // definitely need to query (using our metadata stuff, probably)
-  // then need to process the query - where?
-  // what about sets of results - how to operate on all at once?
-  // something to do with nesting.
-   
-  // NOT PORTABLE
-  int valsize=0;
-  for (unsigned int j=0; j<sch->size(); j++) {
-    valsize = valsize + typesize(sch->getType(j));
-  }
-  
-  char *data = new char[size*valsize];
-  
-  //vector for better allocation
-  vector<Tuple> &tups = *(new vector<Tuple>(size,Tuple(sch)));
-  
-  //ptr structure to satisfy Array requirements.
-  for (int j=0; j<size; j++) {
-    tupptrs[j] = &tups[j];
-  }
-  
-  // Read the data in big chunks if possible
-  while (i<size) {
-    index = i;
-    pos = positions[i];
-    block = 1;
-    while (true) {
-      if (i+1 >= size) break;
-      if (positions[i + 1] != positions[i] + 1) break;
-      ++block;
-      ++i;
-    }
-    f.seekg( offset + pos * valsize, ifstream::beg );
-    f.read((char *) &data[index*valsize], block * valsize);
-    for (int j=0; j<block; j++) {
-      tups[index+j].assign((char *) &data[index*valsize + j*valsize ]);
-      //tups[index+j].print();
-    }
-  //  cout << *(float *) data[0] << endl;
-    i++;
-  }
-}
-
-
-ArrayReader *ArrayReader::makeArrayReader(int *array, int size) {
- stringstream *ss = new stringstream();
- stringbuf *pbuf;
- pbuf=ss->rdbuf();
- pbuf->sputn((char *) array, 4*size);
- return new ArrayReader(ss);
-}
-
-ArrayReader *ArrayReader::makeArrayReader(double *array, int size) {
- stringstream *ss = new stringstream();
- stringbuf *pbuf;
- pbuf=ss->rdbuf();
- pbuf->sputn((char *) array, 32*size);
- return new ArrayReader(ss);
+	}
+
+	switch (t) {
+	case INT:
+
+		for (int i = 0; i < size; i++) {
+			while (line <= positions[i]) {
+				f.getline(textline, 256);
+				line++;
+			}
+			sscanf(textline, "%i", (int *) &data[i]);
+			line++;
+		}
+		break;
+
+	case FLOAT:
+		for (int i = 0; i < size; i++) {
+			while (line < positions[i]) {
+				f.getline(textline, 256);
+				line++;
+			}
+			f.getline(textline, 256);
+			//  cout << textline << endl;
+			sscanf(textline, "%f", (float *) &data[i]);
+			line++;
+
+		}
+		break;
+
+	default:
+		Fatal("ArrayReader: only ints and floats for now...");
+		break;
+	}
+
 }
+
+void ArrayReader::ReadPrimitives(istream &f, int *positions, int size, Type, char *data)
+{
+	int i = 0;
+	int index = 0;
+	int block = 0;
+	int pos = 0;
+
+	//if (!f.is_open()) this->prepFile();
+	if (size == 0) return;
+
+	// NOT PORTABLE
+	int valsize = sizeof(int);
+	f.seekg(positions[0] * valsize + this->offset, ifstream::beg);
+	if (f.eof()) {
+		Fatal("Seek to (%i*%i + %i) past end of file while reading array.", positions[0], valsize, this->offset);
+		f.clear();
+	}
+
+	// Read the data in big chunks if possible
+
+	while (i < size) {
+		index = i;
+		pos = positions[i];
+		block = 1;
+		while (true) {
+			if (i + 1 >= size) break;
+			if (positions[i + 1] != positions[i] + 1) break;
+			++block;
+			++i;
+		}
+		f.seekg(offset + pos * valsize, ifstream::beg);
+		f.read(&(data[index * valsize]), block * valsize);
+		//cout << "value: " << *(float *) &data[index] << ",  " << *(int *) &data[index] << endl;
+		i++;
+	}
+}
+
+void TextFileArrayReader::ReadTuples(istream &f, int *positions, int size, Scheme *sch, UnTypedPtr *tupptrs)
+{
+
+	string format = "";
+	Tuple *t;
+	//int s = sch->size();
+
+	int line = 0;
+	char textline[256];
+
+	//assume offset is in lines instead of bytes
+	for (int x = 0; x < offset; x++) {
+		f.getline(textline, 256);
+	}
+
+	for (int i = 0; i < size; i++) {
+		t = new Tuple(sch);
+
+		//cout << "reading position " << positions[i] << endl;
+		while (line < positions[i]) {
+			f.getline(textline, 256);
+			//cout << "eat tup: " << textline << endl;
+			line++;
+		}
+
+		t->Read(f);
+
+		line++;
+
+		tupptrs[i] = (UnTypedPtr) t;
+		//((Tuple *) tupptrs[i])->print();
+	}
+
+}
+
+void ProjectArrayReader::ReadPrimitives(istream &f, int *positions, int size, Type t, char *data)
+{
+	int i = 0;
+	int index = 0;
+	int block = 0;
+	int pos = 0;
+
+	int valsize = typesize(t);
+	int tuplesize = this->sch.bytesize();
+	int tupleoffset = this->sch.byteposition(this->attr);
+
+	char *scratch = new char[size * tuplesize];
+
+	//cout << "Reading primitives: " << this->attr << ": " << tuplesize << ", " << tupleoffset << endl;
+
+	// Copy the projectedright data in big chunks if possible
+	while (i < size) {
+		index = i;
+		pos = positions[i];
+		block = 1;
+		while (true) {
+			if (i + 1 >= size) break;
+			if (positions[i + 1] != positions[i] + 1) break;
+			++block;
+			++i;
+		}
+		//float r = gettime();
+		f.seekg(offset + pos * tuplesize, ifstream::beg);
+		f.read((char *) &scratch[index * tuplesize], block * tuplesize);
+		//float a = gettime();
+		//cout << "read call: " << block << ", " << index << ", " << r <<" , " << a << ", " << a - r << endl;
+		for (int j = 0; j < block; j++) {
+			for (int k = 0; k < valsize; k++) {
+				data[(index + j) * valsize + k] = scratch[(index + j) * tuplesize + tupleoffset + k];
+			}
+			// cout << *(float *)&data[(index+j)*valsize] << ", "
+		}
+		i++;
+	}
+
+	delete[] scratch;
+}
+
+void ProjectArrayReader::ReadTuples(istream &, int *, int, Scheme *, UnTypedPtr *)
+{
+	Fatal("ReadTuples is deprecated; Arrays with complex schemes are deprecated.");
+
+}
+
+void ArrayReader::ReadTuples(istream &f, int *positions, int size, Scheme *sch, UnTypedPtr *tupptrs)
+{
+	int i = 0;
+	int index = 0;
+	int block = 0;
+	int pos = 0;
+
+	//for each gridfield in the tuple, seek past it and save the location
+	//so: gridfields must store location
+	// need catalog information.
+	// users will find gridfield compoennts based on metadata
+	// mapping metadata to physical locations is a RDBMS job
+	// definitely need to query (using our metadata stuff, probably)
+	// then need to process the query - where?
+	// what about sets of results - how to operate on all at once?
+	// something to do with nesting.
+
+	// NOT PORTABLE
+	int valsize = 0;
+	for (unsigned int j = 0; j < sch->size(); j++) {
+		valsize = valsize + typesize(sch->getType(j));
+	}
+
+	char *data = new char[size * valsize];
+
+	//vector for better allocation
+	vector<Tuple> &tups = *(new vector<Tuple>(size, Tuple(sch)));
+
+	//ptr structure to satisfy Array requirements.
+	for (int j = 0; j < size; j++) {
+		tupptrs[j] = &tups[j];
+	}
+
+	// Read the data in big chunks if possible
+	while (i < size) {
+		index = i;
+		pos = positions[i];
+		block = 1;
+		while (true) {
+			if (i + 1 >= size) break;
+			if (positions[i + 1] != positions[i] + 1) break;
+			++block;
+			++i;
+		}
+		f.seekg(offset + pos * valsize, ifstream::beg);
+		f.read((char *) &data[index * valsize], block * valsize);
+		for (int j = 0; j < block; j++) {
+			tups[index + j].assign((char *) &data[index * valsize + j * valsize]);
+			//tups[index+j].print();
+		}
+		//  cout << *(float *) data[0] << endl;
+		i++;
+	}
+}
+
+ArrayReader *ArrayReader::makeArrayReader(int *array, int size)
+{
+	stringstream *ss = new stringstream();
+	stringbuf *pbuf;
+	pbuf = ss->rdbuf();
+	pbuf->sputn((char *) array, 4 * size);
+	return new ArrayReader(ss);
+}
+
+ArrayReader *ArrayReader::makeArrayReader(double *array, int size)
+{
+	stringstream *ss = new stringstream();
+	stringbuf *pbuf;
+	pbuf = ss->rdbuf();
+	pbuf->sputn((char *) array, 32 * size);
+	return new ArrayReader(ss);
+}
+
+} // namespace GF
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/arrayreader.h gridfields/clib/src/arrayreader.h
--- tag/gridfieldsclib-0.7/src/arrayreader.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/arrayreader.h	2014-05-16 22:57:00.793391865 +0200
@@ -6,7 +6,9 @@
 
 #include <fstream>
 
-using namespace std;
+//using namespace std;
+
+namespace GF {
 
 class Array;
 class Grid;
@@ -14,94 +16,139 @@
 class BindOp;
 
 class ArrayReader {
-  public:
-    ArrayReader() {};
-    virtual ~ArrayReader();
-    ArrayReader(istream *is) : s(is), offset(0) {};
-    ArrayReader(istream *is, long offset) : s(is), offset(offset) {};
-    ArrayReader * makeArrayReader(int *array, int size);
-    ArrayReader * makeArrayReader(double *array, int size);
-    virtual void ReadTuples(istream &f, int *positions, 
-                          int size, Scheme *sch, UnTypedPtr *_data);
-    virtual void ReadPrimitives(istream &f, int *positions, 
-                          int size, Type t, char *data);
-
-    void Read(GridField *Gf, int k, Array *arr);
-    long getOffset() { return offset; };
-    void setOffset(long offset);
-    void setPatternAttribute(string pa) { addrAttribute = pa; }
-    void setStream(istream *s) { this->s = s; };
-
-  private:
-    istream *s;
-  protected:
-    string addrAttribute;
-    long offset;
+public:
+	ArrayReader()
+	{
+	}
+	;
+	virtual ~ArrayReader();
+	ArrayReader(istream *is) :
+			s(is), offset(0)
+	{
+	}
+	;
+	ArrayReader(istream *is, long offset) :
+			s(is), offset(offset)
+	{
+	}
+	;
+	ArrayReader * makeArrayReader(int *array, int size);
+	ArrayReader * makeArrayReader(double *array, int size);
+
+	virtual void ReadTuples(istream &f, int *positions, int size, Scheme *sch, UnTypedPtr *_data);
+	virtual void ReadPrimitives(istream &f, int *positions, int size, Type t, char *data);
+
+	void Read(GridField *Gf, int k, Array *arr);
+	long getOffset()
+	{
+		return offset;
+	}
+	;
+	void setOffset(long offset);
+	void setPatternAttribute(string pa)
+	{
+		addrAttribute = pa;
+	}
+	void setStream(istream *s)
+	{
+		this->s = s;
+	}
+	;
+
+private:
+	istream *s;
+protected:
+	string addrAttribute;
+	long offset;
 };
 
+class FileArrayReader: public ArrayReader {
 
-class FileArrayReader : public ArrayReader {
- 
- friend class BindOp; 
- private:
-  string filename;
-  ifstream *f;
-  ifstream::openmode mode;
-  
-  void setFilename(string &filename); 
-  void prepFile();
- public:
-  FileArrayReader(string fn, long off, string pa);
-  FileArrayReader(string fn, long off=0);
-  FileArrayReader(ifstream *f);
-  ~FileArrayReader();
+	friend class BindOp;
+private:
+	string filename;
+	ifstream *f;
+	ifstream::openmode mode;
+
+	void setFilename(string &filename);
+	void prepFile();
+public:
+	FileArrayReader(string fn, long off, string pa);
+	FileArrayReader(string fn, long off = 0);
+	FileArrayReader(ifstream *f);
+	~FileArrayReader();
 };
 
-class ProjectArrayReader : public FileArrayReader {
-  public:
-    ProjectArrayReader(string fn, 
-                       long off, 
-                       string pa, 
-                       string schstr, 
-                       string a) 
-                       : 
-                       FileArrayReader(fn, off, pa), 
-                       sch(Scheme(schstr)), 
-                       attr(a) {
-      if (!sch.isAttribute(attr)) {
-        Fatal("ProjectArrayReader::cnstr : Attribute '%s' is not an attribute of the scheme '%s'.", attr.c_str(), sch.asString().c_str());
-      }                
-    };
-    ProjectArrayReader(string fn, long off, string schstr, string attr) : FileArrayReader(fn, off), sch(Scheme(schstr)), attr(attr) {};
-    ProjectArrayReader(ifstream *f, string schstr, string attr) : FileArrayReader(f), sch(Scheme(schstr)), attr(attr) {};
-    ~ProjectArrayReader() {};
-
-    Scheme GetScheme() { return sch; };
-    void   SetScheme(Scheme s) { sch = s; };
-
-    void ReadPrimitives(istream &f, int *positions, 
-                          int size, Type t, char *data);
-    void ReadTuples(istream &f, int *positions, 
-                          int size, Scheme *sch, UnTypedPtr *_data);
-  
-  private:
-    Scheme sch;
-    string attr;
-  
+class ProjectArrayReader: public FileArrayReader {
+public:
+	ProjectArrayReader(string fn, long off, string pa, string schstr, string a) :
+			FileArrayReader(fn, off, pa), sch(Scheme(schstr)), attr(a)
+	{
+		if (!sch.isAttribute(attr)) {
+			Fatal("ProjectArrayReader::cnstr : Attribute '%s' is not an attribute of the scheme '%s'.", attr.c_str(),
+					sch.asString().c_str());
+		}
+	}
+	;
+	ProjectArrayReader(string fn, long off, string schstr, string attr) :
+			FileArrayReader(fn, off), sch(Scheme(schstr)), attr(attr)
+	{
+	}
+	;
+	ProjectArrayReader(ifstream *f, string schstr, string attr) :
+			FileArrayReader(f), sch(Scheme(schstr)), attr(attr)
+	{
+	}
+	;
+	~ProjectArrayReader()
+	{
+	}
+	;
+
+	Scheme GetScheme()
+	{
+		return sch;
+	}
+	;
+	void SetScheme(Scheme s)
+	{
+		sch = s;
+	}
+	;
+
+	virtual void ReadPrimitives(istream &f, int *positions, int size, Type t, char *data);
+	virtual void ReadTuples(istream &f, int *positions, int size, Scheme *sch, UnTypedPtr *_data);
+
+private:
+	Scheme sch;
+	string attr;
+
 };
 
-class TextFileArrayReader : public FileArrayReader {
+class TextFileArrayReader: public FileArrayReader {
 
- private:
-  void ReadTuples(ifstream &f, int *positions, 
-                  int size, Scheme *sch, UnTypedPtr *_data);
-  void ReadPrimitives(ifstream &f, int *positions, 
-                      int size, Type t, char *data);
-  
- public:
-  TextFileArrayReader(string fn, long off, string pa) 
-      : FileArrayReader(fn, off, pa) {};
-  TextFileArrayReader(string fn, long off)
-      : FileArrayReader(fn, off) {};
+// private:
+public:
+	// Added 'virtual' to these two function declarations because they
+	// hide virtual methods of the same name in the parent class. jhrg
+	// 4/4/14
+	virtual void ReadPrimitives(/*ifstream: Was hiding base class method 4/4/14 jhrg*/istream &f, int *positions,
+			int size, Type t, char *data);
+
+	virtual void ReadTuples(istream &f, int *positions, int size, Scheme *sch, UnTypedPtr *_data);
+public:
+	TextFileArrayReader(string fn, long off, string pa) :
+			FileArrayReader(fn, off, pa)
+	{
+	}
+	;
+	TextFileArrayReader(string fn, long off) :
+			FileArrayReader(fn, off)
+	{
+	}
+	;
 };
+
+} // namespace GF
+
 #endif /* _ARRAYREADER_H */
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/arraywriter.cc gridfields/clib/src/arraywriter.cc
--- tag/gridfieldsclib-0.7/src/arraywriter.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/arraywriter.cc	2014-05-16 22:57:00.736725199 +0200
@@ -1,3 +1,5 @@
+#include "config_gridfields.h"
+
 #include <fstream>
 #include <stdio.h>
 #include <map>
@@ -9,145 +11,157 @@
 
 using namespace std;
 
-ArrayWriter::ArrayWriter(string fn, long off) {
-  filename = fn;
-  offset = off;
-  addrAttribute = "";
-  f = NULL;
-  this->prepFile();
-}
-
-ArrayWriter::ArrayWriter(string fn, long off, string pa) {
-  filename = fn;
-  offset = off;
-  addrAttribute = pa;
-  f = NULL;
-  this->prepFile();
-}
-
-ArrayWriter::ArrayWriter(ofstream *file) {
-  filename = "";
-  offset = 0;
-  addrAttribute = "";
-  f = file;
-}
-
-void ArrayWriter::setOffset(long offset) {
-  this->offset = offset;
-}
-
-void ArrayWriter::prepFile() {
-  
-  this->f = new ofstream((const char *) filename.c_str(), 
-                         ofstream::app | ofstream::out);
-  if (f->fail()) { 
-    cerr << "Unable to open " << filename << endl;
-    exit(1);
-  }
-  
-  long start = f->tellp();
-  //cout << "seekto " << start + offset << endl;
-  this->f->seekp(start + offset); 
-}
-
-void ArrayWriter::Write(const Dataset &ds, string attr) {
-  
-  int size = ds.Size();
-
-  // Look for the attribute that tells us how to write the array
-  int *positions;
-  if (ds.IsAttribute(addrAttribute)) {
-    Array *addr = ds.GetAttribute(addrAttribute);
-    if (addr->type == INT) {
-      addr->getData(positions);
-    } else {
-      Warning("address attribute '%s' found, but type is not INT", addrAttribute.c_str());
-      
-      float *fpos;
-      addr->getData(fpos);
-      positions = new int[size];
-      for (int i=0; i<size; i++) {
-        //cout << fpos[i] << ", ";
-        positions[i] = int(fpos[i]);
-      }
-    }               
-  } else {
-    //assume ordinal positions
-    positions = new int[size];
-    for (int i = 0; i<size; i++) positions[i] = i;
-  }
-
-  //void **data = new void*[size];
-  long valsize = sizeof(float);
-
-  Array *outbound = ds.GetAttribute(attr);
-  std::map<int, UnTypedPtr> sorted;
-  //int x;
-  //UnTypedPtr val;
+namespace GF {
+
+ArrayWriter::ArrayWriter(string fn, long off)
+{
+	filename = fn;
+	offset = off;
+	addrAttribute = "";
+	f = NULL;
+	this->prepFile();
+}
+
+ArrayWriter::ArrayWriter(string fn, long off, string pa)
+{
+	filename = fn;
+	offset = off;
+	addrAttribute = pa;
+	f = NULL;
+	this->prepFile();
+}
+
+ArrayWriter::ArrayWriter(ofstream *file)
+{
+	filename = "";
+	offset = 0;
+	addrAttribute = "";
+	f = file;
+}
+
+void ArrayWriter::setOffset(long offset)
+{
+	this->offset = offset;
+}
+
+void ArrayWriter::prepFile()
+{
+
+	this->f = new ofstream((const char *) filename.c_str(), ofstream::app | ofstream::out);
+	if (f->fail()) {
+		cerr << "Unable to open " << filename << endl;
+		exit(1);
+	}
+
+	long start = f->tellp();
+	//cout << "seekto " << start + offset << endl;
+	this->f->seekp(start + offset);
+}
+
+void ArrayWriter::Write(const Dataset &ds, string attr)
+{
+
+	int size = ds.Size();
+
+	// Look for the attribute that tells us how to write the array
+	int *positions;
+	if (ds.IsAttribute(addrAttribute)) {
+		Array *addr = ds.GetAttribute(addrAttribute);
+		if (addr->type == INT) {
+			addr->getData(positions);
+		}
+		else {
+			Warning("address attribute '%s' found, but type is not INT", addrAttribute.c_str());
+
+			float *fpos;
+			addr->getData(fpos);
+			positions = new int[size];
+			for (int i = 0; i < size; i++) {
+				//cout << fpos[i] << ", ";
+				positions[i] = int(fpos[i]);
+			}
+		}
+	}
+	else {
+		//assume ordinal positions
+		positions = new int[size];
+		for (int i = 0; i < size; i++)
+			positions[i] = i;
+	}
+
+	//void **data = new void*[size];
+	long valsize = sizeof(float);
+
+	Array *outbound = ds.GetAttribute(attr);
+	std::map<int, UnTypedPtr> sorted;
+	//int x;
+	//UnTypedPtr val;
 //  Gf->getScheme()->print();
 
 //  float tot = 0;
-  for (int j=0; j<size; j++) {
-  //  tot += *(float *) outbound->getValPtr(positions[j]);
-    this->f->write( (const char *) outbound->getValPtr(positions[j]), valsize);
-  }
-  this->setOffset(f->tellp());
+	for (int j = 0; j < size; j++) {
+		//  tot += *(float *) outbound->getValPtr(positions[j]);
+		this->f->write((const char *) outbound->getValPtr(positions[j]), valsize);
+	}
+	this->setOffset(f->tellp());
 //  cout << "sum: " << tot << endl;
-/*
-  for (int j=0; j<size; j++) {
-    x = sorted.size();
-    sorted[positions[j]] = outbound->getValPtr(j);
-    if (x==sorted.size()) {
-    //  cout << j << ", " << positions[j] << ", ";
-    //  val = Gf->getAttributeVal("wetpos", j);
-    //  cout << *(int*)val << endl;
-    }
-  }
-  */
-  /*
-//  cout << "GFsize: " << size << endl;
-//  cout << "size: " << sorted.size() << endl;
-//  f.write( (const char *) &size, 4);
-  map<int, UnTypedPtr>::iterator i = sorted.begin();
-  int index = 0;
-  int block = 0;
-  int pos = 0;
-//  cout << "writing..." << endl; 
-  while ( i != sorted.end() ) {
-//    cout << *(float *)(*i).second << endl;
-    this->f->write( (const char *) (*i).second, valsize );
-    i++;
-  }
-  */
-  /*
-  // Write the data in big chunks if possible
-  while ( i != sorted.end() ) {
-    index = distance(sorted.begin(), i);
-    pos = *i;
-    //    cout << positions[i] << endl;
-    block = 1;
-    while (*(i + 1) == *i + 1) {
-      block++;
-      i++;
-    }
-    //    cout << "read " << block << " values" << endl;
-    f.write((char *) &data[index], block * valsize);
-    //    cout << (float *) data[0] << endl;
-    i++;
-  }
- */
-  /*
-  int zpos, bot;
-  float x, y, z;
-  for (int i=0; i<size; i++) {
-    zpos = *(int *) Gf->getAttributeVal("zpos", i);
-    bot = *(int *) Gf->getAttributeVal("b", i);
-    x = *(float *) Gf->getAttributeVal("x", i);
-    y = *(float *) Gf->getAttributeVal("y", i);
-    z = *(float *) Gf->getAttributeVal("z", i);
-    //cout << x << ", " << y << ", " << z << ", " << bot << ", " << zpos << ", " << ((float *) data)[i] << endl; 
-//    getchar();
-  }
-  */
-  delete [] positions;
+	/*
+	 for (int j=0; j<size; j++) {
+	 x = sorted.size();
+	 sorted[positions[j]] = outbound->getValPtr(j);
+	 if (x==sorted.size()) {
+	 //  cout << j << ", " << positions[j] << ", ";
+	 //  val = Gf->getAttributeVal("wetpos", j);
+	 //  cout << *(int*)val << endl;
+	 }
+	 }
+	 */
+	/*
+	 //  cout << "GFsize: " << size << endl;
+	 //  cout << "size: " << sorted.size() << endl;
+	 //  f.write( (const char *) &size, 4);
+	 map<int, UnTypedPtr>::iterator i = sorted.begin();
+	 int index = 0;
+	 int block = 0;
+	 int pos = 0;
+	 //  cout << "writing..." << endl;
+	 while ( i != sorted.end() ) {
+	 //    cout << *(float *)(*i).second << endl;
+	 this->f->write( (const char *) (*i).second, valsize );
+	 i++;
+	 }
+	 */
+	/*
+	 // Write the data in big chunks if possible
+	 while ( i != sorted.end() ) {
+	 index = distance(sorted.begin(), i);
+	 pos = *i;
+	 //    cout << positions[i] << endl;
+	 block = 1;
+	 while (*(i + 1) == *i + 1) {
+	 block++;
+	 i++;
+	 }
+	 //    cout << "read " << block << " values" << endl;
+	 f.write((char *) &data[index], block * valsize);
+	 //    cout << (float *) data[0] << endl;
+	 i++;
+	 }
+	 */
+	/*
+	 int zpos, bot;
+	 float x, y, z;
+	 for (int i=0; i<size; i++) {
+	 zpos = *(int *) Gf->getAttributeVal("zpos", i);
+	 bot = *(int *) Gf->getAttributeVal("b", i);
+	 x = *(float *) Gf->getAttributeVal("x", i);
+	 y = *(float *) Gf->getAttributeVal("y", i);
+	 z = *(float *) Gf->getAttributeVal("z", i);
+	 //cout << x << ", " << y << ", " << z << ", " << bot << ", " << zpos << ", " << ((float *) data)[i] << endl;
+	 //    getchar();
+	 }
+	 */
+	delete[] positions;
 }
+
+} // namespace GF
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/arraywriter.h gridfields/clib/src/arraywriter.h
--- tag/gridfieldsclib-0.7/src/arraywriter.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/arraywriter.h	2014-05-16 22:57:00.740058533 +0200
@@ -4,28 +4,31 @@
 #include <string>
 #include "dataset.h"
 
+//using namespace std;
 
-using namespace std;
+namespace GF {
 
 class Array;
 class Grid;
 
 class ArrayWriter {
 
- public:
-  ArrayWriter(string fn, long off, string pa);
-  ArrayWriter(string fn, long off=0);
-  ArrayWriter(ofstream *f);
-
-  void Write(const Dataset &ds, string attr);
-  
- private:
-  string filename;
-  long offset;
-  ofstream *f;
-  string addrAttribute;
-  void prepFile();
-  void setOffset(long off);
+public:
+	ArrayWriter(string fn, long off, string pa);
+	ArrayWriter(string fn, long off = 0);
+	ArrayWriter(ofstream *f);
+
+	void Write(const Dataset &ds, string attr);
+
+private:
+	string filename;
+	long offset;
+	ofstream *f;
+	string addrAttribute;
+	void prepFile();
+	void setOffset(long off);
 };
 
+} // namespace GF
+
 #endif /* _ARRAYWRITER_H */
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/assignments.cc gridfields/clib/src/assignments.cc
--- tag/gridfieldsclib-0.7/src/assignments.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/assignments.cc	2014-05-16 22:57:00.816725198 +0200
@@ -1,42 +1,47 @@
-#include "assignments.h"
+#include "config_gridfields.h"
 
-int Assign::pnpoly(int npol, float *xp, float *yp, float x, float y) {
-  int i, j, c = 0;
-  for (i = 0, j = npol-1; i < npol; j = i++) {
-    if ((((yp[i] <= y) && (y < yp[j])) ||
-       ((yp[j] <= y) && (y < yp[i]))) &&
-       (x < (xp[j] - xp[i]) * (y - yp[i]) / (yp[j] - yp[i]) + xp[i]))
-       c = !c;
-  }
-  return c;
-};
+#include "assignments.h"
 
-bool Assign::TestCallback(long unsigned id, void *arg) {
-  set<CellId> *out = (set<CellId> *) arg;
-  out->insert(id);
-  //std::cout << "hit: " << id << std::endl;
-  return true;
+int Assign::pnpoly(int npol, float *xp, float *yp, float x, float y)
+{
+	int i, j, c = 0;
+	for (i = 0, j = npol - 1; i < npol; j = i++) {
+		if ((((yp[i] <= y) && (y < yp[j])) || ((yp[j] <= y) && (y < yp[i])))
+				&& (x < (xp[j] - xp[i]) * (y - yp[i]) / (yp[j] - yp[i]) + xp[i])) c = !c;
+	}
+	return c;
 }
+;
 
-bool Assign::equal(Type t, UnTypedPtr p, UnTypedPtr q) {bool ret;
-      switch (t) {
-        case FLOAT:
-          ret= *(float *)p == *(float *)q;
-          break;
-        case INT:
-          ret= *(int *)p == *(int *)q;
-          break;
-        case OBJ:
-          ret= p == q;
-        case TUPLE:
-          ret= p == q;
-          exit(1);
-        case GRIDFIELD:
-          ret= p == q;
-          exit(1);
-        default:
-          ret= p==q;
-          exit(1);
-      }
-return ret;}
+bool Assign::TestCallback(long unsigned id, void *arg)
+{
+	set<CellId> *out = (set<CellId> *) arg;
+	out->insert(id);
+	//std::cout << "hit: " << id << std::endl;
+	return true;
+}
 
+bool Assign::equal(Type t, UnTypedPtr p, UnTypedPtr q)
+{
+	bool ret;
+	switch (t) {
+	case FLOAT:
+		ret = *(float *) p == *(float *) q;
+		break;
+	case INT:
+		ret = *(int *) p == *(int *) q;
+		break;
+	case OBJ:
+		ret = p == q;
+	case TUPLE:
+		ret = p == q;
+		exit(1);
+	case GRIDFIELD:
+		ret = p == q;
+		exit(1);
+	default:
+		ret = p == q;
+		exit(1);
+	}
+	return ret;
+}
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/assignments.h gridfields/clib/src/assignments.h
--- tag/gridfieldsclib-0.7/src/assignments.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/assignments.h	2014-05-16 22:57:00.816725198 +0200
@@ -11,863 +11,953 @@
 
 namespace Assign {
 
+using namespace GF;
+
 bool equal(Type t, UnTypedPtr p, UnTypedPtr q);
-bool TestCallback(long unsigned id, void *arg); 
-int pnpoly(int npol, float *xp, float *yp, float x, float y) ;
+bool TestCallback(long unsigned id, void *arg);
+int pnpoly(int npol, float *xp, float *yp, float x, float y);
+
+class Both: public AssignmentFunction {
+public:
+	AssignmentFunction &left;
+	AssignmentFunction &right;
+
+	Both(AssignmentFunction &left, AssignmentFunction &right) :
+			left(left), right(right)
+	{
+	}
+	;
+
+	virtual void operator()(const CellId &c, vector<CellId> &out)
+	{
+		vector<CellId> leftcells;
+		vector<CellId> rightcells;
+
+		set<CellId> leftset;
+		set<CellId> rightset;
+
+		left(c, leftcells);
+		right(c, rightcells);
+
+		leftset.insert(leftcells.begin(), leftcells.end());
+		rightset.insert(rightcells.begin(), rightcells.end());
+
+		insert_iterator<vector<CellId> > ii(out, out.begin());
+
+		set_intersection(leftset.begin(), leftset.end(), rightset.begin(), rightset.end(), ii);
 
-class Both : public AssignmentFunction {
-  public:
-    AssignmentFunction &left;
-    AssignmentFunction &right;
-    
-    Both(AssignmentFunction &left, AssignmentFunction &right) :
-         left(left), right(right) { };
-
-    virtual void operator()(const CellId &c, vector<CellId> &out) {
-      vector<CellId> leftcells;
-      vector<CellId> rightcells;
-
-      set<CellId> leftset;
-      set<CellId> rightset;
-      
-      left(c, leftcells);
-      right(c, rightcells);
-
-      leftset.insert(leftcells.begin(), leftcells.end());
-      rightset.insert(rightcells.begin(), rightcells.end());
-
-      insert_iterator<vector<CellId> > ii(out, out.begin());
-      
-      set_intersection(leftset.begin(), leftset.end(),
-                       rightset.begin(), rightset.end(),
-                       ii);
-      
-    };
-    
-    void setEnvironment(GridField *t, Dim_t i, GridField *s, Dim_t j) { 
-      this->T=t;
-      this->S=s;
-      this->_i = i;
-      this->_j = j;
-      left.setEnvironment(t,i,s,j);
-      right.setEnvironment(t,i,s,j);
-    };
-};
-
-class Either : public AssignmentFunction {
-  public:
-    AssignmentFunction &left;
-    AssignmentFunction &right;
-    
-    Either(AssignmentFunction &left, AssignmentFunction &right) :
-         left(left), right(right) { };
-
-    virtual void operator()(const CellId &c, vector<CellId> &out) {
-      vector<CellId> leftcells;
-      vector<CellId> rightcells;
-
-      set<CellId> uniquecells;
-      
-      left(c, leftcells);
-      right(c, rightcells);
-
-      uniquecells.insert(leftcells.begin(), leftcells.end());
-      uniquecells.insert(rightcells.begin(), rightcells.end());
-
-      out.insert(out.begin(), uniquecells.begin(), uniquecells.end());
-    };
-     
-    void setEnvironment(GridField *t, Dim_t i, GridField *s, Dim_t j) {
-      this->T=t;
-      this->S=s;
-      this->_i = i;
-      this->_j = j;
-      left.setEnvironment(t,i,s,j);
-      right.setEnvironment(t,i,s,j);
-    };
-};
-
-class IncidentTo : public AssignmentFunction {
-  public:
-  IncidentTo() {};
-  virtual void operator()(const CellId &cid, 
-                                      vector<CellId> &out) {
-    S->GetGrid()->IncidentTo(cid, this->_i, out, this->_j);
-  }
+	}
+	;
+
+	void setEnvironment(GridField *t, Dim_t i, GridField *s, Dim_t j)
+	{
+		this->T = t;
+		this->S = s;
+		this->_i = i;
+		this->_j = j;
+		left.setEnvironment(t, i, s, j);
+		right.setEnvironment(t, i, s, j);
+	}
+	;
+};
+
+class Either: public AssignmentFunction {
+public:
+	AssignmentFunction &left;
+	AssignmentFunction &right;
+
+	Either(AssignmentFunction &left, AssignmentFunction &right) :
+			left(left), right(right)
+	{
+	}
+	;
+
+	virtual void operator()(const CellId &c, vector<CellId> &out)
+	{
+		vector<CellId> leftcells;
+		vector<CellId> rightcells;
+
+		set<CellId> uniquecells;
+
+		left(c, leftcells);
+		right(c, rightcells);
+
+		uniquecells.insert(leftcells.begin(), leftcells.end());
+		uniquecells.insert(rightcells.begin(), rightcells.end());
+
+		out.insert(out.begin(), uniquecells.begin(), uniquecells.end());
+	}
+	;
+
+	void setEnvironment(GridField *t, Dim_t i, GridField *s, Dim_t j)
+	{
+		this->T = t;
+		this->S = s;
+		this->_i = i;
+		this->_j = j;
+		left.setEnvironment(t, i, s, j);
+		right.setEnvironment(t, i, s, j);
+	}
+	;
+};
+
+class IncidentTo: public AssignmentFunction {
+public:
+	IncidentTo()
+	{
+	}
+	;
+	virtual void operator()(const CellId &cid, vector<CellId> &out)
+	{
+		S->GetGrid()->IncidentTo(cid, this->_i, out, this->_j);
+	}
 };
 /*
-class ToIncident : public AssignmentFunction {
-  public:
-  int dim;
-  ToIncident(int d) : dim(d) {};
-  virtual void ToIncident::operator()(const CellId &cid, 
-                                      vector<CellId> &out) {
-    S->GetGrid()->ToIncident(cid, d, out);
-  }
-}
-*/
-
-class Nodes : public AssignmentFunction {
-  public:
-  Nodes() {};
-  virtual void operator()(const CellId &cid, vector<CellId> &out) {
-    Cell *c = T->getKCell(this->_i, cid);
-    for (unsigned int i=0; i<c->getsize(); i++) {
-      out.push_back(c->getnodes()[i]);
-    }
-  }
-};
-
-class adjacentNodes : public AssignmentFunction {
-  // I_{0k0}
-  // find vertices incident to some k-cell to which I am also incident
-  public:
-  adjacentNodes(Dim_t k) :k(k) { };
-
-  virtual void setEnvironment(GridField *t, Dim_t i, 
-                              GridField *s, Dim_t j) {
-    this->T=t;
-    this->S=s; 
-    assert(((i==0) & (j==0)));
-    this->_i = i;
-    this->_j = j;
-    this->kcells = S->GetGrid()->getKCells(this->k);
-    this->zerocells = T->GetGrid()->getKCells(0);
-  }
-
-  virtual void operator()(const CellId &c, vector<CellId> &out) {
-    Cell *nc = this->zerocells->getCell(c);
-    assert(nc->getsize()==1);
-    Node m = nc->getnodes()[0];
-
-    Cell *kc;
-    set<CellId> ks;
-    this->kcells->getIncidentCells(m, ks);
-    FOR(set<CellId>, kci, ks) {
-      kc = this->kcells->getCell(*kci);
-      for (unsigned int i=0; i<kc->getsize(); i++) {
-        Node n = kc->getnodes()[i];
-        if (n != m) out.push_back(n);
-      }
-    }
-  }
-                                                                            
-  private:
-    AbstractCellArray *kcells;
-    AbstractCellArray *zerocells;
-    Dim_t k;
-};
-
-class adjacent : public AssignmentFunction {
-  // I_{i0j} 
-  // find j-cells to which one of my vertices is incident
-  public:
-  adjacent() {};
-  virtual void setEnvironment(GridField *t, Dim_t i, 
-                              GridField *s, Dim_t j) {
-    this->T=t;
-    this->S=s; 
-    this->_i = i;
-    this->_j = j;
-    this->cells = S->GetGrid()->getKCells(this->_j);
-
-  /*
-    // build adjacency index
-    Grid *G = S->GetGrid();
-    unsigned int n = S->Size(this->_j);
-
-    adj.clear();
-    adj.resize(n);
-
-    set<CellId> adjs;
-    for (int i=0; i<n; i++) {
-      S->GetGrid()->adjacent(this->_j, i, adjs);
-      adj[i].insert(adj[i].end(), adjs.begin(), adjs.end());
-      adjs.clear();
-    }
-  */
-  }
-  
-  virtual void operator()(const CellId &c, vector<CellId> &out) {
-    this->cells->getAdjacentCells(c, out);
-    //COPY(vector<CellId>, adj[c], out, ii); 
-  }
+ class ToIncident : public AssignmentFunction {
+ public:
+ int dim;
+ ToIncident(int d) : dim(d) {};
+ virtual void ToIncident::operator()(const CellId &cid,
+ vector<CellId> &out) {
+ S->GetGrid()->ToIncident(cid, d, out);
+ }
+ }
+ */
+
+class Nodes: public AssignmentFunction {
+public:
+	Nodes()
+	{
+	}
+	;
+	virtual void operator()(const CellId &cid, vector<CellId> &out)
+	{
+		Cell *c = T->getKCell(this->_i, cid);
+		for (unsigned int i = 0; i < c->getsize(); i++) {
+			out.push_back(c->getnodes()[i]);
+		}
+	}
+};
+
+class adjacentNodes: public AssignmentFunction {
+	// I_{0k0}
+	// find vertices incident to some k-cell to which I am also incident
+public:
+	adjacentNodes(Dim_t k) :
+			k(k)
+	{
+	}
+	;
+
+	virtual void setEnvironment(GridField *t, Dim_t i, GridField *s, Dim_t j)
+	{
+		this->T = t;
+		this->S = s;
+		assert(((i == 0) & (j == 0)));
+		this->_i = i;
+		this->_j = j;
+		this->kcells = S->GetGrid()->getKCells(this->k);
+		this->zerocells = T->GetGrid()->getKCells(0);
+	}
 
-  private:
-    AbstractCellArray *cells;
+	virtual void operator()(const CellId &c, vector<CellId> &out)
+	{
+		Cell *nc = this->zerocells->getCell(c);
+		assert(nc->getsize() == 1);
+		Node m = nc->getnodes()[0];
+
+		Cell *kc;
+		set<CellId> ks;
+		this->kcells->getIncidentCells(m, ks);
+		FOR(set<CellId>, kci, ks)
+		{
+			kc = this->kcells->getCell(*kci);
+			for (unsigned int i = 0; i < kc->getsize(); i++) {
+				Node n = kc->getnodes()[i];
+				if (n != m) out.push_back(n);
+			}
+		}
+	}
+
+private:
+	AbstractCellArray *kcells;
+	AbstractCellArray *zerocells;
+	Dim_t k;
+};
+
+class adjacent: public AssignmentFunction {
+	// I_{i0j}
+	// find j-cells to which one of my vertices is incident
+public:
+	adjacent()
+	{
+	}
+	;
+	virtual void setEnvironment(GridField *t, Dim_t i, GridField *s, Dim_t j)
+	{
+		this->T = t;
+		this->S = s;
+		this->_i = i;
+		this->_j = j;
+		this->cells = S->GetGrid()->getKCells(this->_j);
+
+		/*
+		 // build adjacency index
+		 Grid *G = S->GetGrid();
+		 unsigned int n = S->Size(this->_j);
+
+		 adj.clear();
+		 adj.resize(n);
+
+		 set<CellId> adjs;
+		 for (int i=0; i<n; i++) {
+		 S->GetGrid()->adjacent(this->_j, i, adjs);
+		 adj[i].insert(adj[i].end(), adjs.begin(), adjs.end());
+		 adjs.clear();
+		 }
+		 */
+	}
+
+	virtual void operator()(const CellId &c, vector<CellId> &out)
+	{
+		this->cells->getAdjacentCells(c, out);
+		//COPY(vector<CellId>, adj[c], out, ii);
+	}
+
+private:
+	AbstractCellArray *cells;
 };
 /*
-class I : public AssignmentFunction {
-  public:
-  //I(Dim_t i, Dim_t j) 
-  virtual void setEnvironment(GridField *t, Dim_t i,
-                              GridField *s, Dim_t j) {
-    this->T=t;
-    this->S=s;
-    this->_i = i;
-    this->_j = j;
-    this->cells = S->GetGrid()->getKCells(this->_j);
-  }
-
-  virtual void I::operator()(const CellId &cid, vector<CellId> &out) {
-    
-  }
-
-};
-*/
-class neighbors : public AssignmentFunction {
-  public:
-  virtual void operator()(const CellId &cid, vector<CellId> &out) {
-    
-    Cell *nc = T->getKCell(this->_i, cid);
-    
-    set<CellId> setOut;
-    AbstractCellArray *dcells = S->GetGrid()->getKCells(this->_j);
-    for (unsigned int i=0; i<nc->getsize(); i++) {
-      dcells->getIncidentCells(nc->getnodes()[i], setOut);
-    }
-
-    set<CellId>::iterator p;
-    for (p=setOut.begin(); p!=setOut.end(); p++) {
-      out.push_back(*p);
-    }
-  }
-};
-
-
-class intervalContains : public AssignmentFunction {
-  public:
-    string rangeattr;
-    string valueattr;
-    string pointattr;
-    intervalContains(string ra, string va, string pa) 
-        : rangeattr(ra), valueattr(va), pointattr(pa)
-    {
-    };
-
-   virtual void operator()(const CellId &c, vector<CellId>&out) {
-      Tuple t(&schtarget); 
-      dstarget->FastBindTuple(c, t);
-      
-      UnTypedPtr r = t.get(rangeattr);
-
-      vector<Tuple *> *rng = (vector<Tuple *> *) r;
-     
-      assert(rng->size() == 2);
-       
-      float v1 = *(float *) (*rng)[0]->get(valueattr);
-      float v2 = *(float *) (*rng)[1]->get(valueattr);
- 
-      float v;     
-      
-      for (unsigned int i=0; i<S->Size(this->_j); i++) {
-         v = *(float *) dssource->GetAttributeVal(pointattr, i);
-         if ((v >= v1) & (v < v2)) {
-           out.push_back(i);
-         }
-      } 
-      
-    }
+ class I : public AssignmentFunction {
+ public:
+ //I(Dim_t i, Dim_t j)
+ virtual void setEnvironment(GridField *t, Dim_t i,
+ GridField *s, Dim_t j) {
+ this->T=t;
+ this->S=s;
+ this->_i = i;
+ this->_j = j;
+ this->cells = S->GetGrid()->getKCells(this->_j);
+ }
+
+ virtual void I::operator()(const CellId &cid, vector<CellId> &out) {
+
+ }
+
+ };
+ */
+class neighbors: public AssignmentFunction {
+public:
+	virtual void operator()(const CellId &cid, vector<CellId> &out)
+	{
+
+		Cell *nc = T->getKCell(this->_i, cid);
+
+		set<CellId> setOut;
+		AbstractCellArray *dcells = S->GetGrid()->getKCells(this->_j);
+		for (unsigned int i = 0; i < nc->getsize(); i++) {
+			dcells->getIncidentCells(nc->getnodes()[i], setOut);
+		}
+
+		set<CellId>::iterator p;
+		for (p = setOut.begin(); p != setOut.end(); p++) {
+			out.push_back(*p);
+		}
+	}
+};
+
+class intervalContains: public AssignmentFunction {
+public:
+	string rangeattr;
+	string valueattr;
+	string pointattr;
+	intervalContains(string ra, string va, string pa) :
+			rangeattr(ra), valueattr(va), pointattr(pa)
+	{
+	}
+	;
+
+	virtual void operator()(const CellId &c, vector<CellId>&out)
+	{
+		Tuple t(&schtarget);
+		dstarget->FastBindTuple(c, t);
+
+		UnTypedPtr r = t.get(rangeattr);
+
+		vector<Tuple *> *rng = (vector<Tuple *> *) r;
+
+		assert(rng->size() == 2);
+
+		float v1 = *(float *) (*rng)[0]->get(valueattr);
+		float v2 = *(float *) (*rng)[1]->get(valueattr);
+
+		float v;
+
+		for (unsigned int i = 0; i < S->Size(this->_j); i++) {
+			v = *(float *) dssource->GetAttributeVal(pointattr, i);
+			if ((v >= v1) & (v < v2)) {
+				out.push_back(i);
+			}
+		}
+
+	}
 };
 
 template<typename ValueType>
-class memberof : public AssignmentFunction {
-  public:
-    string item_attr;
-    string set_attr;
-    string set_value_attr;
-    
-    memberof(string item_attr, string set_attr, string set_value_attr) 
-                   : item_attr(item_attr), 
-                     set_attr(set_attr), 
-                     set_value_attr(set_value_attr) {};
-    
-    virtual void operator()(const CellId &c, vector<CellId> &out) {
-      Tuple t(&schtarget); 
-      dstarget->FastBindTuple(c, t);
-      
-      ValueType v = *(ValueType *) t.get(item_attr);
-      
-      vector<Tuple *> *vec;
-      
-      ValueType tst;
-      
-      vector<Tuple *>::iterator p;
-      for (unsigned int i=0; i<dssource->Size(); i++) {       
-        vec = (vector<Tuple *> *) dssource->GetAttributeVal(set_attr, i);
-        for (p=vec->begin(); p!=vec->end(); p++) {
-          tst = *(ValueType *) (*p)->get(set_value_attr);
-          if (tst == v) {
-            out.push_back(i);
-            break;
-          }
-          
-        }        
-      }
-    };
-};
-
-class byPointerSet : public AssignmentFunction {
-  public:
-    byPointerSet(string sa, string pa) : setattr(sa), pattr(pa) {}; 
-    
-    virtual void operator()(const CellId &c, vector<CellId>&out) {
-      Tuple t(&schtarget);
-      dstarget->FastBindTuple(c, t);
-      vector<Tuple> &pset = *(vector<Tuple> *) t.get(setattr);
-
-      for (unsigned int i=0; i<pset.size(); i++) {
-        out.push_back(*(CellId *)pset[i].get(pattr));
-      }
-    }; 
-  private:
-    string setattr;
-    string pattr;
-};
-
-class nearest : public AssignmentFunction {
-  public: 
-    string a;  //S attribute
-    string b;  //T attribute
-    nearest(string attra, string attrb) { a = attra; b = attrb;  }; 
-    nearest(string attra) { a = attra; b = attra;  }; 
-    virtual void operator()(const CellId &c, vector<CellId>&out) {
-      Tuple t(&schtarget); 
-      dstarget->FastBindTuple(c, t);
-      UnTypedPtr p = t.get(a);
-      S->nearest(b, _j, p, out);
-    }
-};
-
-
-class sortedmatch : public AssignmentFunction {
-   CellId position;
-   string Tattr;
-   string Sattr;
-   Type type;
-  public:
-   virtual void setEnvironment(GridField *t, Dim_t i, 
-                               GridField *s, Dim_t j) {
-      position = 0;
-      T=t; S=s; _i=i; _j=j;
-      dstarget = &T->GetDataset(_i);
-      dssource = &S->GetDataset(_j);
-      schtarget = dstarget->GetScheme();
-      schsource = dssource->GetScheme();
-      Type tt = schtarget.getType(Tattr);
-      Type st = schsource.getType(Sattr);
-      if (tt != st) {
-        Fatal("Target attribute '%s' is type '%i', but source attribute '%s' is type '%i'.", Tattr.c_str(), tt, Sattr.c_str(), st);
-      }
-      type = tt;
-   }
-   
-   sortedmatch(string a, string b) : Tattr(a), Sattr(b) {};
-   sortedmatch(string a) : Tattr(a), Sattr(a) {};
-
-   virtual void operator()(const CellId &c, vector<CellId>&out) {
-      Tuple t(&schtarget); 
-      dstarget->FastBindTuple(c, t);
-      if (t.isNull()) {
-        cout << Tattr << endl;
-        T->PrintTo(cout, 5);
-        Fatal("Cell not found.");
-      }
-      UnTypedPtr p = t.get(Tattr);
-      Tuple s(&schsource);
-      UnTypedPtr val;
-      unsigned int size = S->Size(_j);
-      while (position < size) {
-        dssource->FastBindTuple(position, s);
-        val = s.get(Sattr);
-        if (equal(type, val, p)) {
-          out.push_back(position++);
-        } else {
-          break;
-        }
-      }
-      /*
-      int count = -1;
-      int last = S->Size(_j) - 1;
-      do {
-        count++;
-        dssource->FastBindTuple(position+count, s);
-        cout << position << ", " << count << ", " << last << endl;
-        val = s.get(Sattr);
-        s.print();
-      } while (equal(type, val, p) && (position+count < last));
-   
-      for (int i=0; i<count; i++){
-        out.push_back(position++);
-      }
-      */
-   }
-};
-
-class match : public AssignmentFunction {
-  public:
-    string Tattr;
-    string Sattr;
-    
-    match(string a, string b) : Tattr(a), Sattr(b) { }; 
-    match(string a) : Tattr(a), Sattr(a) { }; 
-/*
-    virtual void setEnvironment(GridField *t, Dim_t i, 
-                                GridField *s, Dim_t j) {
-      this->T=t;
-      this->S=s; 
-      this->_i = i;
-      this->_j = j;
-      this->cells = S->GetGrid()->getKCells(this->_j);
-    } 
-*/
-    virtual void operator()(const CellId &c, vector<CellId>&out) {
-      /*
-	if (!T->isAttribute(attr.c_str()) || !S->isAttribute(attr.c_str())) {
-	return;
-	}
-      */
-      //      cout << "evaluate gridfield..." << endl;
-      //cout << "m:" << c.nodes[0] << endl;
-      
-      Tuple t(&schtarget); 
-      dstarget->FastBindTuple(c, t);
-      if (t.isNull()) {
-        cout << Tattr << endl;
-        T->PrintTo(cout, 5);
-        Fatal("Cell not found.");
-      }
-      //t.print();
-      
-      if (schtarget.getType(Tattr) != schsource.getType(Sattr)) {
-        Fatal(("Type mismatch: type(" + Tattr + ") != type("+Sattr +")").c_str());
-      }
-
-      UnTypedPtr p = t.get(Tattr);
-      switch (schtarget.getType(Tattr)) {
-        case FLOAT:
-          S->lookupFloat(Sattr, _j, *(float *)p, out);
-	  break;
-        case INT:
-          S->lookupInt(Sattr, _j, *(int *)p, out);
-	  break;
-        case OBJ:
-          S->lookupInt(Sattr, _j, *(int *)p, out);
-	  break;
-        case TUPLE:
-          S->lookupInt(Sattr, _j, *(int *)p, out);
-	  break;
-        case GRIDFIELD:
-          S->lookupInt(Sattr, _j, *(int *)p, out);
-	  break;
-      }
-      //cout << *(int *) p << ", " << Tattr << endl;
-      //cout << *(int *)T->getAttributeVal(Tattr.c_str(), 0) << endl;
-      //cout << out.size() << " -> ";
-      //cout << "any? " << out.size() << endl;
-    }
-
-};
-
-class pointpoly2 : public AssignmentFunction {
-  public:
-    virtual void operator()(const CellId &c, vector<CellId>&out) {
-      typedef vector<Tuple *> Poly;
-
-      Tuple tup(&schsource);
-      Poly poly;
-      int pts;
-      
-      //the target point
-      Tuple t(&schtarget); 
-      dstarget->FastBindTuple(c, t);
-      float x = *(float *)t.get("x");
-      float y = *(float *)t.get("y");
-      
-      float xs[10];
-      float ys[10];
-      
-      //for each cell in the source grid
-      for (unsigned int i=0; i<S->Size(this->_j); i++) {
-        dssource->FastBindTuple(i, tup);
-        poly = *(Poly *) tup.get("poly");
-        pts = poly.size();
-        if (pts==0) continue;
-        
-        for (int j=0; j<pts; j++) {
-          xs[j] = *(float *)poly[j]->get("x");
-          ys[j] = *(float *)poly[j]->get("y");
-        }
-      
-        if (pnpoly(pts, xs, ys, x, y)) {
-          out.push_back(i);
-        }
-      }
-    }
-};
-
-class containedby : public AssignmentFunction {
-  //from source polgons to target points
-  //max polygon size is 10.
-  
-  public:
-    
-    virtual void operator()(const CellId &c, vector<CellId>&out) {
-      
-      float x;
-      float y;
-      x = *(float *)dstarget->GetAttributeVal("x", c);
-      y = *(float *)dstarget->GetAttributeVal("y", c);
-      
-      for (unsigned int i=0; i<S->Size(this->_j); i++) {
-        if (PointInCell(x,y,i)) {
-          out.push_back(i);
-        }
-      }
-    }
-    
-    bool PointInCell(float x, float y, CellId i) {
-      typedef vector<Tuple> Poly;
-      Poly *poly;
-      Tuple *t;
-      Tuple polytup(&schsource); 
-      
-      float xs[10];
-      float ys[10];
-
-      bool containedBy = false;
-      dssource->FastBindTuple(i, polytup);
-      poly = *(Poly **)polytup.get("poly");
-      int s = poly->size(); 
-        
-      assert(s<=10);
-
-      for (int j=0; j<s; j++) {
-        t = &(*poly)[j];
-        xs[j] = *(float *)t->get("x");
-        ys[j] = *(float *)t->get("y");
-      }
-      if (pnpoly(s, xs, ys, x, y)) {
-        containedBy = true;
-      }
-
-      return containedBy;
-    }
-};
-
-class fastcontainedby : public containedby {
-  // Uses an in-memory RTree to speed up the spatial join
-  
-  RTree<CellId, float, 2> tree;
-  
-  public:
-    virtual void setEnvironment(GridField *t, Dim_t i, GridField *s, Dim_t j) {
-      AssignmentFunction::setEnvironment(t,i,s,j);
-      assert(i == 0);
-      assert(S->GetGrid()->getdim() == 2);
-
-      tree.RemoveAll();
-      
-      Tuple *tup;
-      Tuple polytup(&schsource); 
-
-      for (unsigned int i=0; i<S->Size(this->_j); i++) {
-        dssource->FastBindTuple(i, polytup);
-        typedef vector<Tuple> Poly;
-        Poly *poly;
-
-        poly = *(Poly **)polytup.get("poly");
-        int s = poly->size(); 
-        
-        float x,y;
-        float min[2];
-        float max[2];
-          
-        tup = &(*poly)[0];
-        x = *(float *)tup->get("x");
-        y = *(float *)tup->get("y");
-        min[0] = x;
-        min[1] = y;
-        max[0] = x;
-        max[1] = y;
-        
-        for (int j=1; j<s; j++) {
-          tup = &(*poly)[j];
-          x = *(float *)tup->get("x");
-          y = *(float *)tup->get("y");
-          if (x < min[0]) min[0] = x;
-          if (x > max[0]) max[0] = x;
-          if (y < min[1]) min[1] = y;
-          if (y > max[1]) max[1] = y;
-        }
-        
-        tree.Insert(min, max, i); // Note, all values including zero are fine in this version
-      }
-    }
-    
-    virtual void operator()(const CellId &c, vector<CellId>&out) {
-
-      float x, y;
-      float coords[2];
-      
-      x = *(float *)dstarget->GetAttributeVal("x", c);
-      y = *(float *)dstarget->GetAttributeVal("y", c);
-      
-      coords[0] = x;
-      coords[1] = y;
-      
-      set<CellId> hits;
-      
-      assert((unsigned)tree.Search(coords, coords, TestCallback, &hits)==hits.size());
-      
-      set<CellId>::iterator it;
-      for (it=hits.begin(); it!=hits.end(); it++) {
-        if (PointInCell(x,y,*it)) {
-          cout << "cell id containing:" << *it << endl;
-          out.push_back(*it);
-        }
-      }
-    }
-
-};
- 
-class contains : public AssignmentFunction {
-  //from source points to target polygons
-  public:
-    
-    virtual void operator()(const CellId &c, vector<CellId>&out) {
-      assert(T->GetGrid()->getdim() == 2);
-      typedef vector<Tuple> Poly;
-      Poly *poly;
-      
-      Tuple *t;
-      Tuple polytup(&schtarget); 
-      dstarget->FastBindTuple(c, polytup);
-      poly = *(Poly **)polytup.get("poly");
-      
-      
-      int s = poly->size(); 
-     
-      float *xs = new float[s];
-      float *ys = new float[s];
-      
-      for (int j=0; j<s; j++) {
-        t = &(*poly)[j];
-        xs[j] = *(float *)t->get("x");
-        ys[j] = *(float *)t->get("y");
-        //cout << " | " << xs[j] << ", " << ys[j];
-      }
-      //cout << "----" << endl;
-      
-
-      float x;
-      float y;
-      for (unsigned int i=0; i<S->Size(this->_j); i++) {
-        x = *(float *)dssource->GetAttributeVal("x", i);
-        y = *(float *)dssource->GetAttributeVal("y", i);
-        if (pnpoly(s, xs, ys, x, y)) {
-          out.push_back(i);
-        }
-      }
-         
-    }
-};
-
-class pointpoly : public AssignmentFunction {
-  
-  public:
-    float xs[10];
-    float ys[10];
-    
-  /* Expects 2-dimensional gridfields with geometry 
-   * defined on the nodes as attributes "x" and "y"
-   * Returns the nodes incident to the cells in S that 
-   * contain the target cell.
-   * Requires that the source grid be normalized
-   * maximum polygon size is 10 nodes.
-   */
-    
-    virtual void operator()(const CellId &c, vector<CellId>&out) {
-      assert(S->GetGrid()->getdim() == 2);
-      int s = 0; 
-      Tuple t(&schtarget); 
-      dstarget->FastBindTuple(c, t);
-      float x = *(float *)t.get("x");
-      float y = *(float *)t.get("y");
-      AbstractCellArray *twocells = S->GetGrid()->getKCells(2);
-      Cell *Sc;
-
-      int zt, zs, b;
-      int *hck;
-      int tpos;
-      
-      //cout << "checking point " << c.nodes[0] << "...." << flush;
+class memberof: public AssignmentFunction {
+public:
+	string item_attr;
+	string set_attr;
+	string set_value_attr;
+
+	memberof(string item_attr, string set_attr, string set_value_attr) :
+			item_attr(item_attr), set_attr(set_attr), set_value_attr(set_value_attr)
+	{
+	}
+	;
+
+	virtual void operator()(const CellId &c, vector<CellId> &out)
+	{
+		Tuple t(&schtarget);
+		dstarget->FastBindTuple(c, t);
+
+		ValueType v = *(ValueType *) t.get(item_attr);
+
+		vector<Tuple *> *vec;
+
+		ValueType tst;
+
+		vector<Tuple *>::iterator p;
+		for (unsigned int i = 0; i < dssource->Size(); i++) {
+			vec = (vector<Tuple *> *) dssource->GetAttributeVal(set_attr, i);
+			for (p = vec->begin(); p != vec->end(); p++) {
+				tst = *(ValueType *) (*p)->get(set_value_attr);
+				if (tst == v) {
+					out.push_back(i);
+					break;
+				}
+
+			}
+		}
+	}
+	;
+};
+
+class byPointerSet: public AssignmentFunction {
+public:
+	byPointerSet(string sa, string pa) :
+			setattr(sa), pattr(pa)
+	{
+	}
+	;
+
+	virtual void operator()(const CellId &c, vector<CellId>&out)
+	{
+		Tuple t(&schtarget);
+		dstarget->FastBindTuple(c, t);
+		vector<Tuple> &pset = *(vector<Tuple> *) t.get(setattr);
+
+		for (unsigned int i = 0; i < pset.size(); i++) {
+			out.push_back(*(CellId *) pset[i].get(pattr));
+		}
+	}
+	;
+private:
+	string setattr;
+	string pattr;
+};
+
+class nearest: public AssignmentFunction {
+public:
+	string a;  //S attribute
+	string b;  //T attribute
+	nearest(string attra, string attrb)
+	{
+		a = attra;
+		b = attrb;
+	}
+	;
+	nearest(string attra)
+	{
+		a = attra;
+		b = attra;
+	}
+	;
+	virtual void operator()(const CellId &c, vector<CellId>&out)
+	{
+		Tuple t(&schtarget);
+		dstarget->FastBindTuple(c, t);
+		UnTypedPtr p = t.get(a);
+		S->nearest(b, _j, p, out);
+	}
+};
+
+class sortedmatch: public AssignmentFunction {
+	CellId position;
+	string Tattr;
+	string Sattr;
+	Type type;
+public:
+	virtual void setEnvironment(GridField *t, Dim_t i, GridField *s, Dim_t j)
+	{
+		position = 0;
+		T = t;
+		S = s;
+		_i = i;
+		_j = j;
+		dstarget = &T->GetDataset(_i);
+		dssource = &S->GetDataset(_j);
+		schtarget = dstarget->GetScheme();
+		schsource = dssource->GetScheme();
+		Type tt = schtarget.getType(Tattr);
+		Type st = schsource.getType(Sattr);
+		if (tt != st) {
+			Fatal("Target attribute '%s' is type '%i', but source attribute '%s' is type '%i'.", Tattr.c_str(), tt,
+					Sattr.c_str(), st);
+		}
+		type = tt;
+	}
+
+	sortedmatch(string a, string b) :
+			Tattr(a), Sattr(b)
+	{
+	}
+	;
+	sortedmatch(string a) :
+			Tattr(a), Sattr(a)
+	{
+	}
+	;
+
+	virtual void operator()(const CellId &c, vector<CellId>&out)
+	{
+		Tuple t(&schtarget);
+		dstarget->FastBindTuple(c, t);
+		if (t.isNull()) {
+			cout << Tattr << endl;
+			T->PrintTo(cout, 5);
+			Fatal("Cell not found.");
+		}
+		UnTypedPtr p = t.get(Tattr);
+		Tuple s(&schsource);
+		UnTypedPtr val;
+		unsigned int size = S->Size(_j);
+		while (position < size) {
+			dssource->FastBindTuple(position, s);
+			val = s.get(Sattr);
+			if (equal(type, val, p)) {
+				out.push_back(position++);
+			}
+			else {
+				break;
+			}
+		}
+		/*
+		 int count = -1;
+		 int last = S->Size(_j) - 1;
+		 do {
+		 count++;
+		 dssource->FastBindTuple(position+count, s);
+		 cout << position << ", " << count << ", " << last << endl;
+		 val = s.get(Sattr);
+		 s.print();
+		 } while (equal(type, val, p) && (position+count < last));
+
+		 for (int i=0; i<count; i++){
+		 out.push_back(position++);
+		 }
+		 */
+	}
+};
+
+class match: public AssignmentFunction {
+public:
+	string Tattr;
+	string Sattr;
+
+	match(string a, string b) :
+			Tattr(a), Sattr(b)
+	{
+	}
+	;
+	match(string a) :
+			Tattr(a), Sattr(a)
+	{
+	}
+	;
+	/*
+	 virtual void setEnvironment(GridField *t, Dim_t i,
+	 GridField *s, Dim_t j) {
+	 this->T=t;
+	 this->S=s;
+	 this->_i = i;
+	 this->_j = j;
+	 this->cells = S->GetGrid()->getKCells(this->_j);
+	 }
+	 */
+	virtual void operator()(const CellId &c, vector<CellId>&out)
+	{
+		/*
+		 if (!T->isAttribute(attr.c_str()) || !S->isAttribute(attr.c_str())) {
+		 return;
+		 }
+		 */
+		//      cout << "evaluate gridfield..." << endl;
+		//cout << "m:" << c.nodes[0] << endl;
+		Tuple t(&schtarget);
+		dstarget->FastBindTuple(c, t);
+		if (t.isNull()) {
+			cout << Tattr << endl;
+			T->PrintTo(cout, 5);
+			Fatal("Cell not found.");
+		}
+		//t.print();
+
+		if (schtarget.getType(Tattr) != schsource.getType(Sattr)) {
+			Fatal(("Type mismatch: type(" + Tattr + ") != type(" + Sattr + ")").c_str());
+		}
+
+		UnTypedPtr p = t.get(Tattr);
+		switch (schtarget.getType(Tattr)) {
+		case FLOAT:
+			S->lookupFloat(Sattr, _j, *(float *) p, out);
+			break;
+		case INT:
+			S->lookupInt(Sattr, _j, *(int *) p, out);
+			break;
+		case OBJ:
+			S->lookupInt(Sattr, _j, *(int *) p, out);
+			break;
+		case TUPLE:
+			S->lookupInt(Sattr, _j, *(int *) p, out);
+			break;
+		case GRIDFIELD:
+			S->lookupInt(Sattr, _j, *(int *) p, out);
+			break;
+		}
+		//cout << *(int *) p << ", " << Tattr << endl;
+		//cout << *(int *)T->getAttributeVal(Tattr.c_str(), 0) << endl;
+		//cout << out.size() << " -> ";
+		//cout << "any? " << out.size() << endl;
+	}
+
+};
+
+class pointpoly2: public AssignmentFunction {
+public:
+	virtual void operator()(const CellId &c, vector<CellId>&out)
+	{
+		typedef vector<Tuple *> Poly;
+
+		Tuple tup(&schsource);
+		Poly poly;
+		int pts;
+
+		//the target point
+		Tuple t(&schtarget);
+		dstarget->FastBindTuple(c, t);
+		float x = *(float *) t.get("x");
+		float y = *(float *) t.get("y");
+
+		float xs[10];
+		float ys[10];
+
+		//for each cell in the source grid
+		for (unsigned int i = 0; i < S->Size(this->_j); i++) {
+			dssource->FastBindTuple(i, tup);
+			poly = *(Poly *) tup.get("poly");
+			pts = poly.size();
+			if (pts == 0) continue;
+
+			for (int j = 0; j < pts; j++) {
+				xs[j] = *(float *) poly[j]->get("x");
+				ys[j] = *(float *) poly[j]->get("y");
+			}
+
+			if (pnpoly(pts, xs, ys, x, y)) {
+				out.push_back(i);
+			}
+		}
+	}
+};
+
+class containedby: public AssignmentFunction {
+	//from source polgons to target points
+	//max polygon size is 10.
+
+public:
+
+	virtual void operator()(const CellId &c, vector<CellId>&out)
+	{
+
+		float x;
+		float y;
+		x = *(float *) dstarget->GetAttributeVal("x", c);
+		y = *(float *) dstarget->GetAttributeVal("y", c);
+
+		for (unsigned int i = 0; i < S->Size(this->_j); i++) {
+			if (PointInCell(x, y, i)) {
+				out.push_back(i);
+			}
+		}
+	}
+
+	bool PointInCell(float x, float y, CellId i)
+	{
+		typedef vector<Tuple> Poly;
+		Poly *poly;
+		Tuple *t;
+		Tuple polytup(&schsource);
+
+		float xs[10];
+		float ys[10];
+
+		bool containedBy = false;
+		dssource->FastBindTuple(i, polytup);
+		poly = *(Poly **) polytup.get("poly");
+		int s = poly->size();
+
+		assert(s <= 10);
+
+		for (int j = 0; j < s; j++) {
+			t = &(*poly)[j];
+			xs[j] = *(float *) t->get("x");
+			ys[j] = *(float *) t->get("y");
+		}
+		if (pnpoly(s, xs, ys, x, y)) {
+			containedBy = true;
+		}
+
+		return containedBy;
+	}
+};
+
+class fastcontainedby: public containedby {
+	// Uses an in-memory RTree to speed up the spatial join
+
+	RTree<CellId, float, 2> tree;
+
+public:
+	virtual void setEnvironment(GridField *t, Dim_t i, GridField *s, Dim_t j)
+	{
+		AssignmentFunction::setEnvironment(t, i, s, j);
+		assert(i == 0);
+		assert(S->GetGrid()->getdim() == 2);
+
+		tree.RemoveAll();
+
+		Tuple *tup;
+		Tuple polytup(&schsource);
+
+		for (unsigned int i = 0; i < S->Size(this->_j); i++) {
+			dssource->FastBindTuple(i, polytup);
+			typedef vector<Tuple> Poly;
+			Poly *poly;
+
+			poly = *(Poly **) polytup.get("poly");
+			int s = poly->size();
+
+			float x, y;
+			float min[2];
+			float max[2];
+
+			tup = &(*poly)[0];
+			x = *(float *) tup->get("x");
+			y = *(float *) tup->get("y");
+			min[0] = x;
+			min[1] = y;
+			max[0] = x;
+			max[1] = y;
+
+			for (int j = 1; j < s; j++) {
+				tup = &(*poly)[j];
+				x = *(float *) tup->get("x");
+				y = *(float *) tup->get("y");
+				if (x < min[0]) min[0] = x;
+				if (x > max[0]) max[0] = x;
+				if (y < min[1]) min[1] = y;
+				if (y > max[1]) max[1] = y;
+			}
+
+			tree.Insert(min, max, i); // Note, all values including zero are fine in this version
+		}
+	}
+
+	virtual void operator()(const CellId &c, vector<CellId>&out)
+	{
+
+		float x, y;
+		float coords[2];
+
+		x = *(float *) dstarget->GetAttributeVal("x", c);
+		y = *(float *) dstarget->GetAttributeVal("y", c);
+
+		coords[0] = x;
+		coords[1] = y;
+
+		set<CellId> hits;
+
+		assert((unsigned )tree.Search(coords, coords, TestCallback, &hits) == hits.size());
+
+		set<CellId>::iterator it;
+		for (it = hits.begin(); it != hits.end(); it++) {
+			if (PointInCell(x, y, *it)) {
+				cout << "cell id containing:" << *it << endl;
+				out.push_back(*it);
+			}
+		}
+	}
+
+};
+
+class contains: public AssignmentFunction {
+	//from source points to target polygons
+public:
+
+	virtual void operator()(const CellId &c, vector<CellId>&out)
+	{
+		assert(T->GetGrid()->getdim() == 2);
+		typedef vector<Tuple> Poly;
+		Poly *poly;
+
+		Tuple *t;
+		Tuple polytup(&schtarget);
+		dstarget->FastBindTuple(c, polytup);
+		poly = *(Poly **) polytup.get("poly");
+
+		int s = poly->size();
+
+		float *xs = new float[s];
+		float *ys = new float[s];
+
+		for (int j = 0; j < s; j++) {
+			t = &(*poly)[j];
+			xs[j] = *(float *) t->get("x");
+			ys[j] = *(float *) t->get("y");
+			//cout << " | " << xs[j] << ", " << ys[j];
+		}
+		//cout << "----" << endl;
+
+		float x;
+		float y;
+		for (unsigned int i = 0; i < S->Size(this->_j); i++) {
+			x = *(float *) dssource->GetAttributeVal("x", i);
+			y = *(float *) dssource->GetAttributeVal("y", i);
+			if (pnpoly(s, xs, ys, x, y)) {
+				out.push_back(i);
+			}
+		}
+
+	}
+};
+
+class pointpoly: public AssignmentFunction {
+
+public:
+	float xs[10];
+	float ys[10];
+
+	/* Expects 2-dimensional gridfields with geometry
+	 * defined on the nodes as attributes "x" and "y"
+	 * Returns the nodes incident to the cells in S that
+	 * contain the target cell.
+	 * Requires that the source grid be normalized
+	 * maximum polygon size is 10 nodes.
+	 */
+
+	virtual void operator()(const CellId &c, vector<CellId>&out)
+	{
+		assert(S->GetGrid()->getdim() == 2);
+		int s = 0;
+		Tuple t(&schtarget);
+		dstarget->FastBindTuple(c, t);
+		float x = *(float *) t.get("x");
+		float y = *(float *) t.get("y");
+		AbstractCellArray *twocells = S->GetGrid()->getKCells(2);
+		Cell *Sc;
+
+		int zt, zs, b;
+		int *hck;
+		int tpos;
+
+		//cout << "checking point " << c.nodes[0] << "...." << flush;
 //      if (c.nodes[0] >= 94) cout << "("<< x << "," <<y<<")" << flush;
-      int size = twocells->getsize();
-      for (int i=0; i < size; i++) {
-          Sc = twocells->getCell(i);
-          s = Sc->getsize();
-//          if (S->card() <10000) 
-  //          cout << "cell----" << endl;
-          for (int j=0; j<s; j++) {
-            xs[j] = *(float *)dssource->GetAttributeVal("x", Sc->getnodes()[j]);
-            ys[j] = *(float *)dssource->GetAttributeVal("y", Sc->getnodes()[j]);
-          }
-         // cout << "----" << endl;
-          if (pnpoly(s, xs, ys, x, y)) {
-            for (int j=0; j<s; j++) {
-              if (dssource->IsAttribute("zpos") && dstarget->IsAttribute("zpos")) {
-                zs = *(int *)dssource->GetAttributeVal("zpos", Sc->getnodes()[j]);
-                zt = *(int *)dstarget->GetAttributeVal("zpos", T->GetGrid()->getKCells(this->_i)->getOrd(c));
-                if (zt == zs) {
-                  b = *(int *)dssource->GetAttributeVal("b", Sc->getnodes()[j]);
-                  if (zs>=b) {
-                    out.push_back(Sc->getnodes()[j]);
-                  }
-                }
-              } else {
-                  out.push_back(c);
-              }
-   
-
-              //Rewrite this garbage.
-               
-              if (dssource->IsAttribute("hack")) { 
-                tpos = c;        
-                hck = (int *) dssource->GetAttribute("hack")->getValPtr(tpos);
-                //cout << "changed?" << endl;
-                //cout << *hck << endl;
-                *hck = 1;              
-  //                *hck = twocells->getOrd(*Sc);
-                //cout << *hck << endl;
-                //hck = (int *) dstarget->GetAttribute("hack")->getValPtr(tpos);
-                //cout << *hck << endl;
-              }
-            }
-            
-          }
-      }
-    }
-
-};
-
-class inverse_pointer : public AssignmentFunction {
-  /* an attribute in the source grid refs a cellid in the target grid
-  */
-  public:
-    string attr;
-    inverse_pointer(string a) { attr = a; }; 
-
-    virtual void operator()(const CellId &c, vector<CellId>&out) {
-      int k = this->_i;
-      int id = T->GetGrid()->getKCells(k)->getOrd(c);
-
-      //search for id in source atribute
-      S->lookupInt(attr, _j, id, out);
-
-     // cout << id << ", assigned: " << out.size() << endl;
-    }
-};
-
-class bypointer : public AssignmentFunction {
-  public:
-    string attr;
-    bypointer(string a) { attr = a;  }; 
-
-    virtual void operator()(const CellId &c, vector<CellId>&out) {
-      Tuple t(&schtarget); 
-      dstarget->FastBindTuple(c, t);
-      Scheme *sch = &schtarget;
-      unsigned int p;
-      if (sch->getType(this->attr) == FLOAT) {
-        p = int(*(float *)t.get(this->attr));
-      } else {
-        p = *(int *)t.get(this->attr);
-      }
-    
-      if (/* p>=0 && p is unsigned jhrg 10/5/11 */ p<S->Size(this->_j)) {
-        out.push_back(p);
-      }
-    }
+		int size = twocells->getsize();
+		for (int i = 0; i < size; i++) {
+			Sc = twocells->getCell(i);
+			s = Sc->getsize();
+//          if (S->card() <10000)
+			//          cout << "cell----" << endl;
+			for (int j = 0; j < s; j++) {
+				xs[j] = *(float *) dssource->GetAttributeVal("x", Sc->getnodes()[j]);
+				ys[j] = *(float *) dssource->GetAttributeVal("y", Sc->getnodes()[j]);
+			}
+			// cout << "----" << endl;
+			if (pnpoly(s, xs, ys, x, y)) {
+				for (int j = 0; j < s; j++) {
+					if (dssource->IsAttribute("zpos") && dstarget->IsAttribute("zpos")) {
+						zs = *(int *) dssource->GetAttributeVal("zpos", Sc->getnodes()[j]);
+						zt = *(int *) dstarget->GetAttributeVal("zpos", T->GetGrid()->getKCells(this->_i)->getOrd(c));
+						if (zt == zs) {
+							b = *(int *) dssource->GetAttributeVal("b", Sc->getnodes()[j]);
+							if (zs >= b) {
+								out.push_back(Sc->getnodes()[j]);
+							}
+						}
+					}
+					else {
+						out.push_back(c);
+					}
+
+					//Rewrite this garbage.
+
+					if (dssource->IsAttribute("hack")) {
+						tpos = c;
+						hck = (int *) dssource->GetAttribute("hack")->getValPtr(tpos);
+						//cout << "changed?" << endl;
+						//cout << *hck << endl;
+						*hck = 1;
+						//                *hck = twocells->getOrd(*Sc);
+						//cout << *hck << endl;
+						//hck = (int *) dstarget->GetAttribute("hack")->getValPtr(tpos);
+						//cout << *hck << endl;
+					}
+				}
+
+			}
+		}
+	}
+
 };
-/*
-class cross : public AssignmentFunction {
-  AbstractCellArray *kcells ;
-  AbstractCellArray *searchcells;
-  CrossNodeMap h;
-  public:
-    cross(GridField *gf) {
-      this->kcells = gf->GetGrid()->getKCells(gf->rank());
-      this->kcells->ref();
-    }
-    cross(Grid *g, int k) {
-      this->kcells = g->getKCells(k);
-    }
-    ~cross() { this->kcells->unref(); }
-    // each cell c in target assigned cells c X G_k
-    void setEnvironment(GridField *T, GridField *S){
-      this->S = S;
-      this->T = T;
-      
-      AbstractCellArray *jcells = T->GetGrid()->getKCells(T->rank());
-      h.setInputs(jcells, kcells);
-      
-      searchcells = S->GetGrid()->getKCells(S->rank());
-      searchcells->buildInvertedIndex();
-      jcells->buildInvertedIndex();
-    };
-    virtual void cross::operator()(const CellId &cid, vector<CellId>&out) {
-
-      //cout << "cross" << endl;
-      //cout << grid->getName() << endl;
-      //cout << "cross" << endl;
-      
-      Cell e(10);
-      Cell *c1;
-      AbstractCellArray *jcells = T->GetGrid()->getKCells(T->rank());
-      Cell *c = jcells->getCell(cid);
-      int s;
-      for (int i=0; i< kcells->getsize(); i++) {
-        c1 = kcells->getCell(i);
-        s = e.getsize();
-        c.Cross2(*c1, h, s, e.getnodes());
-        if (this->searchcells->contains(e)) {
-          //e.print();
-          //cout << this->searchcells->getOrd(e) << endl;
-          //getchar();
-          out.push_back(e);
-        //} else {
-        //  cout << "~ ";
-        }
-      }
-      //if (out.size() == 0) c.print();
-      //getchar();
-    }
-    
-};
-*/
-class unify : public AssignmentFunction {
-  public:
-    virtual void operator()(const CellId &, vector<CellId>&out) {
-      //map all cells of S to the given CellId.
-      //used by unify and as a shortcut to cross->aggregate
-      int k = this->_j;
-      AbstractCellArray *kcells = S->GetGrid()->getKCells(k);
-      for (unsigned int i=0; i< kcells->getsize(); i++) {
-        out.push_back(i);
-      }
-    }
-};
-
-
-class ident : public AssignmentFunction {
-  public:
-    virtual void operator()(const CellId &cid, vector<CellId>&out) {
-      out.push_back(cid);
-    }
 
+class inverse_pointer: public AssignmentFunction {
+	/* an attribute in the source grid refs a cellid in the target grid
+	 */
+public:
+	string attr;
+	inverse_pointer(string a)
+	{
+		attr = a;
+	}
+	;
+
+	virtual void operator()(const CellId &c, vector<CellId>&out)
+	{
+		int k = this->_i;
+		int id = T->GetGrid()->getKCells(k)->getOrd(c);
+
+		//search for id in source atribute
+		S->lookupInt(attr, _j, id, out);
+
+		// cout << id << ", assigned: " << out.size() << endl;
+	}
 };
 
+class bypointer: public AssignmentFunction {
+public:
+	string attr;
+	bypointer(string a)
+	{
+		attr = a;
+	}
+	;
+
+	virtual void operator()(const CellId &c, vector<CellId>&out)
+	{
+		Tuple t(&schtarget);
+		dstarget->FastBindTuple(c, t);
+		Scheme *sch = &schtarget;
+		unsigned int p;
+		if (sch->getType(this->attr) == FLOAT) {
+			p = int(*(float *) t.get(this->attr));
+		}
+		else {
+			p = *(int *) t.get(this->attr);
+		}
+
+		if (/* p>=0 && p is unsigned jhrg 10/5/11 */p < S->Size(this->_j)) {
+			out.push_back(p);
+		}
+	}
+};
+/*
+ class cross : public AssignmentFunction {
+ AbstractCellArray *kcells ;
+ AbstractCellArray *searchcells;
+ CrossNodeMap h;
+ public:
+ cross(GridField *gf) {
+ this->kcells = gf->GetGrid()->getKCells(gf->rank());
+ this->kcells->ref();
+ }
+ cross(Grid *g, int k) {
+ this->kcells = g->getKCells(k);
+ }
+ ~cross() { this->kcells->unref(); }
+ // each cell c in target assigned cells c X G_k
+ void setEnvironment(GridField *T, GridField *S){
+ this->S = S;
+ this->T = T;
+
+ AbstractCellArray *jcells = T->GetGrid()->getKCells(T->rank());
+ h.setInputs(jcells, kcells);
+
+ searchcells = S->GetGrid()->getKCells(S->rank());
+ searchcells->buildInvertedIndex();
+ jcells->buildInvertedIndex();
+ };
+ virtual void cross::operator()(const CellId &cid, vector<CellId>&out) {
+
+ //cout << "cross" << endl;
+ //cout << grid->getName() << endl;
+ //cout << "cross" << endl;
+
+ Cell e(10);
+ Cell *c1;
+ AbstractCellArray *jcells = T->GetGrid()->getKCells(T->rank());
+ Cell *c = jcells->getCell(cid);
+ int s;
+ for (int i=0; i< kcells->getsize(); i++) {
+ c1 = kcells->getCell(i);
+ s = e.getsize();
+ c.Cross2(*c1, h, s, e.getnodes());
+ if (this->searchcells->contains(e)) {
+ //e.print();
+ //cout << this->searchcells->getOrd(e) << endl;
+ //getchar();
+ out.push_back(e);
+ //} else {
+ //  cout << "~ ";
+ }
+ }
+ //if (out.size() == 0) c.print();
+ //getchar();
+ }
+
+ };
+ */
+class unify: public AssignmentFunction {
+public:
+	virtual void operator()(const CellId &, vector<CellId>&out)
+	{
+		//map all cells of S to the given CellId.
+		//used by unify and as a shortcut to cross->aggregate
+		int k = this->_j;
+		AbstractCellArray *kcells = S->GetGrid()->getKCells(k);
+		for (unsigned int i = 0; i < kcells->getsize(); i++) {
+			out.push_back(i);
+		}
+	}
+};
+
+class ident: public AssignmentFunction {
+public:
+	virtual void operator()(const CellId &cid, vector<CellId>&out)
+	{
+		out.push_back(cid);
+	}
+
+};
 
 } //namespace
 
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/binarynodemap.h gridfields/clib/src/binarynodemap.h
--- tag/gridfieldsclib-0.7/src/binarynodemap.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/binarynodemap.h	2014-05-16 22:57:00.836725197 +0200
@@ -3,13 +3,22 @@
 
 #include "nodemap.h"
 
+namespace GF {
+
 class BinaryNodeMap {
 
- public:
+public:
+
+	virtual Node map(Node, Node)=0;
 
-  virtual Node map(Node, Node)=0;
-  //virtual ~BinaryNodeMap()=0; 
- private:
+	//virtual ~BinaryNodeMap()=0;
+	// This class should have a destructor. jhrg 4//8/14
+	virtual ~BinaryNodeMap()
+	{
+	}
+private:
 };
 
+} // namespace GF
+
 #endif /* _BINARYNODEMAP_H */
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/bind.cc gridfields/clib/src/bind.cc
--- tag/gridfieldsclib-0.7/src/bind.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/bind.cc	2014-05-16 22:57:00.740058533 +0200
@@ -1,3 +1,5 @@
+#include "config_gridfields.h"
+
 #include "gridfield.h"
 #include "array.h"
 #include "restrict.h"
@@ -5,103 +7,109 @@
 #include "timing.h"
 #include "bind.h"
 using namespace std;
-BindOp::BindOp(Array *arr, Dim_t k, GridFieldOperator *op) 
- : UnaryGridFieldOperator(op), array(arr), attr(arr->getName()), type(arr->type), 
-   reader(NULL), _k(k)
-{cout<<"ahoy!"<<endl;
+
+namespace GF {
+
+BindOp::BindOp(Array *arr, Dim_t k, GridFieldOperator *op) :
+		UnaryGridFieldOperator(op), /* Unused. jhrg 4/4/14 array(arr),*/attr(arr->getName()), type(arr->type), reader(
+				NULL), _k(k)
+{
+	cout << "ahoy!" << endl;
 //  this->cleanup = false;
 }
 
-BindOp::BindOp(Array *arr, ArrayReader *rdr, Dim_t k, GridFieldOperator *op) 
- : UnaryGridFieldOperator(op), array(arr), attr(arr->getName()), type(arr->type), 
-   reader(rdr), _k(k)
+BindOp::BindOp(Array *arr, ArrayReader *rdr, Dim_t k, GridFieldOperator *op) :
+		UnaryGridFieldOperator(op), /* Unused array(arr),*/attr(arr->getName()), type(arr->type), reader(rdr), _k(k)
 {
 //  this->cleanup = false;
 }
 
-BindOp::BindOp(string attr, Type t, ArrayReader *reader, Dim_t k, GridFieldOperator *op) 
- : UnaryGridFieldOperator(op), temp(0), array(NULL), attr(attr), type(t),
-   reader(reader),  _k(k)
+BindOp::BindOp(string attr, Type t, ArrayReader *reader, Dim_t k, GridFieldOperator *op) :
+		UnaryGridFieldOperator(op), temp(0), /*array(NULL),*/attr(attr), type(t), reader(reader), _k(k)
 {
 //  this->cleanup = false;
 }
 
-BindOp::BindOp(string attr, Type t, string filename, int offset, Dim_t k, GridFieldOperator *op) 
-   : UnaryGridFieldOperator(op), array(NULL), attr(attr), type(t),
-     reader(new FileArrayReader(filename, offset)), _k(k)
+BindOp::BindOp(string attr, Type t, string filename, int offset, Dim_t k, GridFieldOperator *op) :
+		UnaryGridFieldOperator(op), /*array(NULL),*/attr(attr), type(t), reader(new FileArrayReader(filename, offset)), _k(
+				k)
 {
 //  this->cleanup = false;
 }
 
-BindOp::BindOp(string attr, Type t, string filename, int offset, 
-  string addresses, Dim_t k, GridFieldOperator *op) 
-   : UnaryGridFieldOperator(op), array(NULL), attr(attr), type(t),
-     reader(new FileArrayReader(filename, offset, addresses)), _k(k)
+BindOp::BindOp(string attr, Type t, string filename, int offset, string addresses, Dim_t k, GridFieldOperator *op) :
+		UnaryGridFieldOperator(op), /*array(NULL),*/attr(attr), type(t), reader(
+				new FileArrayReader(filename, offset, addresses)), _k(k)
 {
 //  this->cleanup = false;
 }
 
-void BindOp::Execute() {
-  //cout << "Bind..." << endl;
-  //this->array->getScheme()->print();
-  this->PrepareForExecution();
-  //float start = gettime();
-  temp++;
-  Result =  BindOp::Bind(this->attr, this->type, this->reader, this->_k, this->GF);
-  //cout << gettime() - start << endl;
+void BindOp::Execute()
+{
+	//cout << "Bind..." << endl;
+	//this->array->getScheme()->print();
+	this->PrepareForExecution();
+	//float start = gettime();
+	temp++;
+	Result = BindOp::Bind(this->attr, this->type, this->reader, this->_k, this->GF);
+	//cout << gettime() - start << endl;
 }
 
-/* 
+/*
  * This method makes BindOp parameterizable over offset into the file
  */
-void BindOp::setOffset(UnTypedPtr value) {
-  this->setOffsetInt(int(*(float *) value));
+void BindOp::setOffset(UnTypedPtr value)
+{
+	this->setOffsetInt(int(*(float *) value));
 }
 
-void BindOp::setOffsetInt(int value) {
+void BindOp::setOffsetInt(int value)
+{
 //  cout << "SETTING OFFSET: " << *(float *) value);
-  this->reader->setOffset( value);
-  this->Update();
+	this->reader->setOffset(value);
+	this->Update();
 }
 
-
-void BindOp::setOffsetInt(UnTypedPtr value) {
-  this->setOffsetInt(*(int *) value);
-  this->Update();
+void BindOp::setOffsetInt(UnTypedPtr value)
+{
+	this->setOffsetInt(*(int *) value);
+	this->Update();
 }
 
-/* 
+/*
  * This method makes BindOp parameterizable over filename
  */
 
-GridField *BindOp::Bind(const string &attr, Type type, 
-                        ArrayReader *reader, Dim_t k,
-                        GridField *GF) {
-  GridField *Out = GF;//new GridField(GF);
-  
-  Array *arr;
-  if (Out->IsAttribute(k, attr)) {
-    arr = Out->GetAttribute(k, attr);
-    if (arr->type != type) {
-      Fatal("Attempt to Bind over an array with a different type");
-    }
-    
-    //add a reference representing our own work
-    arr->ref();
-    
-  } else {
-    arr = new Array(attr, type, Out->Size(k));
-    Out->Bind(k, arr);
-  }
-  
-  reader->Read(Out, k, arr);
-  //arr->print();
-  //cout << "Offset: " << reader->getOffset() << endl;
-  //cout << "new value? " << Out->getFloatAttributeVal(0, "salt", 0) << endl;
-
-  DEBUG << "Bind("<< attr << ", " << k << ")" << endl;
-  //release the reference representing the bind operator
-  arr->unref();
-  Out->ref();
-  return Out;
+GridField *BindOp::Bind(const string &attr, Type type, ArrayReader *reader, Dim_t k, GridField *GF)
+{
+	GridField *Out = GF;  //new GridField(GF);
+
+	Array *arr;
+	if (Out->IsAttribute(k, attr)) {
+		arr = Out->GetAttribute(k, attr);
+		if (arr->type != type) {
+			Fatal("Attempt to Bind over an array with a different type");
+		}
+
+		//add a reference representing our own work
+		arr->ref();
+
+	}
+	else {
+		arr = new Array(attr, type, Out->Size(k));
+		Out->Bind(k, arr);
+	}
+
+	reader->Read(Out, k, arr);
+	//arr->print();
+	//cout << "Offset: " << reader->getOffset() << endl;
+	//cout << "new value? " << Out->getFloatAttributeVal(0, "salt", 0) << endl;
+
+	DEBUG << "Bind(" << attr << ", " << k << ")" << endl;
+	//release the reference representing the bind operator
+	arr->unref();
+	Out->ref();
+	return Out;
 }
+
+} // namespace GF
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/bindconstant.cc gridfields/clib/src/bindconstant.cc
--- tag/gridfieldsclib-0.7/src/bindconstant.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/bindconstant.cc	2014-05-16 22:57:00.810058531 +0200
@@ -1,37 +1,43 @@
+#include "config_gridfields.h"
+
 #include "gridfield.h"
 #include "constarray.h"
 #include "timing.h"
 #include "bindconstant.h"
 
-BindConstantOp::BindConstantOp(Dim_t k, const string &attr, float val, 
-                               GridFieldOperator *op) 
-   : UnaryGridFieldOperator(op), _k(k), attr(attr), val(val)
+namespace GF {
+
+BindConstantOp::BindConstantOp(Dim_t k, const string &attr, float val, GridFieldOperator *op) :
+		UnaryGridFieldOperator(op), _k(k), attr(attr), val(val)
 {
-  //this->cleanup = false;
+	//this->cleanup = false;
 }
 
-void BindConstantOp::Execute() {
-  this->PrepareForExecution();
-  Result =  BindConstantOp::BindConstant(this->_k, this->attr, this->val, this->GF);
+void BindConstantOp::Execute()
+{
+	this->PrepareForExecution();
+	Result = BindConstantOp::BindConstant(this->_k, this->attr, this->val, this->GF);
 }
 
-
-void BindConstantOp::setAttributeVal(const string &a, float v) {
-  this->attr = a;
-  this->val = v;
-  this->Update();
+void BindConstantOp::setAttributeVal(const string &a, float v)
+{
+	this->attr = a;
+	this->val = v;
+	this->Update();
 }
 
-GridField *BindConstantOp::BindConstant(Dim_t k, const string &attr, float val, 
-                                        GridField *GF) {
+GridField *BindConstantOp::BindConstant(Dim_t k, const string &attr, float val, GridField *GF)
+{
+
+	ConstArray *a = new ConstArray(attr, GF->Size(k), val);
+
+	GridField *Out = GF;
 
-  ConstArray *a = new ConstArray(attr, GF->Size(k), val);
+	Out->unBind(k, attr);
 
-  GridField *Out = GF;
-  
-  Out->unBind(k, attr);
-
-  Out->Bind(k, a);
-  
-  return Out;
+	Out->Bind(k, a);
+
+	return Out;
 }
+
+} // namespace GF
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/bindconstant.h gridfields/clib/src/bindconstant.h
--- tag/gridfieldsclib-0.7/src/bindconstant.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/bindconstant.h	2014-05-16 22:57:00.833391864 +0200
@@ -5,19 +5,23 @@
 #include "array.h"
 #include "gridfieldoperator.h"
 
-class BindConstantOp : public UnaryGridFieldOperator {
+namespace GF {
+
+class BindConstantOp: public UnaryGridFieldOperator {
 public:
 //  BindConstantOp(const string &attr, int val, GridFieldOperator *op);
-  BindConstantOp(Dim_t k, const string &attr, float val, GridFieldOperator *op);
- 
-  void Execute();
+	BindConstantOp(Dim_t k, const string &attr, float val, GridFieldOperator *op);
+
+	void Execute();
 //  static GridField *BindConstant(const string &attr, GridField *GF);
-  void setAttributeVal(const string &a, float v);
-  static GridField *BindConstant(Dim_t k, const string &attr, float val, GridField *GF);
+	void setAttributeVal(const string &a, float v);
+	static GridField *BindConstant(Dim_t k, const string &attr, float val, GridField *GF);
 private:
-  Dim_t _k;
-  string attr;
-  float val;
+	Dim_t _k;
+	string attr;
+	float val;
 };
 
+} // namespace GF
+
 #endif
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/bind.h gridfields/clib/src/bind.h
--- tag/gridfieldsclib-0.7/src/bind.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/bind.h	2014-05-16 22:57:00.830058531 +0200
@@ -5,35 +5,39 @@
 #include "array.h"
 #include "gridfieldoperator.h"
 
-class BindOp : public UnaryGridFieldOperator {
+namespace GF {
+
+class BindOp: public UnaryGridFieldOperator {
 public:
-  BindOp(Array *arr, Dim_t k, GridFieldOperator *op);
-  BindOp(Array *arr, ArrayReader *rdr, Dim_t k, GridFieldOperator *op);
-  BindOp(string attr, Type t, ArrayReader *r, Dim_t k, GridFieldOperator *op);
-  BindOp(string attr, Type t, string filename, int offset, Dim_t k, GridFieldOperator *op);
-  BindOp(string attr, Type t, string filename, 
-      int offset, string addresses, Dim_t k, GridFieldOperator *op);
- 
-  void setArrayReader(ArrayReader *ar) { 
-    delete this->reader;
-    this->reader = ar; 
-    this->Update();
-  };
-  void setOffset(UnTypedPtr value);
-  void setOffsetInt(UnTypedPtr value);
-  void setOffsetInt(int value);
-  
-  void Execute();
-  static GridField *Bind(const string &attr, Type t, 
-                         ArrayReader *ar, Dim_t k, GridField *GF);
+	BindOp(Array *arr, Dim_t k, GridFieldOperator *op);
+	BindOp(Array *arr, ArrayReader *rdr, Dim_t k, GridFieldOperator *op);
+	BindOp(string attr, Type t, ArrayReader *r, Dim_t k, GridFieldOperator *op);
+	BindOp(string attr, Type t, string filename, int offset, Dim_t k, GridFieldOperator *op);
+	BindOp(string attr, Type t, string filename, int offset, string addresses, Dim_t k, GridFieldOperator *op);
+
+	void setArrayReader(ArrayReader *ar)
+	{
+		delete this->reader;
+		this->reader = ar;
+		this->Update();
+	}
+	;
+	void setOffset(UnTypedPtr value);
+	void setOffsetInt(UnTypedPtr value);
+	void setOffsetInt(int value);
+
+	void Execute();
+	static GridField *Bind(const string &attr, Type t, ArrayReader *ar, Dim_t k, GridField *GF);
 private:
-  int temp;
-  Array *array;
-  string attr;
-  Type type;
-  ArrayReader *reader;
-  Dim_t _k;
+	int temp;
+	// array Unused. jhrg 4/4/14 Array *array;
+	string attr;
+	Type type;
+	ArrayReader *reader;
+	Dim_t _k;
 
 };
 
+} // namespace GF
+
 #endif
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/cellarray.cc gridfields/clib/src/cellarray.cc
--- tag/gridfieldsclib-0.7/src/cellarray.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/cellarray.cc	2014-05-16 22:57:00.826725198 +0200
@@ -1,505 +1,574 @@
-#include "timing.h"
-#include "expr.h"
+#include "config_gridfields.h"
+
 #include <assert.h>
+
+#include <set>
 #include <iterator>
-#include <ext/algorithm> 
+#include <algorithm>
+
 #include "cellarray.h"
+#include "timing.h"
+#include "expr.h"
 #include "implicitcrossnodemap.h"
 #include "crossnodemap.h"
 #include "normnodemap.h"
 
+namespace GF {
 
 CellArray::CellArray(Node *celldata, int cellcount) :
-            cells(cellcount, Cell(0)),
-			      cleanup_node_array(true), 
-            nodecount(0),
-			      node_array(NULL) {
-
-  this->node_array = celldata;
-  Node *ptr = celldata;                            
-  for(int i=0; i<cellcount; i++) {
-    Cell &c = cells[i];
-    c.setsize(*ptr);
-    this->nodecount += *ptr;
-    ++ptr;
-    c.setnodes(ptr);
-    ptr += c.getsize();
-  }
-  this->ref();
+		cells(cellcount, Cell(0)), cleanup_node_array(true), nodecount(0), node_array(NULL)
+{
+
+	this->node_array = celldata;
+	Node *ptr = celldata;
+	for (int i = 0; i < cellcount; i++) {
+		Cell &c = cells[i];
+		c.setsize(*ptr);
+		this->nodecount += *ptr;
+		++ptr;
+		c.setnodes(ptr);
+		ptr += c.getsize();
+	}
+	this->ref();
 }
-  
+
 CellArray::CellArray(Node *celldata, int cellcount, int nodespercell) :
-                              cells(cellcount, Cell(0)), 
-			      cleanup_node_array(true), 
-            nodecount(0),
-			      node_array(NULL) {
-                  
-  this->node_array = celldata;
-  Node *ptr = celldata;                            
-  for(int i=0; i<cellcount; i++) {
-    Cell &c = cells[i];
-    c.setsize(nodespercell);
-    c.setnodes(ptr);
-    ptr += nodespercell;
-  }
-  this->nodecount = cellcount*nodespercell;
-  this->ref();
-}
-
-CellArray::~CellArray() {
-  if (this->cleanup_node_array) {
-    DEBUG << "DELETING node array" << endl;
+		cells(cellcount, Cell(0)), cleanup_node_array(true), nodecount(0), node_array(NULL)
+{
+
+	this->node_array = celldata;
+	Node *ptr = celldata;
+	for (int i = 0; i < cellcount; i++) {
+		Cell &c = cells[i];
+		c.setsize(nodespercell);
+		c.setnodes(ptr);
+		ptr += nodespercell;
+	}
+	this->nodecount = cellcount * nodespercell;
+	this->ref();
+}
+
+CellArray::~CellArray()
+{
+	if (this->cleanup_node_array) {
+		DEBUG << "DELETING node array" << endl;
 #if 0
-    // This delete causes a memory fault (the Node* is likely deleted
-    // by whatever code allocated the memory. I tried plain delete to
-    // see if mis-matched plain -vs- array delete was the issue, but
-    // it is not.
-    // jhrg 9/29/11
-    delete [] node_array;
+		// This delete causes a memory fault (the Node* is likely deleted
+		// by whatever code allocated the memory. I tried plain delete to
+		// see if mis-matched plain -vs- array delete was the issue, but
+		// it is not.
+		// jhrg 9/29/11
+		delete [] node_array;
 #endif
-  }
+	}
 }
 
-idx CellArray::getsize()  {
-  return this->cells.size();
-}
+idx CellArray::getsize()
+{
+	return this->cells.size();
+}
+
+void CellArray::addCell(Cell &c)
+{
+	cells.push_back(c);
+	nodecount += c.getsize();
+}
+
+void CellArray::addCell(Cell *c)
+{
+	//inverted_cells[*c] = cells.size();
+	cells.push_back(*c);
+	nodecount += c->getsize();
+}
+
+void CellArray::setNodeArray(Node *na, unsigned int ns)
+{
+	this->node_array = na;
+	this->nodecount = ns;
+	this->cleanup_node_array = true;
+}
+
+Cell *CellArray::addCellNodes(Node *ns, int s)
+{
+	//Cell *c = new Cell(s);
+	Cell c(s);
+	for (int i = 0; i < s; i++) {
+		c.getnodes()[i] = ns[i];
+	}
+	addCell(&c);
+	return &cells.back();
+}
+
+void CellArray::buildInvertedIndex()
+{
+	inverted_cells.clear();
+	//inverted_cells.resize(cells.size());
+
+	for (size_t i = 0; i < cells.size(); i++) {
+		inverted_cells[cells[i]] = i;
+	}
+	//cout << "SIZE: " << inverted_cells.size() << ", BUCKETS: " << inverted_cells.bucket_count() << endl;
+}
+
+void CellArray::buildAdjacencyIndex()
+{
+	// build adjacency index
+	unsigned int n = this->getsize();
+
+	adj.clear();
+	adj.resize(n);
+
+	for (size_t i = 0; i < n; i++) {
+		this->getAdjacentCells(i, adj[i]);
+	}
+	this->UseAdjacencyIndex = true;
+}
+
+vector<vector<int> > CellArray::makeArrayInts()
+{
+
+	CellArray *arr;
+
+	arr = this;
+	// unused jhrg 4/3/14 int i;
+	vector<int> a;
+	//vector<int>* array=new vector<int>;
+	vector<vector<int> > array;
+
+	array.reserve(arr->getsize());
+	for (unsigned int j = 0; j < (arr->getsize()); j++) {
+		a.reserve(arr->cells.at(j).getsize());
+		for (unsigned int l = 0; l < arr->cells.at(j).getsize(); l++) {    //(arr->cells.at(j).getsize()); i++) {
+			a.push_back(arr->cells.at(j).getnodes()[l]);
+		}
+		array.push_back(a);
+		a.clear();
+	}
+	return array;
+}
+
+void CellArray::getAdjacentCells(CellId cid, vector<CellId> &out)
+{
+
+	if (this->UseAdjacencyIndex) {
+		COPY(vector<CellId>, adj[cid], out, ii);
+	}
+
+	AbstractCellArray *ca = this;
+	set<CellId> cellset;
+	Cell &c = *(this->getCell(cid));
+	/*
+	 if (d == 0) {
+	 for (int i=0; i<c.getsize(); i++) {
+	 //cout << "get Incident cells using " << this->getdim() << endl;
+	 ca->getIncidentCells(c.getnodes()[i], cellset);
+	 for (p=cellset.begin(); p!=cellset.end(); p++) {
+	 Cell *ic = ca->getCell(*p);
+	 for (int j=0; j<ic->getsize(); j++) {
+	 out.insert(ic->getnodes()[j]);
+	 }
+	 }
+	 }
+	 out.erase(cid);
+	 //cout << "Node: " << c.getnodes()[0] << " <| " << out.size() << endl;
+	 }
+	 else {
+	 */
+	for (unsigned int i = 0; i < c.getsize(); i++) {
+		ca->getIncidentCells(c.getnodes()[i], cellset);
+	}
+	cellset.erase(cid);
+	out.insert(out.end(), cellset.begin(), cellset.end());
+	//}
+}
+
+void CellArray::getIncidentCells(const Cell &c, set<CellId> &out)
+{
+	if (incidence.empty()) buildIncidenceIndex();
+
+	for (unsigned int i = 0; i < c.getsize(); i++) {
+		out.insert(incidence[c.getnodes()[i]].begin(), incidence[c.getnodes()[i]].end());
+	}
 
-void CellArray::addCell(Cell &c) {
-  cells.push_back(c);
-  nodecount += c.getsize();
-}
-
-void CellArray::addCell(Cell *c) {
-  //inverted_cells[*c] = cells.size();
-  cells.push_back(*c);
-  nodecount += c->getsize();
-}
-
-void CellArray::setNodeArray(Node *na, unsigned int ns) {
-  this->node_array = na;
-  this->nodecount = ns;
-  this->cleanup_node_array = true;
-}
-
-Cell *CellArray::addCellNodes(Node *ns, int s) {
-  //Cell *c = new Cell(s);
-  Cell c(s);
-  for (int i=0; i<s; i++) {
-   c.getnodes()[i] = ns[i];
-  }
-  addCell(&c);
-  return &cells.back();
-}
-
-void CellArray::buildInvertedIndex(){
-  inverted_cells.clear();
-  //inverted_cells.resize(cells.size());
-      
-  for (size_t i=0; i< cells.size(); i++) {
-    inverted_cells[cells[i]] = i;
-  }
-  //cout << "SIZE: " << inverted_cells.size() << ", BUCKETS: " << inverted_cells.bucket_count() << endl;
-}
-
-void CellArray::buildAdjacencyIndex() {
-  // build adjacency index
-  unsigned int n = this->getsize();
-
-  adj.clear();
-  adj.resize(n);
-
-  for (size_t i=0; i<n; i++) {
-    this->getAdjacentCells(i, adj[i]);
-  }
-  this->UseAdjacencyIndex = true;
-}
-
-
-
-void CellArray::getAdjacentCells(CellId cid, vector<CellId> &out) {
-
-  if (this->UseAdjacencyIndex) {
-    COPY(vector<CellId>, adj[cid], out, ii);
-  }
-  
-  AbstractCellArray *ca = this;
-  set<CellId> cellset;
-  Cell &c = *(this->getCell(cid));
-  /*
-  if (d == 0) {
-    for (int i=0; i<c.getsize(); i++) {
-      //cout << "get Incident cells using " << this->getdim() << endl;
-      ca->getIncidentCells(c.getnodes()[i], cellset);
-      for (p=cellset.begin(); p!=cellset.end(); p++) {
-        Cell *ic = ca->getCell(*p);
-        for (int j=0; j<ic->getsize(); j++) {
-          out.insert(ic->getnodes()[j]); 
-        }
-      }
-    }    
-    out.erase(cid);
-    //cout << "Node: " << c.getnodes()[0] << " <| " << out.size() << endl;
-  }
-  else {
-    */
-    for (unsigned int i=0; i<c.getsize(); i++) {
-      ca->getIncidentCells(c.getnodes()[i], cellset);
-    }
-    cellset.erase(cid);
-    out.insert(out.end(), cellset.begin(), cellset.end());
-  //}
-}
-void CellArray::getIncidentCells(const Cell &c, set<CellId> &out) {
-  if (incidence.empty()) buildIncidenceIndex();
-/*
-  c.print();
-  cout 
-  << c.getnodes()[0]
-  << ": "
-  << incidence[c.getnodes()[0]].size()
-  << "->"
-  << *(incidence[c.getnodes()[0]].begin())
-  << ":"
-  << *(incidence[c.getnodes()[0]].end())
-  << endl;
-*/
-  for (unsigned int i=0; i<c.getsize(); i++) {
-    out.insert(incidence[c.getnodes()[i]].begin(), incidence[c.getnodes()[i]].end());
-  }
-  FOR (set<CellId>, x, out) { 
-    if (!c.IncidentTo(*this->getCell(*x))) {
-      out.erase(*x);
-    }
-  }
-}
-
-void CellArray::getIncidentCells(Node n, set<CellId> &out) {
-  if (incidence.empty()) buildIncidenceIndex();
-  out.insert(incidence[n].begin(), incidence[n].end());
-}
-
-void CellArray::buildIncidenceIndex(){
-  vector<Cell>::iterator p;
-  set<Node> nodeset; 
-  toNodeSet(nodeset);
-  incidence.clear();
-  incidence.resize(nodeset.size());
-  int i = 0;
-  for (p=cells.begin(); p!=cells.end(); ++p) {
-    for (unsigned int j=0; j<(*p).getsize(); j++) {
-      incidence[(*p).getnodes()[j]].insert(i);
-    }
-    i++;
-  }
-}
-
-size_t CellArray::getOrd(Node n) {
-  //convenient specialization for 0-cells
-  const Cell c(1); 
-  c.getnodes()[0] = n;
-  return getOrd(c);
-}
+	// Cannot use the FOR macro here beause erase invalidates the
+	// iterator (and then the loop increments it). jhrg 4/3/14
+#if 0
+	FOR (set<CellId>, x, out) {
+		if (!c.IncidentTo(*this->getCell(*x))) {
+			out.erase(*x);
+		}
+	}
+#endif
 
-inline bool CellArray::contains(const Cell &c) {
-  return (inverted_cells.find(c) != inverted_cells.end());
+	// This trick is from Meyers, Effective STL, p.45.
+	// erase() invalidates the the iterator but the post increment
+	// operator works on the initial value. jhrg 4/3/14
+	for (set<CellId>::iterator i = out.begin(), e = out.end(); i != e; /* incr i in body */) {
+		if (!c.IncidentTo(*this->getCell(*i))) {
+			out.erase(i++);
+		}
+		else {
+			++i;
+		}
+	}
+}
+
+void CellArray::getIncidentCells(Node n, set<CellId> &out)
+{
+	if (incidence.empty()) buildIncidenceIndex();
+	out.insert(incidence[n].begin(), incidence[n].end());
+}
+
+void CellArray::buildIncidenceIndex()
+{
+	vector<Cell>::iterator p;
+	set<Node> nodeset;
+	toNodeSet(nodeset);
+	incidence.clear();
+	// jhrg 2/13/14
+#ifdef USE_HASH_MAP_RESIZE
+	incidence.resize(nodeset.size());
+#else
+	incidence.rehash(nodeset.size());
+#endif
+	int i = 0;
+	for (p = cells.begin(); p != cells.end(); ++p) {
+		for (unsigned int j = 0; j < (*p).getsize(); j++) {
+			incidence[(*p).getnodes()[j]].insert(i);
+		}
+		i++;
+	}
+}
+
+size_t CellArray::getOrd(Node n)
+{
+	//convenient specialization for 0-cells
+	const Cell c(1);
+	c.getnodes()[0] = n;
+	return getOrd(c);
+}
+
+inline bool CellArray::contains(const Cell &c)
+{
+	return (inverted_cells.find(c) != inverted_cells.end());
 }
 /*
-inline int CellArray::fastOrd(const Cell &c) {
-  //assumes inverted index is fresh
-  InvertedCellIndex::iterator pos;
-  pos = inverted_cells.find(c);
-  if (pos == inverted_cells.end()) {
-    return -1;
-  }
-  return pos->second; 
-}
-*/
-size_t CellArray::getOrd(const Cell &c) {
-  InvertedCellIndex::iterator pos;
-  if (inverted_cells.empty()) {
-    this->buildInvertedIndex();
-  }
-  pos = inverted_cells.find(c);
-  
-  if (pos == inverted_cells.end()) {
-    //rebuild the index and check again
-    this->buildInvertedIndex(); 
-    pos = inverted_cells.find(c);
-    if (pos == inverted_cells.end()) {
-      return -1;
-    }
-  }
-  return (*pos).second;
-}
-
-Cell CellArray::getCellCopy(idx i) {
-  assert(i < this->cells.size());
-  return this->cells[i];
-}
-
-Cell *CellArray::getCell(idx i) {
-  assert(i < this->cells.size());
-  return &this->cells[i];
-}
-
-Node *CellArray::getCellNodes(idx i) {
-  assert(i < this->cells.size());
-  return this->cells[i].getnodes();
-}
-
-void CellArray::print() {
-  this->print(0);
-}
-
-int CellArray::bytes() {
-  int b = 0;
-  for (size_t i=0; i< this->getsize(); i++) {
-    b += 1 + this->getCell(i)->getsize();
-  }
-  return b*sizeof(int);
-}
-
-void CellArray::print(size_t indent) {
-  CellArray *ca = this;
-  size_t i;
-
-  for (i=0; i<indent; i++) cout << " ";
-  cout << "<CELLARRAY>: \n";
-  for (i=0; i<indent; i++) cout << " ";
-  cout << "size: " << ca->cells.size() << "\n";
-  cout << "nodecount: " << ca->getNodeCount() << "\n";
-  for (i=0; i<indent; i++) cout << " ";
-  cout << "cells: \n";
-  for (i=0; i<ca->cells.size(); i++) {
-    ca->cells[i].print(indent+2);
-  }
+ inline int CellArray::fastOrd(const Cell &c) {
+ //assumes inverted index is fresh
+ InvertedCellIndex::iterator pos;
+ pos = inverted_cells.find(c);
+ if (pos == inverted_cells.end()) {
+ return -1;
+ }
+ return pos->second;
+ }
+ */
+size_t CellArray::getOrd(const Cell &c)
+{
+	InvertedCellIndex::iterator pos;
+	if (inverted_cells.empty()) {
+		this->buildInvertedIndex();
+	}
+	pos = inverted_cells.find(c);
+
+	if (pos == inverted_cells.end()) {
+		//rebuild the index and check again
+		this->buildInvertedIndex();
+		pos = inverted_cells.find(c);
+		if (pos == inverted_cells.end()) {
+			return -1;
+		}
+	}
+	return (*pos).second;
+}
+
+Cell CellArray::getCellCopy(idx i)
+{
+	assert(i < this->cells.size());
+	return this->cells[i];
+}
+
+Cell *CellArray::getCell(idx i)
+{
+	assert(i < this->cells.size());
+	return &this->cells[i];
+}
+
+Node *CellArray::getCellNodes(idx i)
+{
+	assert(i < this->cells.size());
+	return this->cells[i].getnodes();
+}
+
+void CellArray::print()
+{
+	this->print(0);
+}
+
+int CellArray::bytes()
+{
+	int b = 0;
+	for (size_t i = 0; i < this->getsize(); i++) {
+		b += 1 + this->getCell(i)->getsize();
+	}
+	return b * sizeof(int);
+}
+
+void CellArray::print(size_t indent)
+{
+	CellArray *ca = this;
+	size_t i;
+
+	for (i = 0; i < indent; i++)
+		cout << " ";
+	cout << "<CELLARRAY>: \n";
+	for (i = 0; i < indent; i++)
+		cout << " ";
+	cout << "size: " << ca->cells.size() << "\n";
+	cout << "nodecount: " << ca->getNodeCount() << "\n";
+	for (i = 0; i < indent; i++)
+		cout << " ";
+	cout << "cells: \n";
+	for (i = 0; i < ca->cells.size(); i++) {
+		ca->cells[i].print(indent + 2);
+	}
 }
 /*
-void CellArray::Edges(CellArray *onecells) {
-  int nodepair[2];
-  
-  for (int i=0; i<this->getsize(); i++) {
-    Cell *c = this->getCell(i);
-    c->Guess2DEdges(onecells);
-  }  
-}
-*/
-CellArray *CellArray::Intersection(AbstractCellArray *othercells) {
-  typedef SortedCellIndex::iterator Ptr;
+ void CellArray::Edges(CellArray *onecells) {
+ int nodepair[2];
+
+ for (int i=0; i<this->getsize(); i++) {
+ Cell *c = this->getCell(i);
+ c->Guess2DEdges(onecells);
+ }
+ }
+ */
+CellArray *CellArray::Intersection(AbstractCellArray *othercells)
+{
+	typedef SortedCellIndex::iterator Ptr;
 //  typedef InvertedCellIndex::iterator Ptr;
-  Ptr me, mylast;
-  Ptr you, yourlast;
-  CellArray *out = new CellArray();
-  vector<Cell> *ours = out->getCellVector();
-
-  SortedCellIndex sortedcells;
-  SortedCellIndex othersortedcells;
-  
-  for (size_t i=0; i< cells.size(); i++) {
-    sortedcells[cells[i]] = i;
-  }
-  for (size_t i=0; i< othercells->getsize(); i++) {
-    othersortedcells[*(othercells->getCell(i))] = i;
-  }
-
-  me = sortedcells.begin();
-  mylast = sortedcells.end();
-  you = othersortedcells.begin();
-  yourlast = othersortedcells.end();
-
-  while (me != mylast && you != yourlast) {
-    
-     //((Cell)(*me).first).print();
-    //  ((Cell)(*you).first).print();
-    if ((*me).first < (*you).first) { 
-      ++me;
-      continue;
-    }
-    if ((*you).first < (*me).first) { 
-      ++you;
-      continue;
-    }
-    if ((*me).first == (*you).first) {
-      ours->push_back((*me).first);
-      //cout << "match!" << endl;
-      ++me;
-      ++you;
-    } else { 
-      ((Cell)(*me).first).print();
-      ((Cell)(*you).first).print();
-      
-      Fatal("Error computing intersection."); 
-    }
-  }
-    
-  //out->buildInvertedIndex();
-
-  return out;
-}
-
-CellArray *CellArray::Cross(AbstractCellArray *othercells, CrossNodeMap &h) {
-  CellArray *out = new CellArray();
-
-  int mysize = this->getsize();
-  int yoursize = othercells->getsize();
-  
-
-  int s=0;
-  //cout << this->getNodeCount()  << ", " <<  othercells->getNodeCount() << ": ";
-  unsigned int outnodes = this->getNodeCount() * othercells->getNodeCount();
-  Node *raw = new Node[outnodes];
-
-  out->setNodeArray(raw, outnodes);
-  
-  int i, j;
-  int nextnode = 0;
-  int nextsize = 0;
-
-  float tpost = gettime();
-  vector<Cell> &outies = *out->getCellVector();
-  //outies.resize(mysize * yoursize);
-  //outies.clear();
-  outies.reserve(mysize*yoursize);
+	Ptr me, mylast;
+	Ptr you, yourlast;
+	CellArray *out = new CellArray();
+	vector<Cell> *ours = out->getCellVector();
+
+	SortedCellIndex sortedcells;
+	SortedCellIndex othersortedcells;
+
+	for (size_t i = 0; i < cells.size(); i++) {
+		sortedcells[cells[i]] = i;
+	}
+	for (size_t i = 0; i < othercells->getsize(); i++) {
+		othersortedcells[*(othercells->getCell(i))] = i;
+	}
+
+	me = sortedcells.begin();
+	mylast = sortedcells.end();
+	you = othersortedcells.begin();
+	yourlast = othersortedcells.end();
+
+	while (me != mylast && you != yourlast) {
+
+		//((Cell)(*me).first).print();
+		//  ((Cell)(*you).first).print();
+		if ((*me).first < (*you).first) {
+			++me;
+			continue;
+		}
+		if ((*you).first < (*me).first) {
+			++you;
+			continue;
+		}
+		if ((*me).first == (*you).first) {
+			ours->push_back((*me).first);
+			//cout << "match!" << endl;
+			++me;
+			++you;
+		}
+		else {
+			((Cell) (*me).first).print();
+			((Cell) (*you).first).print();
+
+			Fatal("Error computing intersection.");
+		}
+	}
+
+	//out->buildInvertedIndex();
+
+	return out;
+}
+
+CellArray *CellArray::Cross(AbstractCellArray *othercells, CrossNodeMap &h)
+{
+	CellArray *out = new CellArray();
+
+	int mysize = this->getsize();
+	int yoursize = othercells->getsize();
+
+	int s = 0;
+	//cout << this->getNodeCount()  << ", " <<  othercells->getNodeCount() << ": ";
+	unsigned int outnodes = this->getNodeCount() * othercells->getNodeCount();
+	Node *raw = new Node[outnodes];
+
+	out->setNodeArray(raw, outnodes);
+
+	int i, j;
+	int nextnode = 0;
+	int nextsize = 0;
+
+	float tpost = gettime();
+	vector<Cell> &outies = *out->getCellVector();
+	//outies.resize(mysize * yoursize);
+	//outies.clear();
+	outies.reserve(mysize * yoursize);
 //  Cell c;
 //  Cell *cs = (Cell *) malloc(mysize * yoursize * sizeof(Cell));
 //  uninitialized_fill(outies.insert(outies.end(), mysize * yoursize, Cell());
-  outies.insert(outies.end(), mysize * yoursize, Cell());
-  //cout << "resize: " << gettime() - tpost << "\n";
+	outies.insert(outies.end(), mysize * yoursize, Cell());
+	//cout << "resize: " << gettime() - tpost << "\n";
 
-  vector<Cell> &yours = *othercells->getCellVector();
-  Cell x;
-  tpost = gettime();
-  
-  for (i=0; i<mysize; i++) {  
-    for (j=0; j<yoursize; j++) {
-      //      c1 = &cells[i];
-      //      c2 = &yours[j];
-      nextsize = i*(yoursize) + j;
-      
-      this->cells[i].Cross2(yours[j], h, s, &raw[nextnode]);
-      
-      Cell &x = outies[nextsize];
-      x.setsize(s);
-      x.setnodes((&(raw[nextnode])));
-      //outies[nextsize].nodes = &raw[nextnode];
-      //outies[nextsize].deletenodes = false;
+	vector<Cell> &yours = *othercells->getCellVector();
+	Cell x;
+	tpost = gettime();
+
+	for (i = 0; i < mysize; i++) {
+		for (j = 0; j < yoursize; j++) {
+			//      c1 = &cells[i];
+			//      c2 = &yours[j];
+			nextsize = i * (yoursize) + j;
+
+			this->cells[i].Cross2(yours[j], h, s, &raw[nextnode]);
+
+			Cell &x = outies[nextsize];
+			x.setsize(s);
+			x.setnodes((&(raw[nextnode])));
+			//outies[nextsize].nodes = &raw[nextnode];
+			//outies[nextsize].deletenodes = false;
 
 //      outies[nextsize].print();
-      //outies.push_back(x);
-      nextnode += s;
-    }
-  }
-  
-
-  /*
-  vector<Cell> &o  = out->cells;
-  vector<Cell>::iterator p;
-  int ci=0;
-  for (p=o.begin(); p!=o.end(); ++p) {
-    (*p) = outies[ci++];
-  }
-  */
-  //  cout << "making cells...\n";
-  /*
-  nextnode = 0;
-  for (int i=0; i<mysize * yoursize; i++) {
-    out->cells[i].size = s[i];
-    //    cout << "s[i] = " << s[i] << "\n";
-    out->cells[i].setnodes(&raw[nextnode]);
-    //    cout << "nextnode = " << nextnode << "\n";
-    //    cout << "raw[nextnode] = " << raw[nextnode] << "\n";
-    nextnode += s[i];
-  }
-  */
-  return out;
+			//outies.push_back(x);
+			nextnode += s;
+		}
+	}
+
+	/*
+	 vector<Cell> &o  = out->cells;
+	 vector<Cell>::iterator p;
+	 int ci=0;
+	 for (p=o.begin(); p!=o.end(); ++p) {
+	 (*p) = outies[ci++];
+	 }
+	 */
+	//  cout << "making cells...\n";
+	/*
+	 nextnode = 0;
+	 for (int i=0; i<mysize * yoursize; i++) {
+	 out->cells[i].size = s[i];
+	 //    cout << "s[i] = " << s[i] << "\n";
+	 out->cells[i].setnodes(&raw[nextnode]);
+	 //    cout << "nextnode = " << nextnode << "\n";
+	 //    cout << "raw[nextnode] = " << raw[nextnode] << "\n";
+	 nextnode += s[i];
+	 }
+	 */
+	return out;
 }
 
 /*
-CellArray *CellArray::nodeFilter(vector<Node> nodes) {
-  if (this->incidence.empty()) this->buildIncidenceIndex();
+ CellArray *CellArray::nodeFilter(vector<Node> nodes) {
+ if (this->incidence.empty()) this->buildIncidenceIndex();
 
-  vector<Node>::iterator i;
-  IncidenceIndex::iterator cs;
-  set<Cell> *cellsAsSet = new set<Cell>;
-  set<Cell> *subtrahend;
-  set<Cell> *temp = new set<Cell>;
-
-  copy(cells.begin(), cells.end(), inserter(*cellsAsSet, (*cellsAsSet).begin()));
-//  cellsAsSet.insert(cells.begin(), cells.end());
-  
-  
-  for (i=nodes.begin(); i!=nodes.end(); i++) {
-    cs = incidence.find((*i));
-    subtrahend = &((*cs).second);
-    set_difference(cellsAsSet->begin(), cellsAsSet->end(),
-                   subtrahend->begin(), subtrahend->end(),
-                   inserter(*temp,(*temp).begin()));
-    
-    subtrahend->clear();
-    subtrahend = cellsAsSet;
-    cellsAsSet = temp;
-    temp = subtrahend;
-    temp->clear();
-    
-//  cellsAsSet.erase((*cs).second.begin(), (*cs).second.end());
-  }
-  
-  CellArray *out =  new CellArray();
-  insert_iterator<vector<Cell> > ii(out->cells, out->cells.begin());
-  copy(cellsAsSet->begin(), cellsAsSet->end(), ii);
-  
-}
-*/
-void CellArray::Append(AbstractCellArray *othercells) {
-  vector<Cell> *others = othercells->getCellVector();
-  cells.reserve(others->size());
-  cells.insert(cells.end(), others->begin(), others->end());
-  this->nodecount += othercells->getNodeCount();
-}
-
-void CellArray::mapNodes(UnaryNodeMap &h) {
-  //if (inverted_cells.empty()) this->buildInvertedIndex();
-  for (size_t i=0; i<getsize(); i++) {
-    getCell(i)->mapNodes(h);
-  }
-}
-
-CrossNodeMap CellArray::makeCrossNodeMap(AbstractCellArray *other) {
-  return CrossNodeMap(this, other);
-}
-
-void CellArray::toNodeSet(set<Node> &outset) {
-  
-  Cell *c;
-  Node *cn;
-
-  int n = cells.size();
-
-  for (int i=0; i<n; i++) {
-    c = getCell(i);  
-    cn = getCellNodes(i);
-    for (unsigned int j=0; j<c->getsize(); j++)
-      outset.insert(cn[j]);
-  }
+ vector<Node>::iterator i;
+ IncidenceIndex::iterator cs;
+ set<Cell> *cellsAsSet = new set<Cell>;
+ set<Cell> *subtrahend;
+ set<Cell> *temp = new set<Cell>;
+
+ copy(cells.begin(), cells.end(), inserter(*cellsAsSet, (*cellsAsSet).begin()));
+ //  cellsAsSet.insert(cells.begin(), cells.end());
+
+
+ for (i=nodes.begin(); i!=nodes.end(); i++) {
+ cs = incidence.find((*i));
+ subtrahend = &((*cs).second);
+ set_difference(cellsAsSet->begin(), cellsAsSet->end(),
+ subtrahend->begin(), subtrahend->end(),
+ inserter(*temp,(*temp).begin()));
+
+ subtrahend->clear();
+ subtrahend = cellsAsSet;
+ cellsAsSet = temp;
+ temp = subtrahend;
+ temp->clear();
+
+ //  cellsAsSet.erase((*cs).second.begin(), (*cs).second.end());
+ }
+
+ CellArray *out =  new CellArray();
+ insert_iterator<vector<Cell> > ii(out->cells, out->cells.begin());
+ copy(cellsAsSet->begin(), cellsAsSet->end(), ii);
+
+ }
+ */
+void CellArray::Append(AbstractCellArray *othercells)
+{
+	vector<Cell> *others = othercells->getCellVector();
+	cells.reserve(others->size());
+	cells.insert(cells.end(), others->begin(), others->end());
+	this->nodecount += othercells->getNodeCount();
+}
+
+void CellArray::mapNodes(UnaryNodeMap &h)
+{
+	//if (inverted_cells.empty()) this->buildInvertedIndex();
+	for (size_t i = 0; i < getsize(); i++) {
+		getCell(i)->mapNodes(h);
+	}
 }
 
-int ca_instances=0;
+CrossNodeMap CellArray::makeCrossNodeMap(AbstractCellArray *other)
+{
+	return CrossNodeMap(this, other);
+}
+
+void CellArray::toNodeSet(set<Node> &outset)
+{
+
+	Cell *c;
+	Node *cn;
 
-void CellArray::ref() {
-  //cout << "--" << ca_instances++ << endl;
+	int n = cells.size();
+
+	for (int i = 0; i < n; i++) {
+		c = getCell(i);
+		cn = getCellNodes(i);
+		for (unsigned int j = 0; j < c->getsize(); j++)
+			outset.insert(cn[j]);
+	}
+}
+
+int ca_instances = 0;
+
+void CellArray::ref()
+{
+	//cout << "--" << ca_instances++ << endl;
 //  cout << "cellarray ref" << endl;
-  Object::ref();
+	Object::ref();
 }
 
-void CellArray::unref() {
-  ca_instances--;
-  int old = refcount;
-  Object::unref();
-  DEBUG << "cellarray " << this << ", unref: " << old << " -> " << this->refcount << endl;
-  if (old == 0) cout << "bad refcount" << endl;
-  //cout << "cellarray " << this << ", unref: " << old << " -> " << this->refcount << endl;
-  if (this->norefs()) {
-    //cout << "deleting cellarray" << endl;
-    delete this;
-  }
+void CellArray::unref()
+{
+	ca_instances--;
+	int old = refcount;
+	Object::unref();
+	DEBUG << "cellarray " << this << ", unref: " << old << " -> " << this->refcount << endl;
+	if (old == 0) cout << "bad refcount" << endl;
+	//cout << "cellarray " << this << ", unref: " << old << " -> " << this->refcount << endl;
+	if (this->norefs()) {
+		//cout << "deleting cellarray" << endl;
+		delete this;
+	}
 }
+
+} // namespace GF
+
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/cellarray.h gridfields/clib/src/cellarray.h
--- tag/gridfieldsclib-0.7/src/cellarray.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/cellarray.h	2014-05-16 22:57:00.746725199 +0200
@@ -1,94 +1,105 @@
 #ifndef _CELLARRAY_H
-#define _CELLARRAY_H 
+#define _CELLARRAY_H
+
+//#include "config_gridfields.h"
+
+#include <iostream>
 
 #include <vector>
 #include <set>
 #include <map>
-#include <ext/hash_map>
-#include <iostream>
+
+#include "gridfields_hash_map.h"
 
 #include "cell.h"
 #include "abstractcellarray.h"
 
+namespace GF {
+using namespace std;
 
-class CellArray : public AbstractCellArray {
- public:
-  typedef map<Cell, int, ltCell> SortedCellIndex;
-  typedef hash_map<Cell, int, SimpleCellHash> InvertedCellIndex;
-  //typedef map<Cell, int> InvertedCellIndex;
-  typedef hash_map<Node, set<CellId> > IncidenceIndex;
-  
-  CellArray() : cleanup_node_array(false), 
-                nodecount(0),
-                node_array(NULL), 
-                UseAdjacencyIndex(false)  
-  { this->ref(); };
-  
-  CellArray(std::vector<Cell> vec) : cells(vec),
-                                     cleanup_node_array(false), 
-                                     node_array(NULL), 
-                                     UseAdjacencyIndex(false)
-  { this->ref(); };
-  
-  virtual int whoami() { return 1; };
-  CellArray(Node *cells, int cellcount, int nodespercell);
-  CellArray(Node *cells, int cellcount);
-  ~CellArray();
-  idx getsize();
-  void addCell(Cell &c);
-  void addCell(Cell *c);
-  Cell *addCellNodes(Node *nodes, int size);
-
-  Cell *getCell(idx i);
-  Cell getCellCopy(idx i);
-  Node *getCellNodes(idx i);
-
-  //void Edges(CellArray *onecells);
-
-  bool contains(const Cell &c); 
-  idx getOrd(const Cell &c);
-  idx getOrd(Node n);
-  int bytes();
-  void ref();
-  void unref();
-
-  void setNodeArray(Node *na, unsigned int ns);
-  void getIncidentCells(Node n, set<CellId> &out);
-  void getIncidentCells(const Cell &c, set<CellId> &out);
-  void getAdjacentCells(CellId c, vector<CellId> &out);
-  unsigned int getNodeCount() { return this->nodecount; };
-  
-  void print(size_t indent);
-  void print();
-
-  void toNodeSet(set<Node> &outset);
-
-  //CellArray *nodeFilter(vector<Node> nodes);
-  CellArray *Intersection(AbstractCellArray *othercells);
-  CellArray *Cross(AbstractCellArray *othercells, CrossNodeMap &h);
-  void Append(AbstractCellArray *othercells);
-
-  void mapNodes(UnaryNodeMap &h);
-  CrossNodeMap makeCrossNodeMap(AbstractCellArray *other);
-
-  void buildInvertedIndex();
-  void buildIncidenceIndex();
-  void buildAdjacencyIndex();
-
-  vector<Cell> *getCellVector() { return &cells; }
-  
- private:
-  vector<Cell> cells;
- public:
-  bool cleanup_node_array;
- private:
-  unsigned int nodecount;
-  Node *node_array;
-  //hash_map<Cell, int, CellHash, eqCell>  hashed_cells;
-  InvertedCellIndex inverted_cells;
-  IncidenceIndex incidence;
-  vector<vector<CellId> > adj;
-  bool UseAdjacencyIndex;
+class CellArray: public AbstractCellArray {
+public:
+	typedef map<Cell, int, ltCell> SortedCellIndex;
+	typedef HASH_MAP<Cell, int, SimpleCellHash> InvertedCellIndex;
+	// typedef hash_map<Cell, int, SimpleCellHash> InvertedCellIndex;
+	// jhrg 2/13/14
+	//typedef map<Cell, int> InvertedCellIndex;
+	// typedef hash_map<Node, set<CellId> > IncidenceIndex;
+	// jhrg 2/13/14
+	typedef HASH_MAP<Node, set<CellId> > IncidenceIndex;
+
+	CellArray() : cleanup_node_array(false),
+	nodecount(0),
+	node_array(NULL),
+	UseAdjacencyIndex(false)
+	{   this->ref();};
+
+	CellArray(std::vector<Cell> vec) : cells(vec),
+	cleanup_node_array(false),
+	node_array(NULL),
+	UseAdjacencyIndex(false)
+	{   this->ref();};
+
+	virtual int whoami() {return 1;};
+	CellArray(Node *cells, int cellcount, int nodespercell);
+	CellArray(Node *cells, int cellcount);
+	~CellArray();
+	idx getsize();
+	void addCell(Cell &c);
+	void addCell(Cell *c);
+	Cell *addCellNodes(Node *nodes, int size);
+	vector< vector<int> > makeArrayInts();
+	Cell *getCell(idx i);
+	Cell getCellCopy(idx i);
+	Node *getCellNodes(idx i);
+
+	//void Edges(CellArray *onecells);
+
+	bool contains(const Cell &c);
+	idx getOrd(const Cell &c);
+	idx getOrd(Node n);
+	int bytes();
+	void ref();
+	void unref();
+
+	void setNodeArray(Node *na, unsigned int ns);
+	void getIncidentCells(Node n, set<CellId> &out);
+	void getIncidentCells(const Cell &c, set<CellId> &out);
+	void getAdjacentCells(CellId c, vector<CellId> &out);
+	unsigned int getNodeCount() {return this->nodecount;};
+
+	void print(size_t indent);
+	void print();
+
+	void toNodeSet(set<Node> &outset);
+
+	//CellArray *nodeFilter(vector<Node> nodes);
+	CellArray *Intersection(AbstractCellArray *othercells);
+	CellArray *Cross(AbstractCellArray *othercells, CrossNodeMap &h);
+	void Append(AbstractCellArray *othercells);
+
+	void mapNodes(UnaryNodeMap &h);
+	CrossNodeMap makeCrossNodeMap(AbstractCellArray *other);
+	void buildInvertedIndex();
+	void buildIncidenceIndex();
+	void buildAdjacencyIndex();
+
+	vector<Cell> *getCellVector() {return &cells;}
+
+private:
+	vector<Cell> cells;
+public:
+	bool cleanup_node_array;
+private:
+	unsigned int nodecount;
+	Node *node_array;
+	//hash_map<Cell, int, CellHash, eqCell>  hashed_cells;
+	InvertedCellIndex inverted_cells;
+	IncidenceIndex incidence;
+	vector<vector<CellId> > adj;
+	bool UseAdjacencyIndex;
 };
 
+} // namespace GF
+
 #endif /* _CELLARRAY_H */
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/cell.cc gridfields/clib/src/cell.cc
--- tag/gridfieldsclib-0.7/src/cell.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/cell.cc	2014-05-16 22:57:00.800058531 +0200
@@ -1,239 +1,267 @@
+#include "config_gridfields.h"
+
 #include "timing.h"
 #include <assert.h>
 #include <iterator>
 #include <iostream>
-#include <ext/algorithm> 
+#include <algorithm>
+// jhrg 2/13/14 #include <ext/algorithm>
 #include "crossnodemap.h"
 #include "normnodemap.h"
 
+namespace GF {
 
-void Cell::print() const {
-  print(0);
-}
-
-void Cell::setNode(unsigned int i, Node n){ 
-  this->nodes[i] = n;
-}
-
-void Cell::print(int indent) const {
-  const Cell *c = this;
-  int i;
-  for (i=0; i<indent; i++) printf(" ");
-  cout << "<CELL>" << endl;
-  for (i=0; i<indent; i++) printf(" ");
-  cout << "size: " << c->size << endl;
-  for (i=0; i<indent; i++) printf(" ");
-  cout << "nodes: ";
-  for (i=0; i<c->size; i++) {
-    cout << c->nodes[i] << " ";
-  }
-  cout << endl;
-}
-
-Cell::Cell() {
-  deletenodes = false;
-  size = 0;
-  nodes = NULL;
+void Cell::print() const
+{
+	print(0);
+}
+
+void Cell::setNode(unsigned int i, Node n)
+{
+	this->nodes[i] = n;
+}
+
+void Cell::print(int indent) const
+{
+	const Cell *c = this;
+	int i;
+	for (i = 0; i < indent; i++)
+		printf(" ");
+	cout << "<CELL>" << endl;
+	for (i = 0; i < indent; i++)
+		printf(" ");
+	cout << "size: " << c->size << endl;
+	for (i = 0; i < indent; i++)
+		printf(" ");
+	cout << "nodes: ";
+	for (i = 0; i < c->size; i++) {
+		cout << c->nodes[i] << " ";
+	}
+	cout << endl;
+}
+
+Cell::Cell()
+{
+	deletenodes = false;
+	size = 0;
+	nodes = NULL;
 }
 /*
-Cell::Cell(bool delete) {
-  deletenodes = delete;
-  size = 0;
-  nodes = NULL;
-}
-*/
-Cell::Cell(int s) {
-  deletenodes = true;
-  size = s;
-  nodes = new Node[s];
-}
-
-Cell::Cell(int s, Node *ns) {
-  deletenodes = false;
-  size = s;
-  nodes = ns;
-}
-
-Cell::Cell(int *ns, int s) {
-  deletenodes = true;
-  size = s;
-  nodes = new Node[s];
-  for (int i=0; i<s; i++){
-    nodes[i] = ns[i];
-  }
-}
-
-Cell& Cell::operator=(const Cell& that) {
-  Node *newnodes = 0;
-  // attempt to allocate the node array
-  try {
-    newnodes = new Node[that.size];
-  } 
-  catch (...) {
-    // if we fail, delete whatever we have
-    delete newnodes;
-  }
-  // if we own our node array, delete it.
-  if (deletenodes) {
-    delete [] this->nodes;
-  }
-  // copy the rhs to lhs
-  for (int i=0; i<that.size; i++) {
-    newnodes[i] = that.nodes[i];
-  } 
-
-  // we own our new node array
-  this->deletenodes = true;
-  // set our node array to newnodes
-  this->nodes = newnodes;
-  this->size = that.size;
-  // C++ convention is to retirn the lhs
-  return *this;
-}
-
-Cell::Cell(const Cell &rhs) {
-  // we own our nodes
-  deletenodes = true;
-  // Set the size
-  this->size = rhs.size;
-  this->nodes = NULL;
-  if (size == 0) return;
-  this->nodes = new Node[size];
-  // copy the node data
-  for (int i=0; i<size; i++) {
-    this->nodes[i] = rhs.nodes[i];
-  }     
-}
-void Cell::setnodes(Node *p) { 
-  this->deletenodes = false; 
-  nodes = p; 
-}
-
-Cell::~Cell() {
-  if (deletenodes) {
-    for (int i=0; i<size; i++) {
-      //cout << nodes[i] << endl;
-    }
-    delete [] this->nodes;
-  }
+ Cell::Cell(bool delete) {
+ deletenodes = delete;
+ size = 0;
+ nodes = NULL;
+ }
+ */
+Cell::Cell(int s)
+{
+	deletenodes = true;
+	size = s;
+	nodes = new Node[s];
+}
+
+Cell::Cell(int s, Node *ns)
+{
+	deletenodes = false;
+	size = s;
+	nodes = ns;
+}
+
+Cell::Cell(int *ns, int s)
+{
+	deletenodes = true;
+	size = s;
+	nodes = new Node[s];
+	for (int i = 0; i < s; i++) {
+		nodes[i] = ns[i];
+	}
+}
+
+Cell& Cell::operator=(const Cell& that)
+{
+	Node *newnodes = 0;
+	// attempt to allocate the node array
+	try {
+		newnodes = new Node[that.size];
+	}
+	catch (...) {
+		// if we fail, delete whatever we have
+		delete newnodes;
+	}
+	// if we own our node array, delete it.
+	if (deletenodes) {
+		delete[] this->nodes;
+	}
+	// copy the rhs to lhs
+	for (int i = 0; i < that.size; i++) {
+		newnodes[i] = that.nodes[i];
+	}
+
+	// we own our new node array
+	this->deletenodes = true;
+	// set our node array to newnodes
+	this->nodes = newnodes;
+	this->size = that.size;
+	// C++ convention is to retirn the lhs
+	return *this;
+}
+
+Cell::Cell(const Cell &rhs)
+{
+	// we own our nodes
+	deletenodes = true;
+	// Set the size
+	this->size = rhs.size;
+	this->nodes = NULL;
+	if (size == 0) return;
+	this->nodes = new Node[size];
+	// copy the node data
+	for (int i = 0; i < size; i++) {
+		this->nodes[i] = rhs.nodes[i];
+	}
+}
+void Cell::setnodes(Node *p)
+{
+	this->deletenodes = false;
+	nodes = p;
+}
+
+Cell::~Cell()
+{
+	if (deletenodes) {
+		for (int i = 0; i < size; i++) {
+			//cout << nodes[i] << endl;
+		}
+		delete[] this->nodes;
+	}
 }
 
 /*
-void Cell::Guess2DEdges(CellArray *onecells) {
-  int nodepair[2];
-  for (int i=0; i<this->size-1; i++) {
-    nodepair[0] = this->nodes[i]; 
-    nodepair[1] = this->nodes[i+1]; 
-    onecells->addCellNodes(nodepair); 
-  }
-}
-*/
-
+ void Cell::Guess2DEdges(CellArray *onecells) {
+ int nodepair[2];
+ for (int i=0; i<this->size-1; i++) {
+ nodepair[0] = this->nodes[i];
+ nodepair[1] = this->nodes[i+1];
+ onecells->addCellNodes(nodepair);
+ }
+ }
+ */
 
 /*
-void Cell::Cross(Cell &rhs, CrossNodeMap &h, Cell &out) {
-  out.size = size* rhs.size; 
-  for (int i=0; i<out.size; i++) {
-    out.nodes[i] = h.map(nodes[i%size], rhs.nodes[i/size]);
-  }
-}
-*/
-
-Cell *Cell::Cross(Cell &rhs, CrossNodeMap &h) const {
-  Cell *out = new Cell(size * rhs.size);
-  for (int i=0; i<out->size; i++) {
-    out->nodes[i] = h.map(nodes[i%size], rhs.nodes[i/size]);
+ void Cell::Cross(Cell &rhs, CrossNodeMap &h, Cell &out) {
+ out.size = size* rhs.size;
+ for (int i=0; i<out.size; i++) {
+ out.nodes[i] = h.map(nodes[i%size], rhs.nodes[i/size]);
+ }
+ }
+ */
+
+Cell *Cell::Cross(Cell &rhs, CrossNodeMap &h) const
+{
+	Cell *out = new Cell(size * rhs.size);
+	for (int i = 0; i < out->size; i++) {
+		out->nodes[i] = h.map(nodes[i % size], rhs.nodes[i / size]);
 //    out->nodes[i] = h.map(nodes[i/rhs.size], rhs.nodes[i%rhs.size]);
-  }
-  return out;
+	}
+	return out;
 }
 /*
-void Cell::Cross21(Cell &rhs, CrossNodeMap &h, int &s, Node *n) const {
-  s = size * rhs.size;
-  
-  for (int i=0; i<size; i++) {
-    for (int j=0; j<rhs.size; j++) {
-      n[i*rhs.size + j] 
-        = h.map(nodes[i], rhs.nodes[j]);
-    }
-  }
-}  
-*/
-void Cell::Cross2(Cell &rhs, CrossNodeMap &h, int &s, Node *n) const {
-  s = size * rhs.size;
-  
-  if ((size == 2) & (rhs.size == 2)) {
-    for (int i=0; i<size; i++) {
-      for (int j=0; j<rhs.size; j++) {
-        n[i*rhs.size + j] 
-          = h.map(nodes[i], rhs.nodes[(1-i%2)*j + (i%2)*(rhs.size-j-1)]);
-      }
-    }
-  } else if ((rhs.size > 2) & (size == 2)) {
-    for (int j=0; j<rhs.size; j++) {
-      for (int i=0; i<size; i++) {
-        n[i*rhs.size + j] = h.map(nodes[i], rhs.nodes[j]);
-      }
-    }
-  } else {
-    for (int j=0; j<rhs.size; j++) {
-      for (int i=0; i<size; i++) {
-        n[j*size + i] = h.map(nodes[i], rhs.nodes[j]);
-      }
-    }
-  }
- /* 
-  for (int i=0; i<s; i++) {
-//    n[i] = h.map(nodes[i%size], rhs.nodes[i/size]);
-    n[i] = h.map(nodes[i/rhs.size], rhs.nodes[i%rhs.size]);
-  }
-  */
-}
-
-void Cell::mapNodes(UnaryNodeMap &h) {
-  for (int i=0; i<size; i++) {
-    nodes[i] = h.map(nodes[i]);
-  }
-}
-
-/* Return True if the nodes of the rhs Cell are 
- * a subset of this cell's nodes.  This property is 
- * a proxy for true incidence in this node-oriented 
+ void Cell::Cross21(Cell &rhs, CrossNodeMap &h, int &s, Node *n) const {
+ s = size * rhs.size;
+
+ for (int i=0; i<size; i++) {
+ for (int j=0; j<rhs.size; j++) {
+ n[i*rhs.size + j]
+ = h.map(nodes[i], rhs.nodes[j]);
+ }
+ }
+ }
+ */
+void Cell::Cross2(Cell &rhs, CrossNodeMap &h, int &s, Node *n) const
+{
+	s = size * rhs.size;
+
+	if ((size == 2) & (rhs.size == 2)) {
+		for (int i = 0; i < size; i++) {
+			for (int j = 0; j < rhs.size; j++) {
+				n[i * rhs.size + j] = h.map(nodes[i], rhs.nodes[(1 - i % 2) * j + (i % 2) * (rhs.size - j - 1)]);
+			}
+		}
+	}
+	else if ((rhs.size > 2) & (size == 2)) {
+		for (int j = 0; j < rhs.size; j++) {
+			for (int i = 0; i < size; i++) {
+				n[i * rhs.size + j] = h.map(nodes[i], rhs.nodes[j]);
+			}
+		}
+	}
+	else {
+		for (int j = 0; j < rhs.size; j++) {
+			for (int i = 0; i < size; i++) {
+				n[j * size + i] = h.map(nodes[i], rhs.nodes[j]);
+			}
+		}
+	}
+	/*
+	 for (int i=0; i<s; i++) {
+	 //    n[i] = h.map(nodes[i%size], rhs.nodes[i/size]);
+	 n[i] = h.map(nodes[i/rhs.size], rhs.nodes[i%rhs.size]);
+	 }
+	 */
+}
+
+void Cell::mapNodes(UnaryNodeMap &h)
+{
+	for (int i = 0; i < size; i++) {
+		nodes[i] = h.map(nodes[i]);
+	}
+}
+
+/* Return True if the nodes of the rhs Cell are
+ * a subset of this cell's nodes.  This property is
+ * a proxy for true incidence in this node-oriented
  * representation.  See dissertation.
  */
 
-bool Cell::IncidentTo(const Cell &rhs) const {
-  for (unsigned int i=0; i<rhs.getsize(); i++) {
-    if (!this->hasNode(rhs.getnodes()[i])) return false;
-  }
-  return true;
-}
-
-bool Cell::operator==(const Cell &rhs) const {
-  if (size != rhs.size) return false;
-  for (int i=0; i<size; i++)
-    if (nodes[i] != rhs.nodes[i]) return false;
-  
-  return true;
-}
-
-bool Cell::operator<(const Cell &rhs) const {
-  if (size < rhs.size) return true;
-  if (size > rhs.size) return false;
-  //  cout << "cell:\n";
-  for (int i=0; i<size; i++) {
-    //cout << nodes[i] << ", " <<  rhs.nodes[i] << "\n";
-    if (nodes[i] < rhs.nodes[i]) return true;
-    if (rhs.nodes[i] < nodes[i]) return false;
-  }
-  return false;  
-}
-
-bool Cell::eq(Cell *c2) {
-  for (int i=0; i<this->size; i++) {
-    if (this->nodes[i] != c2->nodes[i]) {
-      return false;
-    }
-  }
-  return true;
+bool Cell::IncidentTo(const Cell &rhs) const
+{
+	for (unsigned int i = 0; i < rhs.getsize(); i++) {
+		if (!this->hasNode(rhs.getnodes()[i])) return false;
+	}
+	return true;
+}
+
+bool Cell::operator==(const Cell &rhs) const
+{
+	if (size != rhs.size) return false;
+	for (int i = 0; i < size; i++)
+		if (nodes[i] != rhs.nodes[i]) return false;
+
+	return true;
+}
+
+bool Cell::operator<(const Cell &rhs) const
+{
+	if (size < rhs.size) return true;
+	if (size > rhs.size) return false;
+	//  cout << "cell:\n";
+	for (int i = 0; i < size; i++) {
+		//cout << nodes[i] << ", " <<  rhs.nodes[i] << "\n";
+		if (nodes[i] < rhs.nodes[i]) return true;
+		if (rhs.nodes[i] < nodes[i]) return false;
+	}
+	return false;
+}
+
+bool Cell::eq(Cell *c2)
+{
+	for (int i = 0; i < this->size; i++) {
+		if (this->nodes[i] != c2->nodes[i]) {
+			return false;
+		}
+	}
+	return true;
 }
+
+} // namespace GF
+
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/cell.h gridfields/clib/src/cell.h
--- tag/gridfieldsclib-0.7/src/cell.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/cell.h	2014-05-16 22:57:00.800058531 +0200
@@ -1,106 +1,137 @@
 #ifndef _CELL_H
-#define _CELL_H 
+#define _CELL_H
 
 //#define __USE_MALLOC
 #include "type.h"
 #include <cmath>
 #include <vector>
 //using namespace __gnu_cxx;
-using namespace std;
+//using namespace std;
+
+namespace GF {
 
 class UnaryNodeMap;
 class CrossNodeMap;
 
 typedef unsigned long CellId;
 typedef std::vector<CellId> CellVector;
-// Changed 'short' to 'unsigned short'. jhrg 10/5/11
+// Change 'short' to 'unsigned short'? jhrg 10/5/11
+// NO. There must be places where the signed-ness of Dim_t variables
+// is used. Changing Dim_t to an unsigned short breaks a test and
+// makes some dimensions that are '3' normally become '65536'. 4/7/14 jhrg
 typedef short Dim_t;
 
 class Cell {
- public:
-  Cell();
-  //Cell(bool delete) ;
-  Cell(int s);
-  Cell(int s, Node *ns);
-  Cell(int *nodes, int s);
-  Cell(const Cell &rhs);
-  ~Cell();
-
-  Cell *Cross(Cell &rhs, CrossNodeMap &h) const;
-  void Cross2(Cell &rhs, CrossNodeMap &h, int &s, Node *n) const;
-  void mapNodes(UnaryNodeMap &h);
-
-  void setNode(unsigned int i, Node n);
-
-  bool eq(Cell *c2);
-  bool operator==(const Cell &rhs) const;
-  bool operator<(const Cell &rhs) const;
-  bool operator[](int &i) const { return nodes[i]; };
-  Cell& operator=(const Cell& that);
-
-  void print(int indent) const;
-  void print() const;
-
-  bool hasNode(Node n) const {
-    for (int j=0; j<size; j++) {
-      if (nodes[j] == n) return true;
-    }
-    return false;
-  }
-
-  /* Return True if the nodes of the rhs Cell are 
-   * a subset of this cell's nodes.  This property is 
-   * a proxy for true incidence in this node-oriented 
-   * representation.  See dissertation.
-   */
-  bool IncidentTo(const Cell &rhs) const;
-
-  void setsize(int sz) { size = sz; }
-  void setnodes(Node *p);
-  
-  unsigned int getsize() const {return size; };
-  Node *getnodes() const { return nodes; };
-  Node getnode(unsigned int i) const { return nodes[i]; };
- 
-  //void Guess2DEdges(CellArray *onecells); 
- private:
-  Node *nodes;
-  bool deletenodes;
-  int size;
+public:
+	Cell();
+	//Cell(bool delete) ;
+	Cell(int s);
+	Cell(int s, Node *ns);
+	Cell(int *nodes, int s);
+	Cell(const Cell &rhs);
+	~Cell();
+
+	Cell *Cross(Cell &rhs, CrossNodeMap &h) const;
+	void Cross2(Cell &rhs, CrossNodeMap &h, int &s, Node *n) const;
+	void mapNodes(UnaryNodeMap &h);
+
+	void setNode(unsigned int i, Node n);
+
+	bool eq(Cell *c2);
+	bool operator==(const Cell &rhs) const;
+	bool operator<(const Cell &rhs) const;
+	bool operator[](int &i) const
+	{
+		return nodes[i];
+	}
+	;
+	Cell& operator=(const Cell& that);
+
+	void print(int indent) const;
+	void print() const;
+
+	bool hasNode(Node n) const
+	{
+		for (int j = 0; j < size; j++) {
+			if (nodes[j] == n) return true;
+		}
+		return false;
+	}
+
+	/* Return True if the nodes of the rhs Cell are
+	 * a subset of this cell's nodes.  This property is
+	 * a proxy for true incidence in this node-oriented
+	 * representation.  See dissertation.
+	 */
+	bool IncidentTo(const Cell &rhs) const;
+
+	void setsize(int sz)
+	{
+		size = sz;
+	}
+	void setnodes(Node *p);
+
+	unsigned int getsize() const
+	{
+		return size;
+	}
+	;
+	Node *getnodes() const
+	{
+		return nodes;
+	}
+	;
+	Node getnode(unsigned int i) const
+	{
+		return nodes[i];
+	}
+	;
+
+	//void Guess2DEdges(CellArray *onecells);
+private:
+	Node *nodes;
+	bool deletenodes;
+	int size;
 };
 
 struct eqCell {
-    bool operator()(const Cell &c1, const Cell &c2) const {
-      if (c1.getsize() != c2.getsize()) return false;
-      for (unsigned int i=0; i<c1.getsize(); i++)
-	if (c1.getnodes()[i] != c2.getnodes()[i]) return false;
-      
-      return true;
-    }
+	bool operator()(const Cell &c1, const Cell &c2) const
+	{
+		if (c1.getsize() != c2.getsize()) return false;
+		for (unsigned int i = 0; i < c1.getsize(); i++)
+			if (c1.getnodes()[i] != c2.getnodes()[i]) return false;
+
+		return true;
+	}
 };
 
-struct ltCell { 
-    bool operator()(const Cell &c1, const Cell &c2) const {
-      return (c1 < c2);
-    }
+struct ltCell {
+	bool operator()(const Cell &c1, const Cell &c2) const
+	{
+		return (c1 < c2);
+	}
 };
 
 class SimpleCellHash {
-  public:
-  int operator()(const Cell &c) const {
-    return c.getnodes()[0];
-  }
+public:
+	int operator()(const Cell &c) const
+	{
+		return c.getnodes()[0];
+	}
 };
 
 class CellHash {
- public:
-  int operator()(const Cell &c) const {
-    int base = 0;
-    for (int i=c.getsize(); i>0; i--) {
-      base += c.getnodes()[i-1] * (int) pow(10.0,i-1);
-    }
-    return base;
-  }
+public:
+	int operator()(const Cell &c) const
+	{
+		int base = 0;
+		for (int i = c.getsize(); i > 0; i--) {
+			base += c.getnodes()[i - 1] * (int) pow(10.0, i - 1);
+		}
+		return base;
+	}
 };
 
-#endif 
+} // namespace GF
+
+#endif
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/CmdLine.h gridfields/clib/src/CmdLine.h
--- tag/gridfieldsclib-0.7/src/CmdLine.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/CmdLine.h	2014-05-16 22:57:00.796725198 +0200
@@ -1,119 +1,118 @@
 /*------------------------------------------------------
-   CCmdLine
+ CCmdLine
 
-   A utility for parsing command lines.
+ A utility for parsing command lines.
 
-   Copyright (C) 1999 Chris Losinger, Smaller Animals Software.
-   http://www.smalleranimals.com
+ Copyright (C) 1999 Chris Losinger, Smaller Animals Software.
+ http://www.smalleranimals.com
 
-   This software is provided 'as-is', without any express
-   or implied warranty.  In no event will the authors be 
-   held liable for any damages arising from the use of this software.
-
-   Permission is granted to anyone to use this software 
-   for any purpose, including commercial applications, and 
-   to alter it and redistribute it freely, subject to the 
-   following restrictions:
-
-     1. The origin of this software must not be misrepresented; 
-   you must not claim that you wrote the original software. 
-   If you use this software in a product, an acknowledgment 
-   in the product documentation would be appreciated but is not required.
-   
-     2. Altered source versions must be plainly marked as such, 
-   and must not be misrepresented as being the original software.
-   
-     3. This notice may not be removed or altered from any source 
-   distribution.
-
-  -------------------------
-
-   Example :
-
-   Our example application uses a command line that has two
-   required switches and two optional switches. The app should abort
-   if the required switches are not present and continue with default
-   values if the optional switches are not present.
-
-      Sample command line : 
-      MyApp.exe -p1 text1 text2 -p2 "this is a big argument" -opt1 -55 -opt2
-
-      Switches -p1 and -p2 are required. 
-      p1 has two arguments and p2 has one.
-      
-      Switches -opt1 and -opt2 are optional. 
-      opt1 requires a numeric argument. 
-      opt2 has no arguments.
-      
-      Also, assume that the app displays a 'help' screen if the '-h' switch
-      is present on the command line.
-
-   #include "CmdLine.h"
-
-   void main(int argc, char **argv)
-   {
-      // our cmd line parser object
-      CCmdLine cmdLine;
-
-      // parse argc,argv 
-      if (cmdLine.SplitLine(argc, argv) < 1)
-      {
-         // no switches were given on the command line, abort
-         ASSERT(0);
-         exit(-1);
-      }
-
-      // test for the 'help' case
-      if (cmdLine.HasSwitch("-h"))
-      {
-         show_help();
-         exit(0);
-      }
-
-      // get the required arguments
-      StringType p1_1, p1_2, p2_1;
-      try
-      {  
-         // if any of these fail, we'll end up in the catch() block
-         p1_1 = cmdLine.GetArgument("-p1", 0);
-         p1_2 = cmdLine.GetArgument("-p1", 1);
-         p2_1 = cmdLine.GetArgument("-p2", 0);
-
-      }
-      catch (...)
-      {
-         // one of the required arguments was missing, abort
-         ASSERT(0);
-         exit(-1);
-      }
-
-      // get the optional parameters
-
-      // convert to an int, default to '100'
-      int iOpt1Val =    atoi(cmdLine.GetSafeArgument("-opt1", 0, 100));
-
-      // since opt2 has no arguments, just test for the presence of
-      // the '-opt2' switch
-      bool bOptVal2 =   cmdLine.HasSwitch("-opt2");
-
-      .... and so on....
-
-   }
-
-   If this class is used in an MFC application, StringType is CString, else
-   it uses the STL 'string' type.
-
-   If this is an MFC app, you can use the __argc and __argv macros from
-   you CYourWinApp::InitInstance() function in place of the standard argc 
-   and argv variables. 
+ This software is provided 'as-is', without any express
+ or implied warranty.  In no event will the authors be
+ held liable for any damages arising from the use of this software.
 
-------------------------------------------------------*/
+ Permission is granted to anyone to use this software
+ for any purpose, including commercial applications, and
+ to alter it and redistribute it freely, subject to the
+ following restrictions:
+
+ 1. The origin of this software must not be misrepresented;
+ you must not claim that you wrote the original software.
+ If you use this software in a product, an acknowledgment
+ in the product documentation would be appreciated but is not required.
+
+ 2. Altered source versions must be plainly marked as such,
+ and must not be misrepresented as being the original software.
+
+ 3. This notice may not be removed or altered from any source
+ distribution.
+
+ -------------------------
+
+ Example :
+
+ Our example application uses a command line that has two
+ required switches and two optional switches. The app should abort
+ if the required switches are not present and continue with default
+ values if the optional switches are not present.
+
+ Sample command line :
+ MyApp.exe -p1 text1 text2 -p2 "this is a big argument" -opt1 -55 -opt2
+
+ Switches -p1 and -p2 are required.
+ p1 has two arguments and p2 has one.
+
+ Switches -opt1 and -opt2 are optional.
+ opt1 requires a numeric argument.
+ opt2 has no arguments.
+
+ Also, assume that the app displays a 'help' screen if the '-h' switch
+ is present on the command line.
+
+ #include "CmdLine.h"
+
+ void main(int argc, char **argv)
+ {
+ // our cmd line parser object
+ CCmdLine cmdLine;
+
+ // parse argc,argv
+ if (cmdLine.SplitLine(argc, argv) < 1)
+ {
+ // no switches were given on the command line, abort
+ ASSERT(0);
+ exit(-1);
+ }
+
+ // test for the 'help' case
+ if (cmdLine.HasSwitch("-h"))
+ {
+ show_help();
+ exit(0);
+ }
+
+ // get the required arguments
+ StringType p1_1, p1_2, p2_1;
+ try
+ {
+ // if any of these fail, we'll end up in the catch() block
+ p1_1 = cmdLine.GetArgument("-p1", 0);
+ p1_2 = cmdLine.GetArgument("-p1", 1);
+ p2_1 = cmdLine.GetArgument("-p2", 0);
+
+ }
+ catch (...)
+ {
+ // one of the required arguments was missing, abort
+ ASSERT(0);
+ exit(-1);
+ }
+
+ // get the optional parameters
+
+ // convert to an int, default to '100'
+ int iOpt1Val =    atoi(cmdLine.GetSafeArgument("-opt1", 0, 100));
+
+ // since opt2 has no arguments, just test for the presence of
+ // the '-opt2' switch
+ bool bOptVal2 =   cmdLine.HasSwitch("-opt2");
+
+ .... and so on....
+
+ }
+
+ If this class is used in an MFC application, StringType is CString, else
+ it uses the STL 'string' type.
+
+ If this is an MFC app, you can use the __argc and __argv macros from
+ you CYourWinApp::InitInstance() function in place of the standard argc
+ and argv variables.
+
+ ------------------------------------------------------*/
 #ifndef SACMDSH
 #define SACMDSH
 
-
 #ifdef __AFX_H__
-// if we're using MFC, use CStrings 
+// if we're using MFC, use CStrings
 #define StringType CString
 #else
 // if we're not using MFC, use STL strings
@@ -133,109 +132,108 @@
 
 #include "src/util.h"
 
-using namespace std ;
+using namespace std;
+using namespace GF;
 
 // handy little container for our argument vector
-struct CCmdParam
-{
-   vector<StringType> m_strings;
+struct CCmdParam {
+	vector<StringType> m_strings;
 };
 
 // this class is actually a map of strings to vectors
 typedef map<StringType, CCmdParam> _CCmdLine;
 
 // the command line parser class
-class CCmdLine : public _CCmdLine
-{
+class CCmdLine: public _CCmdLine {
 
 public:
-   /*------------------------------------------------------
-      int CCmdLine::SplitLine(int argc, char **argv)
+	/*------------------------------------------------------
+	 int CCmdLine::SplitLine(int argc, char **argv)
+
+	 parse the command line into switches and arguments.
+
+	 returns number of switches found
+	 ------------------------------------------------------*/
+	int SplitLine(int argc, char **argv);
 
-      parse the command line into switches and arguments.
+	/*------------------------------------------------------
+	 bool CCmdLine::HasSwitch(const char *pSwitch)
 
-      returns number of switches found
-   ------------------------------------------------------*/
-   int         SplitLine(int argc, char **argv);
+	 was the switch found on the command line ?
 
-   /*------------------------------------------------------
-      bool CCmdLine::HasSwitch(const char *pSwitch)
+	 ex. if the command line is : app.exe -a p1 p2 p3 -b p4 -c -d p5
 
-      was the switch found on the command line ?
+	 call                          return
+	 ----                          ------
+	 cmdLine.HasSwitch("-a")       true
+	 cmdLine.HasSwitch("-z")       false
+	 ------------------------------------------------------*/
+	bool HasSwitch(const char *pSwitch);
 
-      ex. if the command line is : app.exe -a p1 p2 p3 -b p4 -c -d p5
+	/*------------------------------------------------------
 
-      call                          return
-      ----                          ------
-      cmdLine.HasSwitch("-a")       true
-      cmdLine.HasSwitch("-z")       false
-   ------------------------------------------------------*/   
-   bool        HasSwitch(const char *pSwitch);
+	 StringType CCmdLine::GetSafeArgument(const char *pSwitch, int iIdx, const char *pDefault)
 
-   /*------------------------------------------------------
+	 fetch an argument associated with a switch . if the parameter at
+	 index iIdx is not found, this will return the default that you
+	 provide.
 
-      StringType CCmdLine::GetSafeArgument(const char *pSwitch, int iIdx, const char *pDefault)
+	 example :
 
-      fetch an argument associated with a switch . if the parameter at
-      index iIdx is not found, this will return the default that you
-      provide.
+	 command line is : app.exe -a p1 p2 p3 -b p4 -c -d p5
 
-      example :
-  
-      command line is : app.exe -a p1 p2 p3 -b p4 -c -d p5
+	 call                                      return
+	 ----                                      ------
+	 cmdLine.GetSafeArgument("-a", 0, "zz")    p1
+	 cmdLine.GetSafeArgument("-a", 1, "zz")    p2
+	 cmdLine.GetSafeArgument("-b", 0, "zz")    p4
+	 cmdLine.GetSafeArgument("-b", 1, "zz")    zz
 
-      call                                      return
-      ----                                      ------
-      cmdLine.GetSafeArgument("-a", 0, "zz")    p1
-      cmdLine.GetSafeArgument("-a", 1, "zz")    p2
-      cmdLine.GetSafeArgument("-b", 0, "zz")    p4
-      cmdLine.GetSafeArgument("-b", 1, "zz")    zz
+	 ------------------------------------------------------*/
 
-   ------------------------------------------------------*/
+	StringType GetSafeArgument(const char *pSwitch, int iIdx, const char *pDefault);
 
-   StringType  GetSafeArgument(const char *pSwitch, int iIdx, const char *pDefault);
+	/*------------------------------------------------------
 
-   /*------------------------------------------------------
+	 StringType CCmdLine::GetArgument(const char *pSwitch, int iIdx)
 
-      StringType CCmdLine::GetArgument(const char *pSwitch, int iIdx)
+	 fetch a argument associated with a switch. throws an exception
+	 of (int)0, if the parameter at index iIdx is not found.
 
-      fetch a argument associated with a switch. throws an exception 
-      of (int)0, if the parameter at index iIdx is not found.
+	 example :
 
-      example :
-  
-      command line is : app.exe -a p1 p2 p3 -b p4 -c -d p5
+	 command line is : app.exe -a p1 p2 p3 -b p4 -c -d p5
 
-      call                             return
-      ----                             ------
-      cmdLine.GetArgument("-a", 0)     p1
-      cmdLine.GetArgument("-b", 1)     throws (int)0, returns an empty string
+	 call                             return
+	 ----                             ------
+	 cmdLine.GetArgument("-a", 0)     p1
+	 cmdLine.GetArgument("-b", 1)     throws (int)0, returns an empty string
 
-   ------------------------------------------------------*/
-   StringType  GetArgument(const char *pSwitch, idx iIdx); 
+	 ------------------------------------------------------*/
+	StringType GetArgument(const char *pSwitch, idx iIdx);
 
-   /*------------------------------------------------------
-      int CCmdLine::GetArgumentCount(const char *pSwitch)
+	/*------------------------------------------------------
+	 int CCmdLine::GetArgumentCount(const char *pSwitch)
 
-      returns the number of arguments found for a given switch.
+	 returns the number of arguments found for a given switch.
 
-      returns -1 if the switch was not found
+	 returns -1 if the switch was not found
 
-   ------------------------------------------------------*/
-   int         GetArgumentCount(const char *pSwitch);
+	 ------------------------------------------------------*/
+	int GetArgumentCount(const char *pSwitch);
 
 protected:
-   /*------------------------------------------------------
+	/*------------------------------------------------------
 
-   protected member function
-   test a parameter to see if it's a switch :
+	 protected member function
+	 test a parameter to see if it's a switch :
 
-   switches are of the form : -x
-   where 'x' is one or more characters.
-   the first character of a switch must be non-numeric!
+	 switches are of the form : -x
+	 where 'x' is one or more characters.
+	 the first character of a switch must be non-numeric!
 
-   ------------------------------------------------------*/
-   bool        IsSwitch(const char *pParam);
+	 ------------------------------------------------------*/
+	bool IsSwitch(const char *pParam);
 };
 
 #endif
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/constarray.cc gridfields/clib/src/constarray.cc
--- tag/gridfieldsclib-0.7/src/constarray.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/constarray.cc	2014-05-16 22:57:00.750058533 +0200
@@ -1,3 +1,5 @@
+#include "config_gridfields.h"
+
 #include <iostream>
 #include "expr.h"
 #include "tuple.h"
@@ -6,235 +8,276 @@
 
 using namespace std;
 
+namespace GF {
+
+ConstArray::ConstArray(string nm, int sz, Type t, UnTypedPtr constval) :
+		Array(nm.c_str(), t)
+{
+	_size = sz;
+	setConst(constval);
+}
+
+void ConstArray::setConst(UnTypedPtr constval)
+{
+	switch (type) {
+	case INT:
+		int_constant = *(int*) constval;
+		float_constant = 0;
+		obj_constant = 0;
+		break;
+	case FLOAT:
+		int_constant = 0;
+		float_constant = *(float*) constval;
+		obj_constant = 0;
+		break;
+	case OBJ:
+		int_constant = 0;
+		float_constant = 0;
+		obj_constant = constval;
+		break;
+	default:
+		cout << "Unkown type" << endl;
+	}
+}
+
+ConstArray::ConstArray(string nm, int sz, float constval) :
+		Array(nm.c_str(), FLOAT), float_constant(constval), int_constant(0), obj_constant(0)
+
+{
+	_size = sz;
+}
+
+ConstArray::ConstArray(string nm, int sz, int constval) :
+		Array(nm.c_str(), INT), float_constant(0.0), int_constant(constval), obj_constant(0)
+{
+	_size = sz;
+}
+
+ConstArray::ConstArray(string nm, int sz, UnTypedPtr constval) :
+		Array(nm.c_str(), OBJ), float_constant(0.0), int_constant(0), obj_constant(constval)
+{
+	_size = sz;
+}
+
+void ConstArray::getData(void **&)
+{
+	cout << "can't get data from a ConstArray." << endl;
+}
+void ConstArray::getData(float *&)
+{
+	cout << "can't get data from a ConstArray." << endl;
+}
+void ConstArray::getData(int *&)
+{
+	cout << "can't get data from a ConstArray." << endl;
+}
+
+void ConstArray::copyData(int *, int)
+{
+	cout << "can't copy data into a ConstArray." << endl;
+}
+
+void ConstArray::shareData(int *, int)
+{
+	cout << "can't share data with a ConstArray." << endl;
+}
+
+void ConstArray::copyData(float *, int)
+{
+	cout << "can't copy data into a ConstArray." << endl;
+}
+
+void ConstArray::shareData(float *, int)
+{
+	cout << "can't share data with a ConstArray." << endl;
+}
+
+void ConstArray::copyData(UnTypedPtr *, int)
+{
+	cout << "can't copy data into a ConstArray." << endl;
+}
+
+void ConstArray::shareData(void **, int)
+{
+	cout << "can't share data with a ConstArray." << endl;
+}
+
+ConstArray *ConstArray::copy()
+{
+	return resize(_size);
+}
+
+void ConstArray::setVals(UnTypedPtr, int)
+{
+	cout << "can't set Vals of a ConstArray." << endl;
+}
 
-ConstArray::ConstArray(string nm, int sz, Type t, UnTypedPtr constval) 
-  : Array(nm.c_str(), t) 
+ConstArray *ConstArray::copyAndFilter(bool *filter)
 {
-  _size = sz;
-  setConst(constval);
+	ConstArray *arr = this;
+	ConstArray *newarr;
+	int i;
+	int newsize = 0;
+
+	if (filter == NULL) {
+		newarr = arr->copy();
+	}
+	else {
+
+		for (i = 0; i < arr->_size; i++) {
+			if (filter[i]) {
+				newsize++;
+			}
+		}
+
+		newarr = resize(newsize);
+	}
+	return newarr;
+
 }
+;
 
-void ConstArray::setConst(UnTypedPtr constval) {
-  switch (type) {
-    case INT:
-      int_constant = *(int*) constval; 
-      float_constant = 0;
-      obj_constant = 0;
-      break;
-    case FLOAT:
-      int_constant = 0;
-      float_constant = *(float*) constval; 
-      obj_constant = 0;
-      break;
-    case OBJ:
-      int_constant = 0;
-      float_constant = 0;
-      obj_constant = constval; 
-      break;
-    default:
-      cout << "Unkown type" << endl;
-  }
-}
-
-ConstArray::ConstArray(string nm, int sz, float constval) 
-  : Array(nm.c_str(), FLOAT),float_constant(constval), int_constant(0),
-    obj_constant(0)
-     
-{
-  _size = sz;
-}
-
-ConstArray::ConstArray(string nm, int sz, int constval) 
-  : Array(nm.c_str(), INT) ,float_constant(0.0), int_constant(constval), 
-    obj_constant(0)
-{ 
-  _size = sz;
-}
-
-ConstArray::ConstArray(string nm, int sz, UnTypedPtr constval) 
-  : Array(nm.c_str(), OBJ), float_constant(0.0), int_constant(0), 
-    obj_constant(constval)
-{
-  _size = sz;
-}
-
-void ConstArray::getData(void **&) {
-  cout << "can't get data from a ConstArray." << endl;
-}
-void ConstArray::getData(float *&) {
-  cout << "can't get data from a ConstArray." << endl;
-}
-void ConstArray::getData(int *&) {
-  cout << "can't get data from a ConstArray." << endl;
-}
-
-void ConstArray::copyData(int *, int ) {
-  cout << "can't copy data into a ConstArray." << endl;
-}
-
-void ConstArray::shareData(int *, int ) {
-  cout << "can't share data with a ConstArray." << endl;
-}
-
-void ConstArray::copyData(float *, int) {
-  cout << "can't copy data into a ConstArray." << endl;
-}
-
-void ConstArray::shareData(float *, int ) {
-  cout << "can't share data with a ConstArray." << endl;
-}
-
-void ConstArray::copyData(UnTypedPtr *, int ) {
-  cout << "can't copy data into a ConstArray." << endl;
-}
-
-void ConstArray::shareData(void **, int) {
-  cout << "can't share data with a ConstArray." << endl;
-}
-
-ConstArray *ConstArray::copy() { return resize(_size); }
-
-void ConstArray::setVals(UnTypedPtr , int ) {
-  cout << "can't set Vals of a ConstArray." << endl;
-}
-
-ConstArray *ConstArray::copyAndFilter(bool *filter) {
-  ConstArray *arr = this;
-  ConstArray *newarr;
-  int i;
-  int newsize=0;
-
-  if (filter == NULL) {
-    newarr = arr->copy();
-  } else {
-
-    for (i=0; i<arr->_size; i++) {
-      if (filter[i]) { newsize++; }
-    }
-
-    newarr = resize(newsize);
-  }
-  return newarr;
-
-};
-
-ConstArray *ConstArray::resize(int newsize) {ConstArray *nty;
-  switch (type) {
-    case INT:
-      nty= new ConstArray(this->getName(), newsize, int_constant); 
-    case FLOAT:
-      nty= new ConstArray(this->getName(), newsize, float_constant);
-    case OBJ:
-      nty= new ConstArray(this->getName(), newsize, obj_constant);
-    default:
-      cout << "Unkown type" << endl;
-      exit(1);
-      nty= new ConstArray(this->getName(), newsize, obj_constant);
-  }
-return nty;
-};
-
-long ConstArray::getConst() {long nty=int_constant;
-  switch (type) {
-    case INT:
-      nty= int_constant; 
-      break;
-    case FLOAT:
-      nty= long(float_constant);
-      break;
-    case OBJ:
-      nty= long(obj_constant);
-      break;
-    default:
-      cout << "Unkown type" << endl;
-      exit(1);
-  }
-return nty;
-};
-
-ConstArray *ConstArray::repeat(int n)  { return resize(n*_size); }
-
-ConstArray *ConstArray::expand(int n)  { return resize(n*_size); }
-
-
-void ConstArray::cast(Type t) {
-
-  if (t != INT && t!= FLOAT) {
-    Warning("Can only cast numeric types");
-    return;
-  }
-  Array *arr = this;
-  
-  switch (arr->type) {
-  case INT:
-    if (t==INT) return;
-    int_constant = int(float_constant);
-    float_constant = 0;
-    break;
-  case FLOAT:
-    if (t==FLOAT) return;
-    float_constant =  float(int_constant);
-    int_constant = 0;
-  default:
-    Warning("Can only cast ints and floats");
-  }
-  arr->type = t;
-}
-
-void ConstArray::clear() {
-  _size=0; 
-  deleteName(); 
-  int_constant = 0;
-  float_constant = 0;
-  obj_constant = 0;
-}
-
-UnTypedPtr ConstArray::getValPtr(int i) {
-  if (i<_size && i>= 0) {
-    switch (type) {
-      case INT:
-        return (UnTypedPtr) &int_constant;
-      case FLOAT:
-        return (UnTypedPtr) &float_constant;
-      case OBJ:
-        return (UnTypedPtr) &obj_constant;
-      default:
-        cout << "unkown type" << endl;
-        return NULL;
-    }
-  } else{
-    cout << "index out of range " << endl;
-    return NULL;  
-  }
+ConstArray *ConstArray::resize(int newsize)
+{
+	ConstArray *nty;
+	switch (type) {
+	case INT:
+		nty = new ConstArray(this->getName(), newsize, int_constant);
+	case FLOAT:
+		nty = new ConstArray(this->getName(), newsize, float_constant);
+	case OBJ:
+		nty = new ConstArray(this->getName(), newsize, obj_constant);
+	default:
+		cout << "Unkown type" << endl;
+		exit(1);
+		nty = new ConstArray(this->getName(), newsize, obj_constant);
+	}
+	return nty;
+}
+;
+
+long ConstArray::getConst()
+{
+	long nty = int_constant;
+	switch (type) {
+	case INT:
+		nty = int_constant;
+		break;
+	case FLOAT:
+		nty = long(float_constant);
+		break;
+	case OBJ:
+		nty = long(obj_constant);
+		break;
+	default:
+		cout << "Unkown type" << endl;
+		exit(1);
+	}
+	return nty;
+}
+;
+
+ConstArray *ConstArray::repeat(int n)
+{
+	return resize(n * _size);
+}
+
+ConstArray *ConstArray::expand(int n)
+{
+	return resize(n * _size);
+}
+
+void ConstArray::cast(Type t)
+{
+
+	if (t != INT && t != FLOAT) {
+		Warning("Can only cast numeric types");
+		return;
+	}
+	Array *arr = this;
+
+	switch (arr->type) {
+	case INT:
+		if (t == INT) return;
+		int_constant = int(float_constant);
+		float_constant = 0;
+		break;
+	case FLOAT:
+		if (t == FLOAT) return;
+		float_constant = float(int_constant);
+		int_constant = 0;
+	default:
+		Warning("Can only cast ints and floats");
+	}
+	arr->type = t;
+}
+
+void ConstArray::clear()
+{
+	_size = 0;
+	deleteName();
+	int_constant = 0;
+	float_constant = 0;
+	obj_constant = 0;
+}
+
+UnTypedPtr ConstArray::getValPtr(int i)
+{
+	if (i < _size && i >= 0) {
+		switch (type) {
+		case INT:
+			return (UnTypedPtr) &int_constant;
+		case FLOAT:
+			return (UnTypedPtr) &float_constant;
+		case OBJ:
+			return (UnTypedPtr) &obj_constant;
+		default:
+			cout << "unkown type" << endl;
+			return NULL;
+		}
+	}
+	else {
+		cout << "index out of range " << endl;
+		return NULL;
+	}
 }
 /*
-UnTypedPtr operator[](int i) {
-  return this->getValPtr(i); 
+ UnTypedPtr operator[](int i) {
+ return this->getValPtr(i);
+ }
+ */
+UnTypedPtr ConstArray::getVals()
+{
+	UnTypedPtr vals;
+	switch (this->type) {
+	case INT:
+		vals = (int *) new int[this->_size];
+		for (int i = 0; i < _size; i++) {
+			((int *) vals)[i] = int_constant;
+		}
+		break;
+	case FLOAT:
+		vals = (float *) new float[this->_size];
+		for (int i = 0; i < _size; i++) {
+			((float *) vals)[i] = float_constant;
+		}
+		break;
+	case OBJ:
+		vals = new UnTypedPtr[this->_size];
+		for (int i = 0; i < _size; i++) {
+			((float *) vals)[i] = *(float *) obj_constant;
+		}
+		break;
+	case TUPLE:
+		exit(1);
+	case GRIDFIELD:
+		exit(1);
+	default:
+		vals = (int *) new int[this->_size];
+		exit(1);
+	}
+	return vals;
 }
-*/
-UnTypedPtr ConstArray::getVals() {
-  UnTypedPtr vals;
-  switch (this->type) {
-    case INT:
-      vals = (int *)new int[this->_size];
-      for (int i=0; i<_size; i++) {((int *)vals)[i] = int_constant;}
-      break;
-    case FLOAT:
-      vals = (float *)new float[this->_size];
-      for (int i=0; i<_size; i++) {((float *)vals)[i] = float_constant;}
-      break;
-    case OBJ:
-      vals = new UnTypedPtr[this->_size];
-      for (int i=0; i<_size; i++) {((float *)vals)[i] = *(float *)obj_constant;}
-      break;
-    case TUPLE:
-      exit(1);
-    case GRIDFIELD:
-      exit(1);
-    default:
-      vals = (int *)new int[this->_size];
-      exit(1);      
-  } 
-return vals;}
 
+} // namespace GF
 
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/constarray.h gridfields/clib/src/constarray.h
--- tag/gridfieldsclib-0.7/src/constarray.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/constarray.h	2014-05-16 22:57:00.813391865 +0200
@@ -5,75 +5,88 @@
 #include "object.h"
 #include "array.h"
 
-
 #include <string>
 
-using namespace std;
+//using namespace std;
+
+namespace GF {
 
 class Scheme;
 
-class ConstArray : public Array {
+class ConstArray: public Array {
 
- public:
-  ConstArray(string nm, int size, Type t, UnTypedPtr constant);
-  ConstArray(string nm, int size, float constant);
-  ConstArray(string nm, int size, int constant);
-  ConstArray(string nm, int size, UnTypedPtr constant);
-  //virtual ~ConstArray() {};
-
-  ConstArray *copyAndFilter(bool *filter);
-  ConstArray *copy();
-
-  void copyData(int *data, int s) ;
-  void shareData(int *data, int s);
-
-  void copyData(float *data, int s);
-  void shareData(float *data, int s);
-
-  void copyData(void **data, int s);
-  void shareData(void **data, int s);
-
-  void getData(int *&out);
-  void getData(float *&out);
-  void getData(void **&out);
-
-  void setVals(UnTypedPtr vals, int s);
-  UnTypedPtr getVals();
-  
-  UnTypedPtr getValPtr(int i);
-  inline void next(UnTypedPtr *) { };
-
-  long getConst();
-  void setConst(UnTypedPtr newconst);
-  
-  ConstArray *expand(int n);
-  ConstArray *repeat(int n);
-
-  ConstArray *resize(int newsize);
-  
-  void cast(Type t);
-
-  void print() { 
-    cout << "name: " << this->getName() << endl;
-    cout << "ConstArray: " << this->_size << ", " << type << ", " << this->float_constant << ":" << this->int_constant << ":" << this->obj_constant << endl;
-  };
-
-  void clear();
-
-  void SetConst(float val) { 
-    float_constant = val; 
-    type = FLOAT;
-  };
-  void SetConst(int val) { 
-    int_constant = val; 
-    type = INT;
-  };
-
- private:
-  float float_constant;
-  int int_constant;
-  UnTypedPtr obj_constant;
-  Scheme *_sch;
+public:
+	ConstArray(string nm, int size, Type t, UnTypedPtr constant);
+	ConstArray(string nm, int size, float constant);
+	ConstArray(string nm, int size, int constant);
+	ConstArray(string nm, int size, UnTypedPtr constant);
+	//virtual ~ConstArray() {};
+
+	ConstArray *copyAndFilter(bool *filter);
+	ConstArray *copy();
+
+	void copyData(int *data, int s);
+	void shareData(int *data, int s);
+
+	void copyData(float *data, int s);
+	void shareData(float *data, int s);
+
+	void copyData(void **data, int s);
+	void shareData(void **data, int s);
+
+	void getData(int *&out);
+	void getData(float *&out);
+	void getData(void **&out);
+
+	void setVals(UnTypedPtr vals, int s);
+	UnTypedPtr getVals();
+
+	UnTypedPtr getValPtr(int i);
+	inline void next(UnTypedPtr *)
+	{
+	}
+	;
+
+	long getConst();
+	void setConst(UnTypedPtr newconst);
+
+	ConstArray *expand(int n);
+	ConstArray *repeat(int n);
+
+	ConstArray *resize(int newsize);
+
+	void cast(Type t);
+
+	void print()
+	{
+		cout << "name: " << this->getName() << endl;
+		cout << "ConstArray: " << this->_size << ", " << type << ", " << this->float_constant << ":"
+				<< this->int_constant << ":" << this->obj_constant << endl;
+	}
+	;
+
+	void clear();
+
+	void SetConst(float val)
+	{
+		float_constant = val;
+		type = FLOAT;
+	}
+	;
+	void SetConst(int val)
+	{
+		int_constant = val;
+		type = INT;
+	}
+	;
+
+private:
+	float float_constant;
+	int int_constant;
+	UnTypedPtr obj_constant;
+	// Unused. jhrg 4/4/14 Scheme *_sch;
 };
 
+} // namespace GF
+
 #endif /* _ARRAY_H */
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/counted_ptr.h gridfields/clib/src/counted_ptr.h
--- tag/gridfieldsclib-0.7/src/counted_ptr.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/counted_ptr.h	2014-05-16 22:57:00.813391865 +0200
@@ -11,73 +11,96 @@
 /* For ANSI-challenged compilers, you may want to #define
  * NO_MEMBER_TEMPLATES or explicit */
 
-template <class X> class counted_ptr
-{
+template<class X> class counted_ptr {
 public:
-    typedef X element_type;
+	typedef X element_type;
 
-    explicit counted_ptr(X* p = 0) // allocate a new counter
-        : itsCounter(0) {if (p) itsCounter = new counter(p);}
-    ~counted_ptr()
-        {release();}
-    counted_ptr(const counted_ptr& r) throw()
-    {
-        acquire(r.itsCounter);
-    }
-    counted_ptr& operator=(const counted_ptr& r)
-    {
-        if (this != &r) {
-            release();
-            acquire(r.itsCounter);
-        }
-        return *this;
-    }
+	explicit counted_ptr(X* p = 0) // allocate a new counter
+	:
+			itsCounter(0)
+	{
+		if (p) itsCounter = new counter(p);
+	}
+	~counted_ptr()
+	{
+		release();
+	}
+	counted_ptr(const counted_ptr& r) throw ()
+	{
+		acquire(r.itsCounter);
+	}
+	counted_ptr& operator=(const counted_ptr& r)
+	{
+		if (this != &r) {
+			release();
+			acquire(r.itsCounter);
+		}
+		return *this;
+	}
 
 #ifndef NO_MEMBER_TEMPLATES
-    template <class Y> friend class counted_ptr<Y>;
-    template <class Y> counted_ptr(const counted_ptr<Y>& r) throw()
-        {acquire(r.itsCounter);}
-    template <class Y> counted_ptr& operator=(const counted_ptr<Y>& r)
-    {
-        if (this != &r) {
-            release();
-            acquire(r.itsCounter);
-        }
-        return *this;
-    }
+	template<class Y> friend class counted_ptr<Y> ;
+	template<class Y> counted_ptr(const counted_ptr<Y>& r) throw ()
+	{
+		acquire(r.itsCounter);
+	}
+	template<class Y> counted_ptr& operator=(const counted_ptr<Y>& r)
+	{
+		if (this != &r) {
+			release();
+			acquire(r.itsCounter);
+		}
+		return *this;
+	}
 #endif // NO_MEMBER_TEMPLATES
-
-    X& operator*()  const throw()   {return *itsCounter->ptr;}
-    X* operator->() const throw()   {return itsCounter->ptr;}
-    X* get()        const throw()   {return itsCounter ? itsCounter->ptr : 0;}
-    bool unique()   const throw()
-        {return (itsCounter ? itsCounter->count == 1 : true);}
-    unsigned getcount() const throw() {return itsCounter->count; }
+	X& operator*() const throw ()
+	{
+		return *itsCounter->ptr;
+	}
+	X* operator->() const throw ()
+	{
+		return itsCounter->ptr;
+	}
+	X* get() const throw ()
+	{
+		return itsCounter ? itsCounter->ptr : 0;
+	}
+	bool unique() const throw ()
+	{
+		return (itsCounter ? itsCounter->count == 1 : true);
+	}
+	unsigned getcount() const throw ()
+	{
+		return itsCounter->count;
+	}
 private:
 
-    struct counter {
-        counter(X* p = 0, unsigned c = 1) : ptr(p), count(c) {}
-        X*          ptr;
-        unsigned    count;
-    }* itsCounter;
-
-    void acquire(counter* c) throw()
-    { // increment the count
-        itsCounter = c;
-        if (c) ++c->count;
-        std::cout << c->count << "=" << std::endl;
-    }
-
-    void release()
-    { // decrement the count, delete if it is 0
-        if (itsCounter) {
-            if (--itsCounter->count == 0) {
-                delete itsCounter->ptr;
-                delete itsCounter;
-            }
-            itsCounter = 0;
-        }
-    }
+	struct counter {
+		counter(X* p = 0, unsigned c = 1) :
+				ptr(p), count(c)
+		{
+		}
+		X* ptr;
+		unsigned count;
+	}* itsCounter;
+
+	void acquire(counter* c) throw ()
+	{ // increment the count
+		itsCounter = c;
+		if (c) ++c->count;
+		std::cout << c->count << "=" << std::endl;
+	}
+
+	void release()
+	{ // decrement the count, delete if it is 0
+		if (itsCounter) {
+			if (--itsCounter->count == 0) {
+				delete itsCounter->ptr;
+				delete itsCounter;
+			}
+			itsCounter = 0;
+		}
+	}
 };
 
 #endif // COUNTED_PTR_H
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/cross.cc gridfields/clib/src/cross.cc
--- tag/gridfieldsclib-0.7/src/cross.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/cross.cc	2014-05-16 22:57:00.753391866 +0200
@@ -1,93 +1,103 @@
+#include "config_gridfields.h"
+
 #include "cross.h"
 #include "crossordmap.h"
 #include "timing.h"
 #include "array.h"
 
+namespace GF {
 
-CrossOp::CrossOp(GridFieldOperator *left, GridFieldOperator *right) {
-  this->A = NULL;
-  this->B = NULL;
-  this->LeftOp = left;
-  this->RightOp = right;
+CrossOp::CrossOp(GridFieldOperator *left, GridFieldOperator *right)
+{
+	this->A = NULL;
+	this->B = NULL;
+	this->LeftOp = left;
+	this->RightOp = right;
 }
 
-void CrossOp::Execute() {
-  this->PrepareForExecution();  
-  Result = Cross(this->A,this->B);
+void CrossOp::Execute()
+{
+	this->PrepareForExecution();
+	Result = Cross(this->A, this->B);
 }
 
-GridField *CrossOp::Cross(GridField *Aa, 
-			  GridField *Bb) {
-  
-  Grid *A = Aa->GetGrid();
-  Grid *B = Bb->GetGrid();
-
-  /*
-  assert( (Aa->rank() == A->getdim() && Bb->rank() == B->getdim())
-	  || 
-	  (Aa->rank() == 0 && Bb->rank() == 0) 
-	);
-  */
-
-
-  Grid *G;
-  GridField *Gg;
-  
-  if (A->empty() || B->empty()) {
-    G = new Grid("empty", 0);
-    Gg = new GridField(G);  
-  } else {
-    G = Aa->GetGrid()->Cross(Bb->GetGrid());
-    //  cout << gettime() - start << '\t' << "( Cross(Grid) )" << endl;;
-    Gg = new GridField(G);
-  }
-  
-  crossData(Gg, Aa, 0, Bb, 0);
-  if (Aa->Dim() + Bb->Dim() > 0) {
-    crossData(Gg, Aa, Aa->Dim(), Bb, Bb->Dim());
-  }
-  
-  //cout << gettime() - start << '\t' << "( Cross(Data) )" << endl;;
-
-  CrossOrdMap *ordmap = new CrossOrdMap(A, B, Gg);
-  G->setReferent(ordmap);
-
-  G->unref();
-  
-  return Gg;
+GridField *CrossOp::Cross(GridField *Aa, GridField *Bb)
+{
+
+	Grid *A = Aa->GetGrid();
+	Grid *B = Bb->GetGrid();
+
+	/*
+	 assert( (Aa->rank() == A->getdim() && Bb->rank() == B->getdim())
+	 ||
+	 (Aa->rank() == 0 && Bb->rank() == 0)
+	 );
+	 */
+
+	Grid *G;
+	GridField *Gg;
+
+	if (A->empty() || B->empty()) {
+		G = new Grid("empty", 0);
+		Gg = new GridField(G);
+	}
+	else {
+		G = Aa->GetGrid()->Cross(Bb->GetGrid());
+		//  cout << gettime() - start << '\t' << "( Cross(Grid) )" << endl;;
+		Gg = new GridField(G);
+	}
+
+	crossData(Gg, Aa, 0, Bb, 0);
+	if (Aa->Dim() + Bb->Dim() > 0) {
+		crossData(Gg, Aa, Aa->Dim(), Bb, Bb->Dim());
+	}
+
+	//cout << gettime() - start << '\t' << "( Cross(Data) )" << endl;;
+
+	CrossOrdMap *ordmap = new CrossOrdMap(A, B, Gg);
+	G->setReferent(ordmap);
+
+	G->unref();
+
+	return Gg;
 
 }
 
-void CrossOp::crossData(GridField *Gg, GridField *Aa, Dim_t i, GridField *Bb, Dim_t j) {
-  int Asize = Aa->Card(i);
-  int Bsize = Bb->Card(j);
-
-  Scheme Asch = Aa->GetScheme(i);
-  Scheme Bsch = Bb->GetScheme(j);
-
-  string attr;
-  Array *temparr;
-
-  float start = gettime();(void)start;
-  for (unsigned int a=0; a<Aa->Arity(i); a++) {
-    attr = Asch.getAttribute(a);
-    temparr = Aa->GetAttribute(i, attr)->expand(Bsize);
-    Gg->Bind(i+j, temparr);
-    temparr->unref();
-  }
-
-  for (unsigned int b=0; b<Bb->Arity(j); b++) {    
-    attr = Bsch.getAttribute(b);
-    temparr = Bb->GetAttribute(j, attr)->repeat(Asize);
-    Gg->Bind(i+j, temparr);
-    temparr->unref();
-  }
+void CrossOp::crossData(GridField *Gg, GridField *Aa, Dim_t i, GridField *Bb, Dim_t j)
+{
+	int Asize = Aa->Card(i);
+	int Bsize = Bb->Card(j);
+
+	Scheme Asch = Aa->GetScheme(i);
+	Scheme Bsch = Bb->GetScheme(j);
+
+	string attr;
+	Array *temparr;
+
+	float start = gettime();
+	(void) start;
+	for (unsigned int a = 0; a < Aa->Arity(i); a++) {
+		attr = Asch.getAttribute(a);
+		temparr = Aa->GetAttribute(i, attr)->expand(Bsize);
+		Gg->Bind(i + j, temparr);
+		temparr->unref();
+	}
+
+	for (unsigned int b = 0; b < Bb->Arity(j); b++) {
+		attr = Bsch.getAttribute(b);
+		temparr = Bb->GetAttribute(j, attr)->repeat(Asize);
+		Gg->Bind(i + j, temparr);
+		temparr->unref();
+	}
 
 }
 
-string CrossOp::newName(string Tname, string Sname) {
+string CrossOp::newName(string Tname, string Sname)
+{
 
-  string gname = "a(" + Tname + ", " + Sname + ")";
-  return gname;
+	string gname = "a(" + Tname + ", " + Sname + ")";
+	return gname;
 }
 
+} // namespace GF
+
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/cross.h gridfields/clib/src/cross.h
--- tag/gridfieldsclib-0.7/src/cross.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/cross.h	2014-05-16 22:57:00.816725198 +0200
@@ -6,18 +6,20 @@
 #include "gridfieldoperator.h"
 #include <string>
 
-class CrossOp : public BinaryGridFieldOperator {
- public:
-  CrossOp(GridFieldOperator *A, GridFieldOperator *B);
-  void Execute(); 
-  static GridField *Cross(GridField *T, 
-     			  GridField *S);
+namespace GF {
 
+class CrossOp: public BinaryGridFieldOperator {
+public:
+	CrossOp(GridFieldOperator *A, GridFieldOperator *B);
+	void Execute();
+	static GridField *Cross(GridField *T, GridField *S);
 
- private:
-  static string newName(string Aname, string Bname);
-  static void crossData(GridField *Gg, GridField *Aa, Dim_t i, GridField *Bb, Dim_t j);
+private:
+	static string newName(string Aname, string Bname);
+	static void crossData(GridField *Gg, GridField *Aa, Dim_t i, GridField *Bb, Dim_t j);
 
 };
 
+} // namespace GF
+
 #endif /* CROSS_H */
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/crossnodemap.h gridfields/clib/src/crossnodemap.h
--- tag/gridfieldsclib-0.7/src/crossnodemap.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/crossnodemap.h	2014-05-16 22:57:00.760058532 +0200
@@ -4,42 +4,58 @@
 #include "binarynodemap.h"
 #include "abstractcellarray.h"
 
-class CrossNodeMap : public BinaryNodeMap {
+namespace GF {
 
- public: 
-  CrossNodeMap() {};
-  CrossNodeMap(AbstractCellArray *An, AbstractCellArray *Bn) : BinaryNodeMap() { 
-    Anodes = An;
-    Bnodes = Bn;
-  };
-  inline virtual Node map(Node a, Node b) { 
-    return Anodes->getOrd(a) * Bnodes->getsize() + Bnodes->getOrd(b) ;
-    //return a * Bnodes->getsize() + b ;
-  };
- 
-  
-  void setInputs(AbstractCellArray *An, AbstractCellArray *Bn) {
-    Anodes = An;
-    Bnodes = Bn;
-  }
-
-  Node inv_b(Node o, Node /* a unused jhrg 10/5/11*/) { 
-    Cell *c;
-    int i = o % Bnodes->getsize();
-    c = Bnodes->getCell(i);
-    return c->getnodes()[0];
-  };
-  
-  Node inv_a(Node o, Node /* b */) { 
-    Cell *c;
-    int i = o / Bnodes->getsize();
-    c = Bnodes->getCell(i);
-    return c->getnodes()[0];
-  };
-  
- private:
-  AbstractCellArray *Anodes;
-  AbstractCellArray *Bnodes;
+class CrossNodeMap: public BinaryNodeMap {
+
+public:
+	CrossNodeMap()
+	{
+	}
+	;
+	CrossNodeMap(AbstractCellArray *An, AbstractCellArray *Bn) :
+			BinaryNodeMap()
+	{
+		Anodes = An;
+		Bnodes = Bn;
+	}
+	;
+	inline virtual Node map(Node a, Node b)
+	{
+		return Anodes->getOrd(a) * Bnodes->getsize() + Bnodes->getOrd(b);
+		//return a * Bnodes->getsize() + b ;
+	}
+	;
+
+	void setInputs(AbstractCellArray *An, AbstractCellArray *Bn)
+	{
+		Anodes = An;
+		Bnodes = Bn;
+	}
+
+	Node inv_b(Node o, Node /* a unused jhrg 10/5/11*/)
+	{
+		Cell *c;
+		int i = o % Bnodes->getsize();
+		c = Bnodes->getCell(i);
+		return c->getnodes()[0];
+	}
+	;
+
+	Node inv_a(Node o, Node /* b */)
+	{
+		Cell *c;
+		int i = o / Bnodes->getsize();
+		c = Bnodes->getCell(i);
+		return c->getnodes()[0];
+	}
+	;
+
+private:
+	AbstractCellArray *Anodes;
+	AbstractCellArray *Bnodes;
 };
 
+} // namespace GF
+
 #endif /* _CROSSNODEMAP_H */
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/crossordmap.h gridfields/clib/src/crossordmap.h
--- tag/gridfieldsclib-0.7/src/crossordmap.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/crossordmap.h	2014-05-16 22:57:00.820058531 +0200
@@ -5,74 +5,83 @@
 #include "cellarray.h"
 #include "gridfield.h"
 
-class CrossOrdMap : public OrdMap {
+namespace GF {
 
- public: 
-  CrossOrdMap(Grid *ga, Grid *gb, GridField *gf) { 
-    A = ga;
-    B = gb;
-    G = gf->GetGrid();
-    GF = gf;
-  };
-  virtual int getBaseSize(int d) {
-    int n,m,ord=0;
-    for (int k=0; k<d; k++) {
-      n = A->cellCount(k);
-      m = B->cellCount(d-k);
-      ord += n*m;
-    }
-    return ord;
-  }
-  
-  virtual int getBaseOrd(Cell *c, int d) { 
-    AbstractCellArray *Acells, *Bcells, *Gcells;
-    int n,m,ai,bi,bsize,pos,ord=0;
-    Cell *a, *b;
-
-    Gcells = G->getKCells(d);
-    pos = Gcells->getOrd((const Cell) *c);
-
-    // cout << "\npos, d: " << pos << ", " << d << endl;
-
-    for (int k=0; k<=d; k++) {
-      Acells = A->getKCells( k );
-      Bcells = B->getKCells( d - k );
-      n = Acells->getsize();
-      m = Bcells->getsize();
-      ord += n * m;
-      //      cout << "ord: " << ord << endl;
-      if (pos < ord) {
-        a = Acells->getCell(pos / m);
-        b = Bcells->getCell(pos % m);
-	//cout << "a, b: " << endl;
-	//a->print(1);
-	//b->print(1);
-        ai = A->ordmap->getBaseOrd( a, k );
-        bi = B->ordmap->getBaseOrd( b, d - k );
-	bsize = B->ordmap->getBaseSize( d - k );
-	//	addr = *(float *) GF->getAttributeVal("addr", pos);
-	//	zpos = *(float *) GF->getAttributeVal("zpos", pos);
-	//	bot = *(float *) GF->getAttributeVal("b", pos);
-	//cout << "  addr, zpos, pos: " << addr << ", " << zpos << ", " << pos << endl;
-	//	return (int) addr + (zpos - bot);
-	//	cout << "addr: " << addr << endl;
-	//	getchar();
-        return ai*bsize + bi;
-	
-      }
-    }
+class CrossOrdMap: public OrdMap {
 
-  Fatal("Base Ordinal not found for position %i", pos);
-return -1;
-};
-  
- private:
-  // G = A x B
-  Grid *A;
-  Grid *B;
-  Grid *G;
-  GridField *GF;
+public:
+	CrossOrdMap(Grid *ga, Grid *gb, GridField *gf)
+	{
+		A = ga;
+		B = gb;
+		G = gf->GetGrid();
+		GF = gf;
+	}
+	;
+	virtual int getBaseSize(int d)
+	{
+		int n, m, ord = 0;
+		for (int k = 0; k < d; k++) {
+			n = A->cellCount(k);
+			m = B->cellCount(d - k);
+			ord += n * m;
+		}
+		return ord;
+	}
+
+	virtual int getBaseOrd(Cell *c, int d)
+	{
+		AbstractCellArray *Acells, *Bcells, *Gcells;
+		int n, m, ai, bi, bsize, pos, ord = 0;
+		Cell *a, *b;
+
+		Gcells = G->getKCells(d);
+		pos = Gcells->getOrd((const Cell) *c);
+
+		// cout << "\npos, d: " << pos << ", " << d << endl;
+
+		for (int k = 0; k <= d; k++) {
+			Acells = A->getKCells(k);
+			Bcells = B->getKCells(d - k);
+			n = Acells->getsize();
+			m = Bcells->getsize();
+			ord += n * m;
+			//      cout << "ord: " << ord << endl;
+			if (pos < ord) {
+				a = Acells->getCell(pos / m);
+				b = Bcells->getCell(pos % m);
+				//cout << "a, b: " << endl;
+				//a->print(1);
+				//b->print(1);
+				ai = A->ordmap->getBaseOrd(a, k);
+				bi = B->ordmap->getBaseOrd(b, d - k);
+				bsize = B->ordmap->getBaseSize(d - k);
+				//	addr = *(float *) GF->getAttributeVal("addr", pos);
+				//	zpos = *(float *) GF->getAttributeVal("zpos", pos);
+				//	bot = *(float *) GF->getAttributeVal("b", pos);
+				//cout << "  addr, zpos, pos: " << addr << ", " << zpos << ", " << pos << endl;
+				//	return (int) addr + (zpos - bot);
+				//	cout << "addr: " << addr << endl;
+				//	getchar();
+				return ai * bsize + bi;
+
+			}
+		}
+
+		Fatal("Base Ordinal not found for position %i", pos);
+		return -1;
+	}
+	;
+
+private:
+	// G = A x B
+	Grid *A;
+	Grid *B;
+	Grid *G;
+	GridField *GF;
 
 };
 
+} // namespace GF
+
 #endif /* _CROSSORDMAP_H */
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/datadump.cc gridfields/clib/src/datadump.cc
--- tag/gridfieldsclib-0.7/src/datadump.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/datadump.cc	2014-05-16 22:57:00.790058532 +0200
@@ -1,10 +1,14 @@
+#include "config_gridfields.h"
+
 #include "gridfield.h"
-extern "C" {
-#include "stdio.h"
+#include <stdio.h>
+//extern "C" {
+//#include "stdio.h"
 #include "elio.h"
-}
+//}
 #include "expr.h"
 #include "timing.h"
+
 #include <iostream>
 #include <iomanip>
 #include <fstream>
@@ -14,33 +18,39 @@
 
 using namespace std;
 
-DataDumpOp::DataDumpOp(Dim_t k, string fn, long off, GridFieldOperator *op) 
-         : UnaryGridFieldOperator(op), _k(k), filename(fn), offset(off) 
-{ }
+namespace GF {
 
+DataDumpOp::DataDumpOp(Dim_t k, string fn, long off, GridFieldOperator *op) :
+		UnaryGridFieldOperator(op), _k(k), filename(fn), offset(off)
+{
+}
 
-void DataDumpOp::Execute() {
-  this->PrepareForExecution();
-  this->DataDump(this->GF, this->_k, this->filename, this->offset);
-  this->Result = this->GF;
+void DataDumpOp::Execute()
+{
+	this->PrepareForExecution();
+	this->DataDump(this->GF, this->_k, this->filename, this->offset);
+	this->Result = this->GF;
 }
 
+void DataDumpOp::DataDump(GridField *GF, Dim_t k, string filename, long)
+{
 
-void DataDumpOp::DataDump(GridField *GF, Dim_t k, string filename, long ) {
+	ofstream f(filename.c_str(), ios::binary | ios::out | ios::app);
 
-   ofstream f(filename.c_str(), ios::binary | ios::out | ios::app);
-    
-   int arity = GF->Arity(k);
-   f.write((char *) &arity, sizeof(int));
-   
-   ArrayWriter aw(&f);
-   Array *a;
-   const Scheme &sch = GF->GetScheme(k);
-   for (int i=0; i<arity; ++i) {
-     a = GF->GetAttribute(k, sch.getAttribute(i));
-     //writeName(string(a->name), f);
-     //f.write((char *) &a->type, sizeof(Type));
-     //f.write((char *) &a->size, sizeof(int));
-     aw.Write(GF->GetDataset(k), string(a->getName()));
-   }
+	int arity = GF->Arity(k);
+	f.write((char *) &arity, sizeof(int));
+
+	ArrayWriter aw(&f);
+	Array *a;
+	const Scheme &sch = GF->GetScheme(k);
+	for (int i = 0; i < arity; ++i) {
+		a = GF->GetAttribute(k, sch.getAttribute(i));
+		//writeName(string(a->name), f);
+		//f.write((char *) &a->type, sizeof(Type));
+		//f.write((char *) &a->size, sizeof(int));
+		aw.Write(GF->GetDataset(k), string(a->getName()));
+	}
 }
+
+} // namespace GF
+
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/datadump.h gridfields/clib/src/datadump.h
--- tag/gridfieldsclib-0.7/src/datadump.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/datadump.h	2014-05-16 22:57:00.790058532 +0200
@@ -4,19 +4,23 @@
 #include "gridfieldoperator.h"
 #include <iostream>
 
-class DataDumpOp : public UnaryGridFieldOperator {
+namespace GF {
+
+class DataDumpOp: public UnaryGridFieldOperator {
 public:
-  DataDumpOp(Dim_t k, string fn, long off, GridFieldOperator *Op);
-  
-  void Execute();
-  static void DataDump(GridField *GF, Dim_t k, string filename, long offset);
+	DataDumpOp(Dim_t k, string fn, long off, GridFieldOperator *Op);
+
+	void Execute();
+	static void DataDump(GridField *GF, Dim_t k, string filename, long offset);
 
 private:
-  Dim_t _k;
-  string filename;
-  int offset;
+	Dim_t _k;
+	string filename;
+	int offset;
 
-  static void writeGridField(GridField *GF, ofstream &f);
+	static void writeGridField(GridField *GF, ofstream &f);
 };
 
+} // namespace GF
+
 #endif
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/dataset.cc gridfields/clib/src/dataset.cc
--- tag/gridfieldsclib-0.7/src/dataset.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/dataset.cc	2014-05-16 22:57:00.810058531 +0200
@@ -1,3 +1,5 @@
+#include "config_gridfields.h"
+
 #include "dataset.h"
 #include "array.h"
 #include "util.h"
@@ -5,470 +7,530 @@
 #include <sstream>
 #include <iostream>
 
+namespace GF {
 
-
-Dataset::Dataset(const Scheme &s, size_t N) : _size(N) {
-  if (s.size() > 0) {
-    Array *arr = new Array(s.getAttribute(0), s.getType(0), N);
-    this->AddAttribute(arr);
-    this->CoerceScheme(s);
-  }
-}
-
-Dataset::~Dataset() {
-  for (int i=0; i<this->Arity(); i++) {
-    attributes[i]->unref();
-  }
-}
-
-void Dataset::RemoveAttribute(Array *arr) {
-  vector<Array *>::iterator p;
-  for (p=this->attributes.begin(); p!=this->attributes.end(); p++) {
-    if (*p == arr) {
-      (*p)->unref();
-      this->attributes.erase(p);
-      return;
-    }
-  }
-}
-
-void Dataset::recordOrdinals(string ordname) {
-  Array *arr = new Array(ordname, INT, this->Size());
-  int *ords;
-  arr->getData(ords);
-  idx n=this->Size();
-  for (unsigned int i=0; i<n; i++) ords[i] = i;
-  this->AddAttribute(arr);
-}
-
-void Dataset::Clear() {
-  vector<Array *>::iterator p;
-  for (p=this->attributes.begin(); p!=this->attributes.end(); p++) {
-    (*p)->unref();
-  }
-  this->attributes.clear();
-}
-
-Dataset::IntIterator Dataset::BeginInt(const string &attr) {IntIterator nty;
-  // iterator starting at the first element of the attribute.
-  Array *a = this->GetAttribute(attr);
-  int *ii;
-  
-  if (a->type != INT) {
-    Fatal("Type mismatch: IntIterator requested for attribute of type %s.", typeformat(a->type));
-    exit(1);
-    ii = (int *) a->getValPtr(0);
-    nty= IntIterator(ii);
-  } else {
-    ii = (int *) a->getValPtr(0);
-    nty= IntIterator(ii);
-  }
-return nty;
-}
-
-Dataset::IntIterator Dataset::EndInt(const string &attr) {IntIterator nty;
-  // iterator just past the end of the attribute.
-  Array *a = this->GetAttribute(attr);
-  int *ii;
-  
-  if (a->type != INT) {
-    Fatal("Type mismatch: IntIterator requested for attribute of type %s.", typeformat(a->type));
-    exit(1);
-    ii = (int *) a->getValPtr(0);
-    nty= IntIterator(ii + a->size());
-  } else {
-    ii = (int *) a->getValPtr(0);
-    nty= IntIterator(ii + a->size());
-  }
-return nty;
-}
-
-Dataset::FloatIterator Dataset::BeginFloat(const string &attr) {FloatIterator nty;
-  Array *a = this->GetAttribute(attr);
-  float *fi;
-
-  if (a->type != FLOAT) {
-    Fatal("Type mismatch: FloatIterator requested for attribute of type %s.", typeformat(a->type));
-    exit(1);
-    fi = (float *) a->getValPtr(0);
-    nty= FloatIterator(fi);
-  } else {
-    fi = (float *) a->getValPtr(0);
-    nty= FloatIterator(fi);
-  }
-return nty;
-}
-
-Dataset::FloatIterator Dataset::EndFloat(const string &attr) { FloatIterator nty;
-  // iterator just past the end of the attribute.
-  Array *a = this->GetAttribute(attr);
-  float *fi;
-
-  if (a->type != FLOAT) {
-    Fatal("Type mismatch: FloatIterator requested for attribute of type %s.", typeformat(a->type));
-    exit(1);
-    fi = (float *) a->getValPtr(0);
-    nty= FloatIterator(fi + a->size());
-  } else {
-    fi = (float *) a->getValPtr(0);
-    nty= FloatIterator(fi + a->size());
-  }
-return nty;
-} 
-
-UnTypedPtr Dataset::GetAttributeVal(const string &attr, idx i) const { 
-  return this->GetAttribute(attr)->getValPtr(i);
-};
-
-void Dataset::AddAttribute(Array *arr) {
-
-  if (!arr) {
-    Fatal("AddAttribute: array is NULL");
-  }
-
-  if (arr->size() != (signed)this->Size() && !this->IsEmpty()) {
-    Fatal("Cardinality of array (%i) does not match cardinality of dataset (%i)", arr->size(), this->Size());
-  }
-  
-  if (IsAttribute(string(arr->getName()))) {
-    Array *a = this->GetAttribute(arr->getName());
-    if (a != arr) {
-      Fatal("Dataset already contains a different array named %s", arr->getName().c_str());
-    } else {
-      // we already have this array as an attribute
-      return;
-    }
-  }
-  
-  attributes.push_back(arr);
-  //increment ref count
-  arr->ref();
-}
-
-void Dataset::print(int ) const { PrintTo(cout, 5); };
- 
-void Dataset::Zip(const Dataset &d) {
-  vector<Array *>::const_iterator p;
-  if (this->IsEmpty()) { this->_size = d.Size(); }
-  for (p=d.attributes.begin(); p!=d.attributes.end(); p++) {
-    this->AddAttribute((*p));
-  }
-}
-
-UnTypedPtr Dataset::GetVoidPointer(const string &attr) const {
-  return GetAttribute(attr)->getVals();
-}
-
-Array *Dataset::GetAttribute(const string &attr) const {
-  int i;
-  if ((i = IsAttribute(attr))) {
-    return attributes[i-1];
-  } else {
-    Fatal("%s is not an attribute of this gridfield", attr.c_str());
-    return NULL;
-  }
-}
-
-void Dataset::CoerceScheme(Scheme sch, unsigned int sz) {
-  // Coerces the dataset to subsume the input scheme
-  // new attributes are generated with default values
-  // existing attributes are reordered to match the input scheme
-  vector<Array *> copy;
-   
-  // put the input attributes in front
-  unsigned int n = sz == 0 ? this->Size() : sz;
-  for (unsigned int i=0; i<sch.size(); i++) {
-    string a = sch.getAttribute(i);
-    Type t = sch.getType(i);
-    if (this->IsAttribute(a)) {
-      Array *keeper = this->GetAttribute(a);
-      copy.push_back(keeper);
-      keeper->ref();
-      this->RemoveAttribute(keeper);
-    } else {
-      copy.push_back(new Array(a, t, n));
-    }
-  }
- 
-  // add the remainder to the end
-  vector<Array *>::iterator p;
-  for (p=this->attributes.begin(); p!=this->attributes.end(); p++) {
-    copy.push_back(*p);
-    (*p)->ref();
-  }                  
-  this->Clear();
-  this->attributes.swap(copy);
-}
-
-void Dataset::FilterBy(const string &mask, Dataset &Result) {
-  if (!IsAttribute(mask)) {
-    Fatal("Attempt to filter with mask '%s', but '%s' is not an attribute.", mask.c_str(), mask.c_str());
-  }
-
-  Array *m = this->GetAttribute(mask);
-  m->cast(INT);
-  int *filter;
-  m->getData(filter);
-  
-  vector<Array *>::iterator ai;
-  vector<Array *>::iterator stop = attributes.end();
-  
-  for (ai=attributes.begin(); ai!=stop; ai++) {
-    Array *newarr = (*ai)->copyAndFilter((bool *) filter);
-    Result.AddAttribute(newarr);
-  }
-}
-
-void Dataset::Apply(const string &unparsedExpr) {
-  Dataset *Gg = this;
-
-  SpecializedTupleFunction tf;
-
-  tf.Parse(unparsedExpr);
-
-  Scheme *func_insch = tf.InputType();
-  Scheme *func_outsch = tf.ReturnType();
-
-  Scheme real_insch = Gg->GetScheme();
-
-  // check that all needed attributes appear in the gridfield
-  if (!real_insch.Subsumes(*func_insch)) {
-    stringstream ss;
-    ss << "'"<< unparsedExpr << "'" << endl;
-    ss << "required type: ";
-    func_insch->PrintTo(ss);
-    ss << "actual type: ";
-    real_insch.PrintTo(ss);
-    Fatal("Type Error in Apply Operator: %s", ss.str().c_str());
-  }
-
-  //allocate new attributes as necessary to match required output type
-  // and change types if necessary
-  
-  Gg->CoerceScheme(*func_outsch);
-  Scheme real_outsch = Gg->GetScheme();
-
-  tf.SpecializeFor(real_outsch);
-
-  // get a tuple of the new coerced scheme
-  Tuple tup(&real_outsch);
-
-  int n = Gg->Size();
-
-  float bt=0;
-  float et=0;
-  float t; (void)n;(void)bt;(void)et;(void)t;
-  Gg->BindTuple(0, tup);
-
-  vector<pair<Array*, UnTypedPtr*> > fast_loop;
-  Array *arr;
-  string attr;
-  for (int i=0; i<tup.size(); i++) {
-    attr = tup.getAttribute(i);
-    arr = Gg->GetAttribute(attr);
-    fast_loop.push_back(make_pair(arr, &tup.tupledata[i]));
-  }
-
-  for (unsigned int i=0; i<Gg->Size(); i++) {
-    vector<pair<Array*, UnTypedPtr*> >::iterator p;
-    tf.Eval(tup, tup);
-    for (p=fast_loop.begin(); p!=fast_loop.end(); p++) {
-      p->first->next(p->second);
-    }
-  } 
-  for (int i=0; i<tup.size(); i++) {
-    attr = tup.getAttribute(i);
-    arr = Gg->GetAttribute(attr);
-    //arr->UnSafeCast(FLOAT);
-  }
-}
-
-int Dataset::IsAttribute(const string &attr) const {
-  int j=1;
-  vector<Array *>::const_iterator p;
-  for (p=this->attributes.begin(); p!=this->attributes.end(); p++) {
-    if (attr == (*p)->getName()) {
-      return j;
-    }
-    j++;
-  }
-  return 0;
-}
-
-int Dataset::Arity() const { return this->attributes.size(); };
-
-Scheme Dataset::GetScheme() const {
-  Scheme s;
-  string n;
-  vector<Array *>::const_iterator p;
-  for (p=this->attributes.begin(); p!=this->attributes.end(); p++) {
-    n.assign((*p)->getName());
-    s.addAttribute(n, (*p)->type);   
-  }
-  return s;
-}
-
-void Dataset::FastBindTuple(unsigned int idx, Tuple &t) const {
-  /* random access to all attributes of a dataset
-     assumes the scheme of the tuple matches the 
-     scheme of the dataset
-  */
-  Array *arr;(void)arr;
-  UnTypedPtr ptr;(void)ptr;
-  assert(idx < this->Size());
-  for (unsigned int i=0; (unsigned)i<(unsigned)t.size(); i++) {
-    //this->attributes[i]->print();
-    //cout << this->attributes[i]->getValPtr(idx) << endl;
-    t.set(i, this->attributes[i]->getValPtr(idx));
-  }
-}
-
-
-void Dataset::BindTuple(unsigned int idx, Tuple &t) const {
-  /* random access to all attributes of a dataset
-  */
-/* if the tuple has attributes that do not appear in the gridfield,
- * they will be NULL (as in NULL pointers, not pointers to NULL)
- */
-  string arr;
-  UnTypedPtr ptr;(void)ptr;
-
-  //cout << idx << ", " << this->Size() << endl;
-  assert(idx < this->Size());
-  for (unsigned int i=0; (unsigned)i<(unsigned)t.size(); i++) {
-    if (int j = this->IsAttribute(t.getAttribute(i))) {
-      Array *arr = this->attributes[j-1];
-      t.set(i, arr->getValPtr(idx));
-    } else {
-      stringstream ss;
-      this->GetScheme().PrintTo(ss);
-      Fatal("BindTuple: attribute %s not in scheme %s", t.getAttribute(i).c_str(), ss.str().c_str());
-    }
-  }
-}
-
-size_t Dataset::Size() const {
-  return _size;
-  if (this->IsEmpty()) {
-    return 0;
-  } else {
-    return attributes[0]->size();
-  }
-}
-
-void Dataset::PrintTo(ostream &os, int indent, int limit) const { 
-  unsigned int i;
-  Scheme s = this->GetScheme();
-  Tuple t(&s);
-  os << tab(indent) << "dataset: " << endl;
-  if (this->IsEmpty()) return;
-  for (i=0; i<this->Size(); i++) {
-    this->BindTuple(i, t);
-    t.PrintTo(os, indent+4);
-    if (limit>0 && (signed)i>=limit) break;
-  }
-}
-
-void Dataset::nearest(const string &attr, UnTypedPtr p, vector<idx> &out) {
-  typedef int valtype;
-  Array *arr = this->GetAttribute(attr);
-  valtype near, v;
-  valtype pf = *(valtype *)p;
-  near = *(valtype *)arr->getValPtr(0);
-  int nearest=0;
-
-  for (int i=1; i<arr->size(); i++) {
-    v = *(valtype *)arr->getValPtr(i);
-    if (abs(pf-v) <= abs(pf-near)) {
-      nearest = i;
-      near = v;
-    }
-  }
-  out.push_back(nearest);
-}
-
-void Dataset::lookupFloat(const string &attr, float p, vector<idx> &out) {
-
-  Array *arr = this->GetAttribute(attr);
-  int x = int(p);
-  switch (arr->type) {
-    case FLOAT: 
-  
-      for (int i=0; i<arr->size(); i++) {
-       //cout << p << ", " <<  *(float*)arr->getValPtr(i) << endl;
-       if (p == *(float*)arr->getValPtr(i)) {
-         out.push_back(i);
-        }
-      }
-      break;
-    case INT:
-      
-      for (int i=0; i<arr->size(); i++) {
-       //cout << x << ", " <<  *(int*)arr->getValPtr(i) << endl;
-       if (x == *(int*)arr->getValPtr(i)) {
-         out.push_back(i);
-        }
-      }
-      break;
-    case OBJ:
-      Fatal("Array is not of type float.");
-      exit(1);
-      break;
-    case TUPLE:
-      Fatal("Array is not of type float.");
-      exit(1);
-      break;
-    case GRIDFIELD:
-      Fatal("Array is not of type float.");
-      exit(1);
-      break;
-  }
-}
-
-void Dataset::lookupInt(const string &attr, int p, vector<idx> &out) {
-
-  Array *arr = this->GetAttribute(attr);
-  float x = float(p);
-  switch (arr->type) {
-    case FLOAT: 
-  
-      for (int i=0; i<arr->size(); i++) {
-       //cout << x << ", " <<  *(float*)arr->getValPtr(i) << endl;
-       if (x == *(float*)arr->getValPtr(i)) {
-         out.push_back(i);
-        }
-      }
-      break;
-    case INT:
-      for (int i=0; i<arr->size(); i++) {
-       //cout << p << ", " <<  *(int*)arr->getValPtr(i) << endl;
-       if (p == *(int*)arr->getValPtr(i)) {
-         out.push_back(i);
-        }
-      }
-      break;
-    case OBJ:
-      for (int i=0; i<arr->size(); i++) {
-       if (p == *(int*)arr->getValPtr(i)) {
-         out.push_back(i);
-        }
-      }
-    case TUPLE:
-      exit(1);
-    case GRIDFIELD:
-      exit(1);
-  }
+Dataset::Dataset(const Scheme &s, size_t N) :
+		_size(N)
+{
+	if (s.size() > 0) {
+		Array *arr = new Array(s.getAttribute(0), s.getType(0), N);
+		this->AddAttribute(arr);
+		this->CoerceScheme(s);
+	}
+}
+
+Dataset::~Dataset()
+{
+	for (int i = 0; i < this->Arity(); i++) {
+		attributes[i]->unref();
+	}
+}
+
+void Dataset::RemoveAttribute(Array *arr)
+{
+	vector<Array *>::iterator p;
+	for (p = this->attributes.begin(); p != this->attributes.end(); p++) {
+		if (*p == arr) {
+			(*p)->unref();
+			this->attributes.erase(p);
+			return;
+		}
+	}
+}
+
+void Dataset::recordOrdinals(string ordname)
+{
+	Array *arr = new Array(ordname, INT, this->Size());
+	int *ords;
+	arr->getData(ords);
+	idx n = this->Size();
+	for (unsigned int i = 0; i < n; i++)
+		ords[i] = i;
+	this->AddAttribute(arr);
+}
+
+void Dataset::Clear()
+{
+	vector<Array *>::iterator p;
+	for (p = this->attributes.begin(); p != this->attributes.end(); p++) {
+		(*p)->unref();
+	}
+	this->attributes.clear();
+}
+
+Dataset::IntIterator Dataset::BeginInt(const string &attr)
+{
+	IntIterator nty;
+	// iterator starting at the first element of the attribute.
+	Array *a = this->GetAttribute(attr);
+	int *ii;
+
+	if (a->type != INT) {
+		Fatal("Type mismatch: IntIterator requested for attribute of type %s.", typeformat(a->type));
+		exit(1);
+		ii = (int *) a->getValPtr(0);
+		nty = IntIterator(ii);
+	}
+	else {
+		ii = (int *) a->getValPtr(0);
+		nty = IntIterator(ii);
+	}
+	return nty;
+}
+
+Dataset::IntIterator Dataset::EndInt(const string &attr)
+{
+	IntIterator nty;
+	// iterator just past the end of the attribute.
+	Array *a = this->GetAttribute(attr);
+	int *ii;
+
+	if (a->type != INT) {
+		Fatal("Type mismatch: IntIterator requested for attribute of type %s.", typeformat(a->type));
+		exit(1);
+		ii = (int *) a->getValPtr(0);
+		nty = IntIterator(ii + a->size());
+	}
+	else {
+		ii = (int *) a->getValPtr(0);
+		nty = IntIterator(ii + a->size());
+	}
+	return nty;
+}
+
+Dataset::FloatIterator Dataset::BeginFloat(const string &attr)
+{
+	FloatIterator nty;
+	Array *a = this->GetAttribute(attr);
+	float *fi;
+
+	if (a->type != FLOAT) {
+		Fatal("Type mismatch: FloatIterator requested for attribute of type %s.", typeformat(a->type));
+		exit(1);
+		fi = (float *) a->getValPtr(0);
+		nty = FloatIterator(fi);
+	}
+	else {
+		fi = (float *) a->getValPtr(0);
+		nty = FloatIterator(fi);
+	}
+	return nty;
+}
+
+Dataset::FloatIterator Dataset::EndFloat(const string &attr)
+{
+	FloatIterator nty;
+	// iterator just past the end of the attribute.
+	Array *a = this->GetAttribute(attr);
+	float *fi;
+
+	if (a->type != FLOAT) {
+		Fatal("Type mismatch: FloatIterator requested for attribute of type %s.", typeformat(a->type));
+		exit(1);
+		fi = (float *) a->getValPtr(0);
+		nty = FloatIterator(fi + a->size());
+	}
+	else {
+		fi = (float *) a->getValPtr(0);
+		nty = FloatIterator(fi + a->size());
+	}
+	return nty;
+}
+
+UnTypedPtr Dataset::GetAttributeVal(const string &attr, idx i) const
+{
+	return this->GetAttribute(attr)->getValPtr(i);
+}
+;
+
+void Dataset::AddAttribute(Array *arr)
+{
+
+	if (!arr) {
+		Fatal("AddAttribute: array is NULL");
+	}
+
+	if (arr->size() != (signed) this->Size() && !this->IsEmpty()) {
+		Fatal("Cardinality of array (%i) does not match cardinality of dataset (%i)", arr->size(), this->Size());
+	}
+
+	if (IsAttribute(string(arr->getName()))) {
+		Array *a = this->GetAttribute(arr->getName());
+		if (a != arr) {
+			Fatal("Dataset already contains a different array named %s", arr->getName().c_str());
+		}
+		else {
+			// we already have this array as an attribute
+			return;
+		}
+	}
+
+	attributes.push_back(arr);
+	//increment ref count
+	arr->ref();
+}
+
+void Dataset::print(int) const
+{
+	PrintTo(cout, 5);
+}
+;
+
+void Dataset::Zip(const Dataset &d)
+{
+	vector<Array *>::const_iterator p;
+	if (this->IsEmpty()) {
+		this->_size = d.Size();
+	}
+	for (p = d.attributes.begin(); p != d.attributes.end(); p++) {
+		this->AddAttribute((*p));
+	}
+}
+
+UnTypedPtr Dataset::GetVoidPointer(const string &attr) const
+{
+	return GetAttribute(attr)->getVals();
+}
+
+Array *Dataset::GetAttribute(const string &attr) const
+{
+	int i;
+	if ((i = IsAttribute(attr))) {
+		return attributes[i - 1];
+	}
+	else {
+		Fatal("%s is not an attribute of this gridfield", attr.c_str());
+		return NULL;
+	}
+}
+
+void Dataset::CoerceScheme(Scheme sch, unsigned int sz)
+{
+	// Coerces the dataset to subsume the input scheme
+	// new attributes are generated with default values
+	// existing attributes are reordered to match the input scheme
+	vector<Array *> copy;
+
+	// put the input attributes in front
+	unsigned int n = sz == 0 ? this->Size() : sz;
+	for (unsigned int i = 0; i < sch.size(); i++) {
+		string a = sch.getAttribute(i);
+		Type t = sch.getType(i);
+		if (this->IsAttribute(a)) {
+			Array *keeper = this->GetAttribute(a);
+			copy.push_back(keeper);
+			keeper->ref();
+			this->RemoveAttribute(keeper);
+		}
+		else {
+			copy.push_back(new Array(a, t, n));
+		}
+	}
+
+	// add the remainder to the end
+	vector<Array *>::iterator p;
+	for (p = this->attributes.begin(); p != this->attributes.end(); p++) {
+		copy.push_back(*p);
+		(*p)->ref();
+	}
+	this->Clear();
+	this->attributes.swap(copy);
+}
+
+void Dataset::FilterBy(const string &mask, Dataset &Result)
+{
+	if (!IsAttribute(mask)) {
+		Fatal("Attempt to filter with mask '%s', but '%s' is not an attribute.", mask.c_str(), mask.c_str());
+	}
+
+	Array *m = this->GetAttribute(mask);
+	m->cast(INT);
+	int *filter;
+	m->getData(filter);
+
+	vector<Array *>::iterator ai;
+	vector<Array *>::iterator stop = attributes.end();
+
+	for (ai = attributes.begin(); ai != stop; ai++) {
+		Array *newarr = (*ai)->copyAndFilter((bool *) filter);
+		Result.AddAttribute(newarr);
+	}
+}
+
+void Dataset::Apply(const string &unparsedExpr)
+{
+	Dataset *Gg = this;
+
+	SpecializedTupleFunction tf;
+
+	tf.Parse(unparsedExpr);
+
+	Scheme *func_insch = tf.InputType();
+	Scheme *func_outsch = tf.ReturnType();
+
+	Scheme real_insch = Gg->GetScheme();
+
+	// check that all needed attributes appear in the gridfield
+	if (!real_insch.Subsumes(*func_insch)) {
+		stringstream ss;
+		ss << "'" << unparsedExpr << "'" << endl;
+		ss << "required type: ";
+		func_insch->PrintTo(ss);
+		ss << "actual type: ";
+		real_insch.PrintTo(ss);
+		Fatal("Type Error in Apply Operator: %s", ss.str().c_str());
+	}
+
+	//allocate new attributes as necessary to match required output type
+	// and change types if necessary
+
+	Gg->CoerceScheme(*func_outsch);
+	Scheme real_outsch = Gg->GetScheme();
+
+	tf.SpecializeFor(real_outsch);
+
+	// get a tuple of the new coerced scheme
+	Tuple tup(&real_outsch);
+
+	int n = Gg->Size();
+
+	float bt = 0;
+	float et = 0;
+	float t;
+	(void) n;
+	(void) bt;
+	(void) et;
+	(void) t;
+	Gg->BindTuple(0, tup);
+
+	vector<pair<Array*, UnTypedPtr*> > fast_loop;
+	Array *arr;
+	string attr;
+	for (int i = 0; i < tup.size(); i++) {
+		attr = tup.getAttribute(i);
+		arr = Gg->GetAttribute(attr);
+		fast_loop.push_back(make_pair(arr, &tup.tupledata[i]));
+	}
+
+	for (unsigned int i = 0; i < Gg->Size(); i++) {
+		vector<pair<Array*, UnTypedPtr*> >::iterator p;
+		tf.Eval(tup, tup);
+		for (p = fast_loop.begin(); p != fast_loop.end(); p++) {
+			p->first->next(p->second);
+		}
+	}
+	for (int i = 0; i < tup.size(); i++) {
+		attr = tup.getAttribute(i);
+		arr = Gg->GetAttribute(attr);
+		//arr->UnSafeCast(FLOAT);
+	}
+}
+
+int Dataset::IsAttribute(const string &attr) const
+{
+	int j = 1;
+	vector<Array *>::const_iterator p;
+	for (p = this->attributes.begin(); p != this->attributes.end(); p++) {
+		if (attr == (*p)->getName()) {
+			return j;
+		}
+		j++;
+	}
+	return 0;
+}
+
+int Dataset::Arity() const
+{
+	return this->attributes.size();
+}
+;
+
+Scheme Dataset::GetScheme() const
+{
+	Scheme s;
+	string n;
+	vector<Array *>::const_iterator p;
+	for (p = this->attributes.begin(); p != this->attributes.end(); p++) {
+		n.assign((*p)->getName());
+		s.addAttribute(n, (*p)->type);
+	}
+	return s;
+}
+
+void Dataset::FastBindTuple(unsigned int idx, Tuple &t) const
+{
+	/* random access to all attributes of a dataset
+	 assumes the scheme of the tuple matches the
+	 scheme of the dataset
+	 */
+	Array *arr;
+	(void) arr;
+	UnTypedPtr ptr;
+	(void) ptr;
+	assert(idx < this->Size());
+	for (unsigned int i = 0; (unsigned) i < (unsigned) t.size(); i++) {
+		//this->attributes[i]->print();
+		//cout << this->attributes[i]->getValPtr(idx) << endl;
+		t.set(i, this->attributes[i]->getValPtr(idx));
+	}
+}
+
+void Dataset::BindTuple(unsigned int idx, Tuple &t) const
+{
+	/* random access to all attributes of a dataset
+	 */
+	/* if the tuple has attributes that do not appear in the gridfield,
+	 * they will be NULL (as in NULL pointers, not pointers to NULL)
+	 */
+	string arr;
+	UnTypedPtr ptr;
+	(void) ptr;
+
+	//cout << idx << ", " << this->Size() << endl;
+	assert(idx < this->Size());
+	for (unsigned int i = 0; (unsigned) i < (unsigned) t.size(); i++) {
+		if (int j = this->IsAttribute(t.getAttribute(i))) {
+			Array *arr = this->attributes[j - 1];
+			t.set(i, arr->getValPtr(idx));
+		}
+		else {
+			stringstream ss;
+			this->GetScheme().PrintTo(ss);
+			Fatal("BindTuple: attribute %s not in scheme %s", t.getAttribute(i).c_str(), ss.str().c_str());
+		}
+	}
+}
+
+size_t Dataset::Size() const
+{
+	return _size;
+	if (this->IsEmpty()) {
+		return 0;
+	}
+	else {
+		return attributes[0]->size();
+	}
+}
+
+void Dataset::PrintTo(ostream &os, int indent, int limit) const
+{
+	unsigned int i;
+	Scheme s = this->GetScheme();
+	Tuple t(&s);
+	os << tab(indent) << "dataset: " << endl;
+	if (this->IsEmpty()) return;
+	for (i = 0; i < this->Size(); i++) {
+		this->BindTuple(i, t);
+		t.PrintTo(os, indent + 4);
+		if (limit > 0 && (signed) i >= limit) break;
+	}
+}
+
+void Dataset::nearest(const string &attr, UnTypedPtr p, vector<idx> &out)
+{
+	typedef int valtype;
+	Array *arr = this->GetAttribute(attr);
+	valtype near, v;
+	valtype pf = *(valtype *) p;
+	near = *(valtype *) arr->getValPtr(0);
+	int nearest = 0;
+
+	for (int i = 1; i < arr->size(); i++) {
+		v = *(valtype *) arr->getValPtr(i);
+		if (abs(pf - v) <= abs(pf - near)) {
+			nearest = i;
+			near = v;
+		}
+	}
+	out.push_back(nearest);
+}
+
+void Dataset::lookupFloat(const string &attr, float p, vector<idx> &out)
+{
+
+	Array *arr = this->GetAttribute(attr);
+	int x = int(p);
+	switch (arr->type) {
+	case FLOAT:
+
+		for (int i = 0; i < arr->size(); i++) {
+			//cout << p << ", " <<  *(float*)arr->getValPtr(i) << endl;
+			if (p == *(float*) arr->getValPtr(i)) {
+				out.push_back(i);
+			}
+		}
+		break;
+	case INT:
+
+		for (int i = 0; i < arr->size(); i++) {
+			//cout << x << ", " <<  *(int*)arr->getValPtr(i) << endl;
+			if (x == *(int*) arr->getValPtr(i)) {
+				out.push_back(i);
+			}
+		}
+		break;
+	case OBJ:
+		Fatal("Array is not of type float.");
+		exit(1);
+		break;
+	case TUPLE:
+		Fatal("Array is not of type float.");
+		exit(1);
+		break;
+	case GRIDFIELD:
+		Fatal("Array is not of type float.");
+		exit(1);
+		break;
+	}
+}
+
+void Dataset::lookupInt(const string &attr, int p, vector<idx> &out)
+{
+
+	Array *arr = this->GetAttribute(attr);
+	float x = float(p);
+	switch (arr->type) {
+	case FLOAT:
+
+		for (int i = 0; i < arr->size(); i++) {
+			//cout << x << ", " <<  *(float*)arr->getValPtr(i) << endl;
+			if (x == *(float*) arr->getValPtr(i)) {
+				out.push_back(i);
+			}
+		}
+		break;
+	case INT:
+		for (int i = 0; i < arr->size(); i++) {
+			//cout << p << ", " <<  *(int*)arr->getValPtr(i) << endl;
+			if (p == *(int*) arr->getValPtr(i)) {
+				out.push_back(i);
+			}
+		}
+		break;
+	case OBJ:
+		for (int i = 0; i < arr->size(); i++) {
+			if (p == *(int*) arr->getValPtr(i)) {
+				out.push_back(i);
+			}
+		}
+	case TUPLE:
+		exit(1);
+	case GRIDFIELD:
+		exit(1);
+	}
 }
 
 /*
-void Dataset::BindTuples(vector<CellId> &cs, vector<Tuple> &ts) {
-  // binds n tuples corresponding to n cells
-  assert(cs.size() == ts.size());
-  
-  vector<Cell>::iterator cptr;
-  for (int i=0; i<cs.size(); i++) {
-    BindTuple(cs[i], ts[i]);
-  }
-}
-*/
+ void Dataset::BindTuples(vector<CellId> &cs, vector<Tuple> &ts) {
+ // binds n tuples corresponding to n cells
+ assert(cs.size() == ts.size());
+
+ vector<Cell>::iterator cptr;
+ for (int i=0; i<cs.size(); i++) {
+ BindTuple(cs[i], ts[i]);
+ }
+ }
+ */
+
+} // namespace GF
 
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/dataset.h gridfields/clib/src/dataset.h
--- tag/gridfieldsclib-0.7/src/dataset.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/dataset.h	2014-05-16 22:57:00.753391866 +0200
@@ -5,73 +5,90 @@
 #include "tuple.h"
 #include "util.h"
 
-class Array;
+//using namespace std;
+
+namespace GF {
 
-using namespace std;
+class Array;
 
 class RankedDataset;
 
 class Dataset {
 
- public:
-  Dataset(const Scheme &s, size_t N);
-  Dataset(unsigned int N) : _size(N) {};
-  Dataset(const Dataset &ds) { 
-    _size = ds.Size();
-    COPY(vector<Array *>, ds.attributes, attributes, ii);
-  };
-  ~Dataset();
-  
-  typedef int* IntIterator;
-  typedef float* FloatIterator;
- 
-  void AddAttribute(Array *arr);
-  void RemoveAttribute(Array *arr);
-  void Zip(const Dataset &arr);
-  void Clear();
-  void CoerceScheme(Scheme sch, unsigned int sz=0);
-  void Apply(const string &unparsedExpr);
-  
-  void recordOrdinals(string ordname);
- 
-  void FilterBy(const string &mask, Dataset &Result);
- 
-  IntIterator BeginInt(const string &attr);
-  IntIterator EndInt(const string &attr);
-  FloatIterator BeginFloat(const string &attr);
-  FloatIterator EndFloat(const string &attr);
-
-  bool IsEmpty() const { return this->attributes.empty(); };
-
-  int IsAttribute(const string &attr) const;
-
-  Array *GetAttribute(const string &attr) const;
-  UnTypedPtr GetVoidPointer(const string &attr) const;
-  UnTypedPtr GetAttributeVal(const string &attr, idx i) const;
+public:
+	Dataset(const Scheme &s, size_t N);
+	Dataset(unsigned int N) :
+			_size(N)
+	{
+	}
+	;
+	Dataset(const Dataset &ds)
+	{
+		_size = ds.Size();
+		COPY(vector<Array *>, ds.attributes, attributes, ii);
+	}
+	;
+	~Dataset();
+
+	typedef int* IntIterator;
+	typedef float* FloatIterator;
+
+	void AddAttribute(Array *arr);
+	void RemoveAttribute(Array *arr);
+	void Zip(const Dataset &arr);
+	void Clear();
+	void CoerceScheme(Scheme sch, unsigned int sz = 0);
+	void Apply(const string &unparsedExpr);
+
+	void recordOrdinals(string ordname);
+
+	void FilterBy(const string &mask, Dataset &Result);
+
+	IntIterator BeginInt(const string &attr);
+	IntIterator EndInt(const string &attr);
+	FloatIterator BeginFloat(const string &attr);
+	FloatIterator EndFloat(const string &attr);
+
+	bool IsEmpty() const
+	{
+		return this->attributes.empty();
+	}
+	;
+
+	int IsAttribute(const string &attr) const;
+
+	Array *GetAttribute(const string &attr) const;
+	UnTypedPtr GetVoidPointer(const string &attr) const;
+	UnTypedPtr GetAttributeVal(const string &attr, idx i) const;
 
 //  void flattenAttr(string attr);
-  
-  void FastBindTuple(unsigned int idx, Tuple &t) const;
-  void BindTuple(unsigned int idx, Tuple &t) const;
-  //void BindTuples(vector<CellId> &cs, vector<Tuple> &ts);
-
-  size_t Size() const;
-  int Arity() const;
-
-  Scheme GetScheme() const;
-
-  void PrintTo(ostream &os, int indent=0, int limit=100) const;
-  void print(int indent=0) const;
-
-  void nearest(const string &attr, UnTypedPtr p, vector<idx> &out);
-  void lookupFloat(const string &attr, float p, vector<idx> &out);
-  void lookupInt(const string &attr, int p, vector<idx> &out);
- friend class RankedDataset;
- private:
-  Dataset() : _size(0) {};
-  size_t _size;
-  vector<Array *> attributes;
+
+	void FastBindTuple(unsigned int idx, Tuple &t) const;
+	void BindTuple(unsigned int idx, Tuple &t) const;
+	//void BindTuples(vector<CellId> &cs, vector<Tuple> &ts);
+
+	size_t Size() const;
+	int Arity() const;
+
+	Scheme GetScheme() const;
+
+	void PrintTo(ostream &os, int indent = 0, int limit = 100) const;
+	void print(int indent = 0) const;
+
+	void nearest(const string &attr, UnTypedPtr p, vector<idx> &out);
+	void lookupFloat(const string &attr, float p, vector<idx> &out);
+	void lookupInt(const string &attr, int p, vector<idx> &out);
+	friend class RankedDataset;
+private:
+	Dataset() :
+			_size(0)
+	{
+	}
+	;
+	size_t _size;
+	vector<Array *> attributes;
 };
 
+} // namespace GF
 
 #endif /*_DATASET_H */
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/elcircfile.cc gridfields/clib/src/elcircfile.cc
--- tag/gridfieldsclib-0.7/src/elcircfile.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/elcircfile.cc	2014-05-16 22:57:00.820058531 +0200
@@ -1,3 +1,5 @@
+#include "config_gridfields.h"
+
 #include <fstream>
 #include <stdio.h>
 #include "array.h"
@@ -15,357 +17,380 @@
 
 using namespace std;
 
-ElcircFile::ElcircFile(string fname) {
-  this->filename = fname;
-  char *fn = (char *) fname.c_str();
-  DEBUG << "CONSTRUCTING ELIO HEADER" << endl;
-  int code = ElioGetHeader(fn, &this->h);
-  if (code == ELIO_OK) {
-    this->valid = true;
-  } else {
-    this->valid = false;
-    Fatal("Elio library returned an error: %i", code);
-  }
-}
-
-ElcircFile::~ElcircFile() {
-  DEBUG << "FREEING ELIO HEADER" << endl;
-  if (this->Valid()) {
-    ElioFreeHeader(&this->h);
-  }
-}
-
-ArrayReader *ElcircFile::getSurfReader(int timestep, string posattr="") {
-  //cout << "ssize: " << this->h.ssize << endl;
-  int offset = this->h.hsize + timestep*this->h.ssize + sizeof(int) + sizeof(float);
-  FileArrayReader *ar = new FileArrayReader(this->filename, offset, posattr);  return ar;
+namespace GF {
+
+ElcircFile::ElcircFile(string fname)
+{
+	this->filename = fname;
+	char *fn = (char *) fname.c_str();
+	DEBUG << "CONSTRUCTING ELIO HEADER" << endl;
+	int code = ElioGetHeader(fn, &this->h);
+	if (code == ELIO_OK) {
+		this->valid = true;
+	}
+	else {
+		this->valid = false;
+		Fatal("Elio library returned an error: %i", code);
+	}
+}
+
+ElcircFile::~ElcircFile()
+{
+	DEBUG << "FREEING ELIO HEADER" << endl;
+	if (this->Valid()) {
+		ElioFreeHeader(&this->h);
+	}
+}
+
+ArrayReader *ElcircFile::getSurfReader(int timestep, string posattr = "")
+{
+	//cout << "ssize: " << this->h.ssize << endl;
+	int offset = this->h.hsize + timestep * this->h.ssize + sizeof(int) + sizeof(float);
+	FileArrayReader *ar = new FileArrayReader(this->filename, offset, posattr);
+	return ar;
 }
 
 /*
-void ElcircFile::getSurfReader(Array *surf, int timestep, string posattr="") {
-  //cout << "ssize: " << this->h.ssize << endl;
-  int offset = this->h.hsize + timestep*this->h.ssize + sizeof(int) + sizeof(float);
-
-  MMapIterator mi(this->filename, offset);
-  PrimitiveIterator<int> pi(mi);
-
-  surf->fill(pi); 
-}
-*/
-
-string ElcircFile::getVarScheme() {
-  const string &var = string(h.variable_nm);
-  string str1=var.c_str();
-  if (same(var,"salinity in psu")) str1= "salt:f";
-  if (same(var,"salt.63")) str1= "salt:f";
-  if (same(var,"horizontal velocity")) str1= "u:f, v:f";
-  if (same(var,"hvel.64")) str1= "u:f, v:f";
-  if (same(var,"temperature in C")) str1= "temp:f";
-  if (same(var,"temp.63")) str1= "temp:f";
-  if (same(var,"vertical velocity")) str1= "w:f";
-  if (same(var,"vert.63")) str1= "w:f";
-  if (same(var,"diffusivity for transport")) str1= "tdiff:f";
-  if (same(var,"tdff.63")) str1= "tdiff:f";
-  if (same(var,"air temperature")) str1= "airtemp:f";
-  if (same(var,"airt.61")) str1= "airtemp:f";
-  if (same(var,"z coordinates")) str1= "z:f";
-  if (same(var,"zcor.63")) str1= "z:f";
-  if (same(var,"surface elevation")) str1= "elev:f";
-  if (same(var,"elev.61")) str1= "elev:f";
-  if (same(var,"fluxsu")) str1= "fluxsu:f";
-  if (same(var,"flsu.61")) str1= "fluxsu:f";
-  if (same(var,"fluxlu")) str1= "fluxlu:f";
-  if (same(var,"fllu.61")) str1= "fluxlu:f";
-  if (same(var,"atmospheric pressure")) str1= "pressure:f";
-  if (same(var,"pres.61")) str1= "pressure:f";
-  if (same(var,"hradd")) str1= "hradd:f";
-  if (same(var,"radd.61")) str1= "hradd:f";
-  if (same(var,"hradu")) str1= "hradu:f";
-  if (same(var,"radu.61")) str1= "hradu:f";
-  Fatal("No scheme found for variable %s.", var.c_str());
-return str1;
-}
-
-ArrayReader *ElcircFile::getVariableReader(const string &variable, 
-                                   int timestep, const string &posattr) {
-  int offset = this->getVariableOffset(timestep, 0, 0);
-  FileArrayReader *ar = new ProjectArrayReader(this->filename, offset, posattr, getVarScheme(), variable);
-  return ar;
-}
-
-int ElcircFile::getTimestepSize() {
-  return h.ssize;
-}
-int ElcircFile::getHeaderSize() {
-  return h.hsize;
-}
-
-int ElcircFile::getSurfOffset(int timestep, int hpos) {
-    int offset = this->h.hsize + timestep*this->h.ssize + sizeof(int) + sizeof(float);
-    offset += hpos*sizeof(int);
-    return offset;
-}
-
-int ElcircFile::getVariableOffset(int timestep, int hpos, int vpos) {
-    int offset = this->h.hsize + timestep*this->h.ssize + sizeof(int) + sizeof(float);
-    offset += this->h.np *sizeof(int);
-    if (this->h.i23d == 2) {
-      offset += hpos*this->h.ivs;
-      return offset;
-    }
-    if (this->h.v != 4) {
-      offset += sizeof(float) * (this->h.no[hpos] + vpos);
-    } else {
-      offset += sizeof(float) * (hpos * this->h.nvrt + vpos);
-    }
-    //cout << hpos << ", " <<  vpos << ", " << this->h.v << ", " << this->h.bi[hpos] << ", " << offset << endl;
-    return offset;
-}
-
-int ElcircFile::newid(int node, int *map, int size) {
-  for (int i=0; i<size; i++) {
-    if (map[i] == node) return i;
-  }
-  return -1;
-}
-
-GridField *ElcircFile::readDGrid() {
-  Grid *gD = new UnitGrid();
-  GridField *D = new GridField(gD);
-  gD->unref();
-
-  Array *as[18];
-  
-/*! Number of time steps skipped */
-  as[0] = new Array("skip", INT);
-  as[0]->copyIntData(&h.skip, 1);
-/*! Vector or scalar data, values are 1 = scalar or 2 = vector */
-  as[1] = new Array("ivs", INT);
-  as[1]->copyIntData(&h.ivs, 1);
-/*! i23d = 2 => 2d (such as elevations or wind) or i23d = 3 => 3d data (such as velocities and salinity) */
-  as[2] = new Array("i23d", INT);
-  as[2]->copyIntData(&h.i23d, 1);
-/*! 1.0 or 0.5 depending whether variable is defined on the level or half level */
-  as[3] = new Array("vpos", FLOAT);
-  as[3]->copyFloatData(&h.vpos, 1);
-/*! correction to mean sea level */
-  as[4] = new Array("zmsl", FLOAT);
-  as[4]->copyFloatData(&h.zmsl, 1);
-/*! Version 4 sigma */
-  as[5] = new Array("ivcor", INT);
-  as[5]->copyIntData(&h.ivcor, 1);
-/*! Version 4 sigma */
-  as[6] = new Array("h0", FLOAT);
-  as[6]->copyFloatData(&h.h0, 1);
-/*! Version 5 sigma */
-  as[7] = new Array("hs", FLOAT);
-  as[7]->copyFloatData(&h.hs, 1);
-/*! Version 4 sigma */
-  as[8] = new Array("hc", FLOAT);
-  as[8]->copyFloatData(&h.hc, 1);
-/*! Version 4 sigma */
-  as[9] = new Array("thetab", FLOAT);
-  as[9]->copyFloatData(&h.thetab, 1);
-/*! Version 4 sigma */
-  as[10] = new Array("thetaf", FLOAT);
-  as[10]->copyFloatData(&h.thetaf, 1);
-/*! Number of vertical levels. Note: this is set to 1 for 2d variables where the
-on-disk header will have the number of levels as in a 3d variable file */
-  as[11] = new Array("nvrt", INT);
-  as[11]->copyIntData(&h.nvrt, 1);
-/*! Number of vertical levels for Z - version 5.0 */
-  as[12] = new Array("kz", INT);
-  as[12]->copyIntData(&h.kz, 1);
-/*! Number of vertical levels for sigma - version 5.0 */
-  as[13] = new Array("ks", INT);
-  as[13]->copyIntData(&h.ks, 1);
-/*! number of elements in a time step */
-  as[14] = new Array("nitems", INT);
-  as[14]->copyIntData(&h.nitems, 1);
-/*! Size of the header on disk */
-  as[15] = new Array("hsize", INT);
-  as[15]->copyIntData(&h.hsize, 1);
-/*! Number of nodes in the grid */
-  as[16] = new Array("np", INT);
-  as[16]->copyIntData(&h.np, 1);
-/*! Number of elements in the grid */
-  as[17] = new Array("ne", INT);
-  as[17]->copyIntData(&h.ne, 1);
- 
-  Dataset ds(1);
-  
-  for (int i=0; i<18; i++) {
-    ds.AddAttribute(as[i]);
-    as[i]->unref();
-  }
-
-  D->Zip(0, ds);
-  return D;
-}
-
-GridField *ElcircFile::readHGrid() {
-  Node nodes[4];
-
-  CellArray *elements = new CellArray();
-  for (int i=0; i<h.ne; i++) {
-    for (int j=0; j<h.etype[i]; j++) {
-      nodes[j] = (Node) h.icon[j][i];
-    }
-    elements->addCellNodes(nodes, h.etype[i]);
-  }
-
-  Grid *G = new Grid("gfGeo", 2);
-  G->setImplicit0Cells(h.np);
-  G->setKCells(elements, 2);
-  GridField *H = new GridField(G);
-  G->unref();
-  //cout << "checkwellformed...\n";typedef map<Node, int> NodeMap;
-  //int wf = G->checkWellFormed();
-  //cout << "Wellformed? " << wf << "\n";
-
-  string name("x");
-  Array *x = new Array(name.c_str(), FLOAT, h.np);
-  x->copyFloatData(h.x, h.np);
-  name = "y";
-  Array *y = new Array(name.c_str(), FLOAT, h.np);
-  y->copyFloatData(h.y, h.np);
-  name = "h";
-  Array *d = new Array(name.c_str(), FLOAT, h.np);
-  d->copyFloatData(h.d, h.np);
-  name = "b";
-  Array *b = new Array(name.c_str(), INT, h.np);
-  b->copyIntData(h.bi, h.np);
-
-  Dataset ds(h.np);
-  ds.AddAttribute(x);
-  ds.AddAttribute(y);
-  ds.AddAttribute(d);
-  ds.AddAttribute(b);
-   
-  x->unref();
-  y->unref();
-  b->unref();
-  d->unref();
-
-  H->Zip(0, ds);
-  //cout << "REFCOUNTS: " << x->refcount << ", " << y->refcount << ", " << b->refcount << endl;
-  return H;
-}
-
-GridField *ElcircFile::readTGrid() {
-  int nsteps = ElioGetNStepsInFile((char *) filename.c_str(), &this->h);
-  //int *offset = new int[nsteps];
-
-  int startpos = this->h.hsize;(void)startpos;
-  
-  Grid *g = (Grid *) new OneGrid("Time", nsteps);
-  GridField *result = new GridField(g);
-  g->unref();
-
-  for (int i=0; i<nsteps; i++) {
-    //offset[i] = i*this->h.ssize/sizeof(int);
-  }
- 
-  Dataset ds(nsteps);
-  
-  Array *tstamp = new Array("tstamp", FLOAT, nsteps);
-  float *stampdata;
-  tstamp->getData(stampdata);
-  Array *tstep = new Array("tstep", FLOAT, nsteps);
-  float *stepdata;
-  tstep->getData(stepdata);
-
-  ElcircTimeStep t;(void)t;
-  //ElioAllocateTimeStep(&this->h, &t);
-  FILE *fp = fopen(filename.c_str(), "r");(void)fp;
-  for (int i=0; i<nsteps; i++) {
-    //ElioGetTimeStep(fp, i, &h, &t);
-    stampdata[i] = h.timestep*(i+1);
-    stepdata[i] =  i; //t.it;
-  }
-/*
-  MMapIterator fmi(this->filename, startpos);
-  PrimitiveIterator<float> fpi(fmi);
-  SliceIterator<float> fsi(fpi, startpos, h.ssize*nsteps/sizeof(int), h.ssize/sizeof(int));
-  tstamp->fill(fsi);
-
-  MMapIterator mi(this->filename, startpos+sizeof(float));
-  PrimitiveIterator<int> pi(mi);
-  SliceIterator<int> si(pi, startpos, h.ssize*nsteps/sizeof(int), h.ssize/sizeof(int));
-  tstep->fill(si);
-  */
-  ds.AddAttribute(tstamp);
-  ds.AddAttribute(tstep);
-  
-  tstamp->unref(); 
-  tstep->unref(); 
-  
-  result->Zip(0, ds);
-  return result;
-}
-
-GridField *ElcircFile::readVGrid() {
-  OneGrid *G = new OneGrid("V", h.nvrt);
-  GridField *V = new GridField(G);
-  G->unref();
-  
-  Array *z = new Array("z", FLOAT, h.nvrt);
-  z->copyFloatData(h.zcor, h.nvrt);
-
-  Dataset ds(h.nvrt);
-  ds.AddAttribute(z);
-  z->unref();
-
-  V->Zip(0, ds);
-  return V;
-}
-
-
-ElcircHeader *ElcircFile::makeHeader(GridField *GF, ElcircHeader *h) {
-  ElcircHeader out;
-
-  strcpy(out.magic,"DataFormat v2.0 (from GridFied)");
-  strcpy(out.version, "GridFields v0.1");
-  strcpy(out.start_time, h->start_time);
-  strcpy(out.variable_nm, h->variable_nm);
-  strcpy(out.variable_dim, h->variable_dim);
-  out.nsteps = h->nsteps;
-  out.timestep = h->timestep;
-  out.skip = h->skip;
-  out.ivs = h->ivs;
-  out.i23d = h->i23d;
-  out.vpos = h->vpos;
-  out.zmsl = h->zmsl;
-  out.nvrt = h->nvrt;
-  out.nitems = h->nitems; //need to compute this!
-  out.hsize = h->hsize;
-  out.ssize = h->ssize;
-  out.zcor = h->zcor;
-  out.np = GF->GetGrid()->Size(0);
-  out.ne = GF->GetGrid()->Size(2);
-  
-  GF->GetAttribute(0, "x")->getData(out.x);
-  GF->GetAttribute(0, "y")->getData(out.y); 
-  GF->GetAttribute(0, "h")->getData(out.d); 
-  GF->GetAttribute(0, "b")->getData(out.bi); 
-  
-  out.no = h->no;
-  out.etype = new int[sizeof(int)*out.ne];  //(int *) malloc(sizeof(int)*out.ne);
-  for (int k=0; k<out.ne; k++) out.etype[k] = 3;
-
-  Node *nodes;
-  for (int j=0; j<4; j++)
-    out.icon[j] = new int[sizeof(int)*out.ne]; //(int *) malloc(sizeof(int)*out.ne);
-
-  AbstractCellArray *cells = GF->GetGrid()->getKCells(2);
-  for (int i=0; i<out.ne; i++) {
-    nodes =  cells->getCellNodes(i);
-    for (int j=0; j<out.etype[i]; j++) {
-      out.icon[j][i] = nodes[j];
-    }
-  }
-  //ElioPrintHeader(*h);
-  return h; 
+ void ElcircFile::getSurfReader(Array *surf, int timestep, string posattr="") {
+ //cout << "ssize: " << this->h.ssize << endl;
+ int offset = this->h.hsize + timestep*this->h.ssize + sizeof(int) + sizeof(float);
+
+ MMapIterator mi(this->filename, offset);
+ PrimitiveIterator<int> pi(mi);
+
+ surf->fill(pi);
+ }
+ */
+
+string ElcircFile::getVarScheme()
+{
+	const string &var = string(h.variable_nm);
+	string str1 = var.c_str();
+	if (same(var, "salinity in psu")) str1 = "salt:f";
+	if (same(var, "salt.63")) str1 = "salt:f";
+	if (same(var, "horizontal velocity")) str1 = "u:f, v:f";
+	if (same(var, "hvel.64")) str1 = "u:f, v:f";
+	if (same(var, "temperature in C")) str1 = "temp:f";
+	if (same(var, "temp.63")) str1 = "temp:f";
+	if (same(var, "vertical velocity")) str1 = "w:f";
+	if (same(var, "vert.63")) str1 = "w:f";
+	if (same(var, "diffusivity for transport")) str1 = "tdiff:f";
+	if (same(var, "tdff.63")) str1 = "tdiff:f";
+	if (same(var, "air temperature")) str1 = "airtemp:f";
+	if (same(var, "airt.61")) str1 = "airtemp:f";
+	if (same(var, "z coordinates")) str1 = "z:f";
+	if (same(var, "zcor.63")) str1 = "z:f";
+	if (same(var, "surface elevation")) str1 = "elev:f";
+	if (same(var, "elev.61")) str1 = "elev:f";
+	if (same(var, "fluxsu")) str1 = "fluxsu:f";
+	if (same(var, "flsu.61")) str1 = "fluxsu:f";
+	if (same(var, "fluxlu")) str1 = "fluxlu:f";
+	if (same(var, "fllu.61")) str1 = "fluxlu:f";
+	if (same(var, "atmospheric pressure")) str1 = "pressure:f";
+	if (same(var, "pres.61")) str1 = "pressure:f";
+	if (same(var, "hradd")) str1 = "hradd:f";
+	if (same(var, "radd.61")) str1 = "hradd:f";
+	if (same(var, "hradu")) str1 = "hradu:f";
+	if (same(var, "radu.61")) str1 = "hradu:f";
+	Fatal("No scheme found for variable %s.", var.c_str());
+	return str1;
+}
+
+ArrayReader *ElcircFile::getVariableReader(const string &variable, int timestep, const string &posattr)
+{
+	int offset = this->getVariableOffset(timestep, 0, 0);
+	FileArrayReader *ar = new ProjectArrayReader(this->filename, offset, posattr, getVarScheme(), variable);
+	return ar;
+}
+
+int ElcircFile::getTimestepSize()
+{
+	return h.ssize;
+}
+int ElcircFile::getHeaderSize()
+{
+	return h.hsize;
+}
+
+int ElcircFile::getSurfOffset(int timestep, int hpos)
+{
+	int offset = this->h.hsize + timestep * this->h.ssize + sizeof(int) + sizeof(float);
+	offset += hpos * sizeof(int);
+	return offset;
+}
+
+int ElcircFile::getVariableOffset(int timestep, int hpos, int vpos)
+{
+	int offset = this->h.hsize + timestep * this->h.ssize + sizeof(int) + sizeof(float);
+	offset += this->h.np * sizeof(int);
+	if (this->h.i23d == 2) {
+		offset += hpos * this->h.ivs;
+		return offset;
+	}
+	if (this->h.v != 4) {
+		offset += sizeof(float) * (this->h.no[hpos] + vpos);
+	}
+	else {
+		offset += sizeof(float) * (hpos * this->h.nvrt + vpos);
+	}
+	//cout << hpos << ", " <<  vpos << ", " << this->h.v << ", " << this->h.bi[hpos] << ", " << offset << endl;
+	return offset;
+}
+
+int ElcircFile::newid(int node, int *map, int size)
+{
+	for (int i = 0; i < size; i++) {
+		if (map[i] == node) return i;
+	}
+	return -1;
+}
+
+GridField *ElcircFile::readDGrid()
+{
+	Grid *gD = new UnitGrid();
+	GridField *D = new GridField(gD);
+	gD->unref();
+
+	Array *as[18];
+
+	/*! Number of time steps skipped */
+	as[0] = new Array("skip", INT);
+	as[0]->copyIntData(&h.skip, 1);
+	/*! Vector or scalar data, values are 1 = scalar or 2 = vector */
+	as[1] = new Array("ivs", INT);
+	as[1]->copyIntData(&h.ivs, 1);
+	/*! i23d = 2 => 2d (such as elevations or wind) or i23d = 3 => 3d data (such as velocities and salinity) */
+	as[2] = new Array("i23d", INT);
+	as[2]->copyIntData(&h.i23d, 1);
+	/*! 1.0 or 0.5 depending whether variable is defined on the level or half level */
+	as[3] = new Array("vpos", FLOAT);
+	as[3]->copyFloatData(&h.vpos, 1);
+	/*! correction to mean sea level */
+	as[4] = new Array("zmsl", FLOAT);
+	as[4]->copyFloatData(&h.zmsl, 1);
+	/*! Version 4 sigma */
+	as[5] = new Array("ivcor", INT);
+	as[5]->copyIntData(&h.ivcor, 1);
+	/*! Version 4 sigma */
+	as[6] = new Array("h0", FLOAT);
+	as[6]->copyFloatData(&h.h0, 1);
+	/*! Version 5 sigma */
+	as[7] = new Array("hs", FLOAT);
+	as[7]->copyFloatData(&h.hs, 1);
+	/*! Version 4 sigma */
+	as[8] = new Array("hc", FLOAT);
+	as[8]->copyFloatData(&h.hc, 1);
+	/*! Version 4 sigma */
+	as[9] = new Array("thetab", FLOAT);
+	as[9]->copyFloatData(&h.thetab, 1);
+	/*! Version 4 sigma */
+	as[10] = new Array("thetaf", FLOAT);
+	as[10]->copyFloatData(&h.thetaf, 1);
+	/*! Number of vertical levels. Note: this is set to 1 for 2d variables where the
+	 on-disk header will have the number of levels as in a 3d variable file */
+	as[11] = new Array("nvrt", INT);
+	as[11]->copyIntData(&h.nvrt, 1);
+	/*! Number of vertical levels for Z - version 5.0 */
+	as[12] = new Array("kz", INT);
+	as[12]->copyIntData(&h.kz, 1);
+	/*! Number of vertical levels for sigma - version 5.0 */
+	as[13] = new Array("ks", INT);
+	as[13]->copyIntData(&h.ks, 1);
+	/*! number of elements in a time step */
+	as[14] = new Array("nitems", INT);
+	as[14]->copyIntData(&h.nitems, 1);
+	/*! Size of the header on disk */
+	as[15] = new Array("hsize", INT);
+	as[15]->copyIntData(&h.hsize, 1);
+	/*! Number of nodes in the grid */
+	as[16] = new Array("np", INT);
+	as[16]->copyIntData(&h.np, 1);
+	/*! Number of elements in the grid */
+	as[17] = new Array("ne", INT);
+	as[17]->copyIntData(&h.ne, 1);
+
+	Dataset ds(1);
+
+	for (int i = 0; i < 18; i++) {
+		ds.AddAttribute(as[i]);
+		as[i]->unref();
+	}
+
+	D->Zip(0, ds);
+	return D;
+}
+
+GridField *ElcircFile::readHGrid()
+{
+	Node nodes[4];
+
+	CellArray *elements = new CellArray();
+	for (int i = 0; i < h.ne; i++) {
+		for (int j = 0; j < h.etype[i]; j++) {
+			nodes[j] = (Node) h.icon[j][i];
+		}
+		elements->addCellNodes(nodes, h.etype[i]);
+	}
+
+	Grid *G = new Grid("gfGeo", 2);
+	G->setImplicit0Cells(h.np);
+	G->setKCells(elements, 2);
+	GridField *H = new GridField(G);
+	G->unref();
+	//cout << "checkwellformed...\n";typedef map<Node, int> NodeMap;
+	//int wf = G->checkWellFormed();
+	//cout << "Wellformed? " << wf << "\n";
+
+	string name("x");
+	Array *x = new Array(name.c_str(), FLOAT, h.np);
+	x->copyFloatData(h.x, h.np);
+	name = "y";
+	Array *y = new Array(name.c_str(), FLOAT, h.np);
+	y->copyFloatData(h.y, h.np);
+	name = "h";
+	Array *d = new Array(name.c_str(), FLOAT, h.np);
+	d->copyFloatData(h.d, h.np);
+	name = "b";
+	Array *b = new Array(name.c_str(), INT, h.np);
+	b->copyIntData(h.bi, h.np);
+
+	Dataset ds(h.np);
+	ds.AddAttribute(x);
+	ds.AddAttribute(y);
+	ds.AddAttribute(d);
+	ds.AddAttribute(b);
+
+	x->unref();
+	y->unref();
+	b->unref();
+	d->unref();
+
+	H->Zip(0, ds);
+	//cout << "REFCOUNTS: " << x->refcount << ", " << y->refcount << ", " << b->refcount << endl;
+	return H;
+}
+
+GridField *ElcircFile::readTGrid()
+{
+	int nsteps = ElioGetNStepsInFile((char *) filename.c_str(), &this->h);
+	//int *offset = new int[nsteps];
+
+	int startpos = this->h.hsize;
+	(void) startpos;
+
+	Grid *g = (Grid *) new OneGrid("Time", nsteps);
+	GridField *result = new GridField(g);
+	g->unref();
+
+	for (int i = 0; i < nsteps; i++) {
+		//offset[i] = i*this->h.ssize/sizeof(int);
+	}
+
+	Dataset ds(nsteps);
+
+	Array *tstamp = new Array("tstamp", FLOAT, nsteps);
+	float *stampdata;
+	tstamp->getData(stampdata);
+	Array *tstep = new Array("tstep", FLOAT, nsteps);
+	float *stepdata;
+	tstep->getData(stepdata);
+
+	ElcircTimeStep t;
+	(void) t;
+	//ElioAllocateTimeStep(&this->h, &t);
+	FILE *fp = fopen(filename.c_str(), "r");
+	(void) fp;
+	for (int i = 0; i < nsteps; i++) {
+		//ElioGetTimeStep(fp, i, &h, &t);
+		stampdata[i] = h.timestep * (i + 1);
+		stepdata[i] = i; //t.it;
+	}
+	/*
+	 MMapIterator fmi(this->filename, startpos);
+	 PrimitiveIterator<float> fpi(fmi);
+	 SliceIterator<float> fsi(fpi, startpos, h.ssize*nsteps/sizeof(int), h.ssize/sizeof(int));
+	 tstamp->fill(fsi);
+
+	 MMapIterator mi(this->filename, startpos+sizeof(float));
+	 PrimitiveIterator<int> pi(mi);
+	 SliceIterator<int> si(pi, startpos, h.ssize*nsteps/sizeof(int), h.ssize/sizeof(int));
+	 tstep->fill(si);
+	 */
+	ds.AddAttribute(tstamp);
+	ds.AddAttribute(tstep);
+
+	tstamp->unref();
+	tstep->unref();
+
+	result->Zip(0, ds);
+	return result;
+}
+
+GridField *ElcircFile::readVGrid()
+{
+	OneGrid *G = new OneGrid("V", h.nvrt);
+	GridField *V = new GridField(G);
+	G->unref();
+
+	Array *z = new Array("z", FLOAT, h.nvrt);
+	z->copyFloatData(h.zcor, h.nvrt);
+
+	Dataset ds(h.nvrt);
+	ds.AddAttribute(z);
+	z->unref();
+
+	V->Zip(0, ds);
+	return V;
+}
+
+ElcircHeader *ElcircFile::makeHeader(GridField *GF, ElcircHeader *h)
+{
+	ElcircHeader out;
+
+	strcpy(out.magic, "DataFormat v2.0 (from GridFied)");
+	strcpy(out.version, "GridFields v0.1");
+	strcpy(out.start_time, h->start_time);
+	strcpy(out.variable_nm, h->variable_nm);
+	strcpy(out.variable_dim, h->variable_dim);
+	out.nsteps = h->nsteps;
+	out.timestep = h->timestep;
+	out.skip = h->skip;
+	out.ivs = h->ivs;
+	out.i23d = h->i23d;
+	out.vpos = h->vpos;
+	out.zmsl = h->zmsl;
+	out.nvrt = h->nvrt;
+	out.nitems = h->nitems; //need to compute this!
+	out.hsize = h->hsize;
+	out.ssize = h->ssize;
+	out.zcor = h->zcor;
+	out.np = GF->GetGrid()->Size(0);
+	out.ne = GF->GetGrid()->Size(2);
+
+	GF->GetAttribute(0, "x")->getData(out.x);
+	GF->GetAttribute(0, "y")->getData(out.y);
+	GF->GetAttribute(0, "h")->getData(out.d);
+	GF->GetAttribute(0, "b")->getData(out.bi);
+
+	out.no = h->no;
+	out.etype = new int[sizeof(int) * out.ne];  //(int *) malloc(sizeof(int)*out.ne);
+	for (int k = 0; k < out.ne; k++)
+		out.etype[k] = 3;
+
+	Node *nodes;
+	for (int j = 0; j < 4; j++)
+		out.icon[j] = new int[sizeof(int) * out.ne]; //(int *) malloc(sizeof(int)*out.ne);
+
+	AbstractCellArray *cells = GF->GetGrid()->getKCells(2);
+	for (int i = 0; i < out.ne; i++) {
+		nodes = cells->getCellNodes(i);
+		for (int j = 0; j < out.etype[i]; j++) {
+			out.icon[j][i] = nodes[j];
+		}
+	}
+	//ElioPrintHeader(*h);
+	return h;
 }
 
+} // namespace GF
 
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/elcircfile.h gridfields/clib/src/elcircfile.h
--- tag/gridfieldsclib-0.7/src/elcircfile.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/elcircfile.h	2014-05-16 22:57:00.763391866 +0200
@@ -4,52 +4,62 @@
 #include <string>
 #include "expr.h"
 #include <stdio.h>
-extern "C" {
+//extern "C" {
 #include "elio.h"
-}
+//}
 #include "arrayreader.h"
 #include "access.h"
 
+//using namespace std;
+
+namespace GF {
+
 class Array;
 class GridField;
 
-using namespace std;
-
 class FileArrayReader;
 
 class ElcircFile {
 
- public:
-  ElcircFile(string fname);
-  ~ElcircFile();
-
-  string getVarScheme();
-  ArrayReader *getSurfReader(int timestep, string posattr);
-  ArrayReader *getVariableReader(const string &variable, 
-                         int timestep, const string &posattr);
-  
-  int getSurfOffset(int index, int hpos=0);
-  int getVariableOffset(int index, int hpos=0, int vpos=0);
-  
-  //int getOffset(string component);
-  int getTimestepSize();
-  int getHeaderSize();
-  //FileArrayReader *getTimeseries()
-  
-  GridField *readHGrid();
-  GridField *readDGrid();
-  GridField *readVGrid();
-  GridField *readTGrid();
-  bool Valid() {return valid;}
-  ElcircHeader *makeHeader(GridField *GF, ElcircHeader *h);
- 
-  ElcircHeader h;
-
-  int i23d() { return h.i23d; };
- private:
-  string filename;
-  bool valid;
-  int newid(int node, int *map, int size);
+public:
+	ElcircFile(string fname);
+	~ElcircFile();
+
+	string getVarScheme();
+	ArrayReader *getSurfReader(int timestep, string posattr);
+	ArrayReader *getVariableReader(const string &variable, int timestep, const string &posattr);
+
+	int getSurfOffset(int index, int hpos = 0);
+	int getVariableOffset(int index, int hpos = 0, int vpos = 0);
+
+	//int getOffset(string component);
+	int getTimestepSize();
+	int getHeaderSize();
+	//FileArrayReader *getTimeseries()
+
+	GridField *readHGrid();
+	GridField *readDGrid();
+	GridField *readVGrid();
+	GridField *readTGrid();
+	bool Valid()
+	{
+		return valid;
+	}
+	ElcircHeader *makeHeader(GridField *GF, ElcircHeader *h);
+
+	ElcircHeader h;
+
+	int i23d()
+	{
+		return h.i23d;
+	}
+	;
+private:
+	string filename;
+	bool valid;
+	int newid(int node, int *map, int size);
 };
 
+} // namespace GF
+
 #endif /* _ELCIRCFILE_H */
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/elio.c gridfields/clib/src/elio.c
--- tag/gridfieldsclib-0.7/src/elio.c	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/elio.c	2014-05-16 22:57:00.780058532 +0200
@@ -79,128 +79,130 @@
  ** \section intro Introduction
  **
  ** The ELIO library provides a C-programming language interface to output files generated by ELCIRC. The CVS repository is 'ace/elio' - use:
-<pre>
-    cvs checkout ace/elio
-</pre>
-to get the elio source code as well as the sources for other utilities using the elio library. These codes are documented at the URL:
-<pre>
-    <a href="http://amb1019.ccalmr.ogi.edu/doc/codes">http://amb1019.ccalmr.ogi.edu/doc/codes</a>
-</pre>
+ <pre>
+ cvs checkout ace/elio
+ </pre>
+ to get the elio source code as well as the sources for other utilities using the elio library. These codes are documented at the URL:
+ <pre>
+ <a href="http://amb1019.ccalmr.ogi.edu/doc/codes">http://amb1019.ccalmr.ogi.edu/doc/codes</a>
+ </pre>
  **
  ** \section use Building your programs.
  **
  ** Makefile
-<pre>
-# 
-# Sample Makefile for use of libelio.a.
-#
-# \$Revision\$
-# \$Log\$
-#
-#
-
-INSTALLDIR = /usr/local/ace
-
-OBJS = testel.o
-
-# -miee for alphas
-# CFLAGS = -mieee
-# for intel
-CFLAGS = -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64
-LIB = /usr/local/ace/lib
-CC = gcc -g
-
-testel: testel.o 
-	\$(CC) \$(CFLAGS) -g testel.c -L\$(LIB) -lelio -lm -o testel
-</pre>
+ <pre>
+ #
+ # Sample Makefile for use of libelio.a.
+ #
+ # \$Revision\$
+ # \$Log\$
+ #
+ #
+
+ INSTALLDIR = /usr/local/ace
+
+ OBJS = testel.o
+
+ # -miee for alphas
+ # CFLAGS = -mieee
+ # for intel
+ CFLAGS = -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64
+ LIB = /usr/local/ace/lib
+ CC = gcc -g
+
+ testel: testel.o
+ \$(CC) \$(CFLAGS) -g testel.c -L\$(LIB) -lelio -lm -o testel
+ </pre>
 
- ** 
+ **
  ** \section examp Example of use.
  **
  ** The following code reads the header from a data file and prints out a
  ** summary of what is seen using the ElioPrintHeader() function.
- ** 
-<pre>
+ **
+ <pre>
 
-// ginfo.c example program - pturner.
-//
-// \$Revision\$
-//
-// \$Log\$
-//
-
-\#include <stdio.h>
-\#include <stdlib.h>
-\#include <math.h>
-\#include "elio.h"
-
-int main(int argc, char **argv)
-{
-    char iname[1024];
-    FILE *fp;
-    ElcircHeader h;
-    int err;
-
-    if (argc != 2) {
-        fprintf(stderr, "Usage: \%s <ELCIRC *.6? file>\\n", argv[0]);
-        exit(1);
-    }
-
-    strcpy(iname, argv[1]);
-// check that file type is correct
-    if ((fp = fopen(iname, "rb")) == NULL) {
-        fprintf(stderr, "\%s: Unable to open file \%s.\\n", argv[0], iname);
-        exit(1);
-    }
-    if (ElioGetFileType(fp) < 2) {
-        fprintf(stderr, "\%s: Incorrect file type for file \%s.\\n", argv[0], iname);
-        exit(1);
-    }
-    fclose(fp);
-// Get the header
-    if ((err = ElioGetHeader(iname, &h)) != ELIO_OK) {
-        fprintf(stderr, "\%s: Error in call to GetElcircHeader(), error # \%d.\\n", argv[0], err);
-        exit(1);
-    }
-    ElioPrintHeader(&h);
-    printf("Number of steps in file: \%d\\n", ElioGetNStepsInFile(iname, &h));
-    ElioFreeHeader(&h);
-}
-</pre>
-
-Makefile for ginfo.c
-
-<pre>
-# 
-# Sample Makefile for use of libelio.a.
-#
-# \$Revision\$
-# \$Log\$
-#
-# -miee for alphas
-# CFLAGS = -mieee
-# for intel
-CFLAGS = -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64
-LIB = /usr/local/ace/lib
-CC = gcc -g
-
-ginfo: ginfo.o 
-	\$(CC) \$(CFLAGS) -g ginfo.c -L\$(LIB) -lelio -lm -o ginfo
-</pre>
+ // ginfo.c example program - pturner.
+ //
+ // \$Revision\$
+ //
+ // \$Log\$
+ //
+
+ \#include <stdio.h>
+ \#include <stdlib.h>
+ \#include <math.h>
+ \#include "elio.h"
+
+ int main(int argc, char **argv)
+ {
+ char iname[1024];
+ FILE *fp;
+ ElcircHeader h;
+ int err;
+
+ if (argc != 2) {
+ fprintf(stderr, "Usage: \%s <ELCIRC *.6? file>\\n", argv[0]);
+ exit(1);
+ }
+
+ strcpy(iname, argv[1]);
+ // check that file type is correct
+ if ((fp = fopen(iname, "rb")) == NULL) {
+ fprintf(stderr, "\%s: Unable to open file \%s.\\n", argv[0], iname);
+ exit(1);
+ }
+ if (ElioGetFileType(fp) < 2) {
+ fprintf(stderr, "\%s: Incorrect file type for file \%s.\\n", argv[0], iname);
+ exit(1);
+ }
+ fclose(fp);
+ // Get the header
+ if ((err = ElioGetHeader(iname, &h)) != ELIO_OK) {
+ fprintf(stderr, "\%s: Error in call to GetElcircHeader(), error # \%d.\\n", argv[0], err);
+ exit(1);
+ }
+ ElioPrintHeader(&h);
+ printf("Number of steps in file: \%d\\n", ElioGetNStepsInFile(iname, &h));
+ ElioFreeHeader(&h);
+ }
+ </pre>
+
+ Makefile for ginfo.c
+
+ <pre>
+ #
+ # Sample Makefile for use of libelio.a.
+ #
+ # \$Revision\$
+ # \$Log\$
+ #
+ # -miee for alphas
+ # CFLAGS = -mieee
+ # for intel
+ CFLAGS = -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64
+ LIB = /usr/local/ace/lib
+ CC = gcc -g
+
+ ginfo: ginfo.o
+ \$(CC) \$(CFLAGS) -g ginfo.c -L\$(LIB) -lelio -lm -o ginfo
+ </pre>
 
 
- ** 
+ **
  **/
 
+#include "config_gridfields.h"
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <ctype.h>
 #include <math.h>
 #include <time.h>
-#include "elio.h"
+//#include "elio.h"
 #include <string.h>
 
+#include "elio.h"
 
 /*!
  * @def WIN32
@@ -234,26 +236,26 @@
 
 /*!
  * Free memory allocated by a previous call to ElioGetHeader()
- * Calling this on an unallocated Header will likely result 
+ * Calling this on an unallocated Header will likely result
  * in a seg fault.
  */
 void ElioFreeHeader(ElcircHeader * h)
 {
-    free(h->zcor);
-    free(h->x);
-    free(h->y);
-    free(h->d);
-    free(h->etype);
-    free(h->icon[0]);
-    free(h->icon[1]);
-    free(h->icon[2]);
-    if (h->v == 3) {
-	free(h->icon[3]);
-    }
-    if (h->v != 4) {
-	free(h->bi);
-    }
-    free(h->no);
+	free(h->zcor);
+	free(h->x);
+	free(h->y);
+	free(h->d);
+	free(h->etype);
+	free(h->icon[0]);
+	free(h->icon[1]);
+	free(h->icon[2]);
+	if (h->v == 3) {
+		free(h->icon[3]);
+	}
+	if (h->v != 4) {
+		free(h->bi);
+	}
+	free(h->no);
 }
 
 /*!
@@ -261,17 +263,17 @@
  */
 void ElioFreeTimeStep(ElcircTimeStep * t)
 {
-    if (t->e != NULL) {
-	free(t->e);
-    }
-    if (t->surfind != NULL) {
-	free(t->surfind);
-    }
-    free(t->d);
+	if (t->e != NULL ) {
+		free(t->e);
+	}
+	if (t->surfind != NULL ) {
+		free(t->surfind);
+	}
+	free(t->d);
 }
 
 /*!
- * Allocate memory for a time step given information in a valid 
+ * Allocate memory for a time step given information in a valid
  * ElcircHeader.
  *
  * Returns ELIO_ERR on failure after cleaning up any current allocations.
@@ -279,112 +281,113 @@
  */
 int ElioAllocateTimeStep(ElcircHeader * h, ElcircTimeStep * t)
 {
-    switch (h->v) {
-    case 2:
-    case 3:
-	t->surfind = (int *) malloc(h->np * sizeof(int));
-	t->d = (float *) malloc(h->nitems * sizeof(float));
-	t->e = (float *) NULL;
-	if (t->surfind == NULL || t->d == NULL) {
-	    return ELIO_ERR;
-	}
-	break;
-    case 4:
-    case 5:
-	t->surfind = (int *) malloc(h->np * sizeof(int));
-	t->e = (float *) malloc(h->np * sizeof(float));
-	t->d = (float *) malloc(h->nitems * sizeof(float));
-	if (t->e == NULL || t->d == NULL) {
-	    return ELIO_ERR;
-	}
-	break;
-    }
-    return ELIO_OK;
+	switch (h->v) {
+	case 2:
+	case 3:
+		t->surfind = (int *) malloc(h->np * sizeof(int));
+		t->d = (float *) malloc(h->nitems * sizeof(float));
+		t->e = (float *) NULL;
+		if (t->surfind == NULL || t->d == NULL ) {
+			return ELIO_ERR;
+		}
+		break;
+	case 4:
+	case 5:
+		t->surfind = (int *) malloc(h->np * sizeof(int));
+		t->e = (float *) malloc(h->np * sizeof(float));
+		t->d = (float *) malloc(h->nitems * sizeof(float));
+		if (t->e == NULL || t->d == NULL ) {
+			return ELIO_ERR;
+		}
+		break;
+	}
+	return ELIO_OK;
 }
 
 /*!
  * Print header information from a valid ElcircHeader struct.
  *
  * \param h = Previously filled in ElcircHeader.
- * 
+ *
  */
 void ElioPrintHeader(ElcircHeader * h)
 {
-    int i;
-    printf("Magic: %s\n", h->magic);
-    printf("Version: %s\n", h->version);
-    printf("Start Time: %s\n", h->start_time);
-    printf("Variable Name: %s\n", h->variable_nm);
-    printf("Variable Dim: %s\n", h->variable_dim);
-    printf("Number of Steps: %d\n", h->nsteps);
-    printf("Time Step: %f\n", h->timestep);
-    printf("Skip Steps: %d\n", h->skip);
-    printf("Variable Type: %d\n", h->ivs);
-    printf("Variable Dimension: %d\n", h->i23d);
-    switch (h->v) {
-    case 2:
-    case 3:
-	printf("Data is Z Level\n");
-	printf("Vertical position: %f\n", h->vpos);
-	printf("Z of MSL: %f\n", h->zmsl);
-	printf("Number of Vertical Levels: %d\n", h->nvrt);
-	printf("Levels:\n");
-	for (i = 0; i < h->nvrt; i++) {
-	    printf("    %02d: %f\n", i, h->zcor[i]);
-	}
-	break;
-    case 4:
-	printf("Data is Sigma Level\n");
-	printf("ivcor: %d\n", h->ivcor);
-	printf("h0: %f\n", h->h0);
-	printf("hc: %f\n", h->hc);
-	printf("Theta b: %f\n", h->thetab);
-	printf("Theta f: %f\n", h->thetaf);
-	printf("Number of Sigma Levels: %d\n", h->nvrt);
-	printf("Levels:\n");
-	for (i = 0; i < h->nvrt; i++) {
-	    printf("    %02d: %f\n", i, h->zcor[i]);
-	}
-	break;
-    case 5:
-	printf("Data is Sigma+Z\n");
-	printf("Total number of Levels: %d\n", h->nvrt);
-	printf("Sigma levels ks: %d\n", h->ks);
-	printf("Z levels kz: %d\n", h->kz);
-	printf("h0: %f\n", h->h0);
-	printf("hs: %f\n", h->hs);
-	printf("hc: %f\n", h->hc);
-	printf("Theta b: %f\n", h->thetab);
-	printf("Theta f: %f\n", h->thetaf);
-	printf("Levels:\n");
-	for (i = 0; i < h->nvrt; i++) {
-	    printf("    %02d: %f\n", i, h->zcor[i]);
-	}
-	break;
-    default:
-	printf("Vertical position: %f\n", h->vpos);
-	printf("Z of MSL: %f\n", h->zmsl);
-	printf("Number of Vertical Levels: %d\n", h->nvrt);
-	printf("Levels:\n");
-	for (i = 0; i < h->nvrt; i++) {
-	    printf("    %02d: %f\n", i, h->zcor[i]);
+	int i;
+	printf("Magic: %s\n", h->magic);
+	printf("Version: %s\n", h->version);
+	printf("Start Time: %s\n", h->start_time);
+	printf("Variable Name: %s\n", h->variable_nm);
+	printf("Variable Dim: %s\n", h->variable_dim);
+	printf("Number of Steps: %d\n", h->nsteps);
+	printf("Time Step: %f\n", h->timestep);
+	printf("Skip Steps: %d\n", h->skip);
+	printf("Variable Type: %d\n", h->ivs);
+	printf("Variable Dimension: %d\n", h->i23d);
+	switch (h->v) {
+	case 2:
+	case 3:
+		printf("Data is Z Level\n");
+		printf("Vertical position: %f\n", h->vpos);
+		printf("Z of MSL: %f\n", h->zmsl);
+		printf("Number of Vertical Levels: %d\n", h->nvrt);
+		printf("Levels:\n");
+		for (i = 0; i < h->nvrt; i++) {
+			printf("    %02d: %f\n", i, h->zcor[i]);
+		}
+		break;
+	case 4:
+		printf("Data is Sigma Level\n");
+		printf("ivcor: %d\n", h->ivcor);
+		printf("h0: %f\n", h->h0);
+		printf("hc: %f\n", h->hc);
+		printf("Theta b: %f\n", h->thetab);
+		printf("Theta f: %f\n", h->thetaf);
+		printf("Number of Sigma Levels: %d\n", h->nvrt);
+		printf("Levels:\n");
+		for (i = 0; i < h->nvrt; i++) {
+			printf("    %02d: %f\n", i, h->zcor[i]);
+		}
+		break;
+	case 5:
+		printf("Data is Sigma+Z\n");
+		printf("Total number of Levels: %d\n", h->nvrt);
+		printf("Sigma levels ks: %d\n", h->ks);
+		printf("Z levels kz: %d\n", h->kz);
+		printf("h0: %f\n", h->h0);
+		printf("hs: %f\n", h->hs);
+		printf("hc: %f\n", h->hc);
+		printf("Theta b: %f\n", h->thetab);
+		printf("Theta f: %f\n", h->thetaf);
+		printf("Levels:\n");
+		for (i = 0; i < h->nvrt; i++) {
+			printf("    %02d: %f\n", i, h->zcor[i]);
+		}
+		break;
+	default:
+		printf("Vertical position: %f\n", h->vpos);
+		printf("Z of MSL: %f\n", h->zmsl);
+		printf("Number of Vertical Levels: %d\n", h->nvrt);
+		printf("Levels:\n");
+		for (i = 0; i < h->nvrt; i++) {
+			printf("    %02d: %f\n", i, h->zcor[i]);
+		}
+		break;
 	}
-	break;
-    }
-    printf("Number of Floats/Step: %d\n", h->nitems);
-    printf("Header Size (bytes): %d\n", h->hsize);
-    printf("Time Step Size (bytes): %d\n", h->ssize);
-    printf("Number of Nodes: %d\n", h->np);
-    printf("Number of Elements: %d\n", h->ne);
-    printf("Internal version number: %d\n", h->v);
-    printf("First Node: 1 -> %f, %f, %f\n", h->x[0], h->y[0], h->d[0]);
-    printf("First Element: 1 -> %d, %d, %d\n", h->icon[0][0], h->icon[1][0], h->icon[2][0]);
-    printf("Last Node: %d -> %f, %f, %f\n", h->np, h->x[h->np - 1], h->y[h->np - 1], h->d[h->np - 1]);
-    printf("Last Element: %d -> %d, %d, %d\n", h->ne, h->icon[0][h->ne - 1], h->icon[1][h->ne - 1], h->icon[2][h->ne - 1]);
+	printf("Number of Floats/Step: %d\n", h->nitems);
+	printf("Header Size (bytes): %d\n", h->hsize);
+	printf("Time Step Size (bytes): %d\n", h->ssize);
+	printf("Number of Nodes: %d\n", h->np);
+	printf("Number of Elements: %d\n", h->ne);
+	printf("Internal version number: %d\n", h->v);
+	printf("First Node: 1 -> %f, %f, %f\n", h->x[0], h->y[0], h->d[0]);
+	printf("First Element: 1 -> %d, %d, %d\n", h->icon[0][0], h->icon[1][0], h->icon[2][0]);
+	printf("Last Node: %d -> %f, %f, %f\n", h->np, h->x[h->np - 1], h->y[h->np - 1], h->d[h->np - 1]);
+	printf("Last Element: %d -> %d, %d, %d\n", h->ne, h->icon[0][h->ne - 1], h->icon[1][h->ne - 1],
+			h->icon[2][h->ne - 1]);
 }
 
 /*!
- * ElioGetTimeStep: Read data for a single time step. 
+ * ElioGetTimeStep: Read data for a single time step.
  *
  * Input variables:
  *
@@ -403,69 +406,66 @@
  */
 int ElioGetTimeStep(FILE * fp, int step, ElcircHeader * h, ElcircTimeStep * t)
 {
-    off_t skip;
-    int i, n;
-   // short *b;
-    skip = (off_t) h->hsize + (off_t) step *(off_t) h->ssize;
-    if (fseeko(fp, skip, SEEK_SET)) {
-	return ELIO_FSEEK_ERR;
-    }
-    if (fread(&t->t, sizeof(float), 1, fp) != 1)
-	return ELIO_FREAD_ERR;
-    if (fread(&t->it, sizeof(int), 1, fp) != 1)
-	return ELIO_FREAD_ERR;
-    if (h->v == 4 || h->v == 5) {
-	if (fread(t->e, sizeof(float), h->np, fp) != h->np)
-	    return ELIO_FREAD_ERR;
-	for (i = 0; i < h->np; i++) {
-	    t->surfind[i] = h->nvrt;
+	off_t skip;
+	int i, n;
+	// short *b;
+	skip = (off_t) h->hsize + (off_t) step * (off_t) h->ssize;
+	if (fseeko(fp, skip, SEEK_SET)) {
+		return ELIO_FSEEK_ERR;
 	}
-    } else {
-	if (fread(t->surfind, sizeof(int), h->np, fp) != h->np)
-	    return ELIO_FREAD_ERR;
-	t->e = (float *) NULL;
-    }
-    if ((n = fread(t->d, sizeof(float), h->nitems, fp)) != h->nitems) {
-	return ELIO_FREAD_ERR;
-    }
-/*
-    printf("Completed Read of Time Step (%d): Time, Step = %f, %d\n", step, t->t, t->it);
-*/
-    return ELIO_OK;
+	if (fread(&t->t, sizeof(float), 1, fp) != 1) return ELIO_FREAD_ERR;
+	if (fread(&t->it, sizeof(int), 1, fp) != 1) return ELIO_FREAD_ERR;
+	if (h->v == 4 || h->v == 5) {
+		if (fread(t->e, sizeof(float), h->np, fp) != h->np) return ELIO_FREAD_ERR;
+		for (i = 0; i < h->np; i++) {
+			t->surfind[i] = h->nvrt;
+		}
+	}
+	else {
+		if (fread(t->surfind, sizeof(int), h->np, fp) != h->np) return ELIO_FREAD_ERR;
+		t->e = (float *) NULL;
+	}
+	if ((n = fread(t->d, sizeof(float), h->nitems, fp)) != h->nitems) {
+		return ELIO_FREAD_ERR;
+	}
+	/*
+	 printf("Completed Read of Time Step (%d): Time, Step = %f, %d\n", step, t->t, t->it);
+	 */
+	return ELIO_OK;
 }
 
 /*!
  * Returns the Z positions of the vertical given the elevation, e. Also
- * the bottom and surface indexes in i1 and i2. Array Zpos1 is returned 
+ * the bottom and surface indexes in i1 and i2. Array Zpos1 is returned
  * with the valid z values. Only values from zpos1[i1] through zpos[i2]
  * contain valid data.
  */
 int ElioGetZPos(ElcircHeader * h, double d, double e, int *i1, int *i2, double *zpos1)
 {
-    int i, ilev1 = 0, ilev2 = 0;
-    for (i = 0; i < h->nvrt; i++) {
-	zpos1[i] = -h->zmsl + h->zcor[i];
-    }
-
-    ilev1 = 0;
-    while (-d >= zpos1[ilev1] && ilev1 < h->nvrt) {
-	ilev1++;
-    }
-    zpos1[ilev1] = (-d);
-    ilev2 = h->nvrt - 1;
-    while (e <= zpos1[ilev2] && ilev2 > 0) {
-	ilev2--;
-    }
-    ilev2++;
-    zpos1[ilev2] = e;
-    *i1 = ilev1;
-    *i2 = ilev2;
-    return ELIO_OK;
+	int i, ilev1 = 0, ilev2 = 0;
+	for (i = 0; i < h->nvrt; i++) {
+		zpos1[i] = -h->zmsl + h->zcor[i];
+	}
+
+	ilev1 = 0;
+	while (-d >= zpos1[ilev1] && ilev1 < h->nvrt) {
+		ilev1++;
+	}
+	zpos1[ilev1] = (-d);
+	ilev2 = h->nvrt - 1;
+	while (e <= zpos1[ilev2] && ilev2 > 0) {
+		ilev2--;
+	}
+	ilev2++;
+	zpos1[ilev2] = e;
+	*i1 = ilev1;
+	*i2 = ilev2;
+	return ELIO_OK;
 }
 
 /*!
  * Return the surface index for a node.
- * 
+ *
  * Input variables:
  *
  * \param fp = Open file handle
@@ -475,25 +475,25 @@
  */
 int ElioGetNodeSurfaceIndex(FILE * fp, int node, int step, ElcircHeader * h)
 {
-    off_t skip;
-    int retval = -1;
-    int ti;
-    if (node >= h->np || node < 0) {
-	return retval;
-    }
-    skip = (off_t) h->hsize + (off_t) step *(off_t) h->ssize + (off_t) 8 + (off_t) (node * 4);
-    if (fseeko(fp, skip, SEEK_SET)) {
-	return ELIO_FSEEK_ERR;
-    }
-    if (fread(&ti, sizeof(int), 1, fp) != 1) {
-	return ELIO_FREAD_ERR;
-    }
-    return ti;
+	off_t skip;
+	int retval = -1;
+	int ti;
+	if (node >= h->np || node < 0) {
+		return retval;
+	}
+	skip = (off_t) h->hsize + (off_t) step * (off_t) h->ssize + (off_t) 8 + (off_t) (node * 4);
+	if (fseeko(fp, skip, SEEK_SET)) {
+		return ELIO_FSEEK_ERR;
+	}
+	if (fread(&ti, sizeof(int), 1, fp) != 1) {
+		return ELIO_FREAD_ERR;
+	}
+	return ti;
 }
 
 /*!
  * Return data for a single node from one time step.
- * 
+ *
  * Input variables:
  *
  * \param fp = Open file handle.
@@ -507,7 +507,7 @@
  * \param it = Pointer to the current computational time step, integer.
  * \param bind = Pointer to the bottom index starting from 0.
  * \param sind = Pointer to the surface index starting from 0.
- * \param d = Pointer to an array of float values, with valid data from 
+ * \param d = Pointer to an array of float values, with valid data from
  *     d[bind] through d[sind].
  *
  * Returns ELIO_OK on success.
@@ -516,108 +516,114 @@
  */
 int ElioGetNode(FILE * fp, int step, int node, ElcircHeader * h, float *t, int *it, int *bind, int *sind, float *d)
 {
-    int npts, itmp;
-    float e;
-    off_t skip;
-    *bind = h->bi[node];
-    if (h->i23d == 3) {		/* 3d data */
-	skip = (off_t) h->hsize + (off_t) step *(off_t) h->ssize;
-	if (fseeko(fp, skip, SEEK_SET)) {	/* Read time, it, and sind */
-	    return ELIO_FSEEK_ERR;
-	}
-	if (fread(t, sizeof(float), 1, fp) != 1) {
-	    return ELIO_FREAD_ERR;
-	}
-	if (fread(it, sizeof(int), 1, fp) != 1) {
-	    return ELIO_FREAD_ERR;
-	}
-	if (h->v == 4) {
-	    itmp = h->nvrt;
-	    *bind = 0;
-	    if (fseeko(fp, node * 4L, SEEK_CUR)) {	/* elevation */
-		return ELIO_FSEEK_ERR;
-	    }
-	    if (fread(&e, sizeof(float), 1, fp) != 1) {
-		return ELIO_FREAD_ERR;
-	    }
-	} else if (h->v == 5) {
-	    itmp = h->nvrt;
-	    if (fseeko(fp, node * 4L, SEEK_CUR)) {	/* elevation */
-		return ELIO_FSEEK_ERR;
-	    }
-	    if (fread(&e, sizeof(float), 1, fp) != 1) {
-		return ELIO_FREAD_ERR;
-	    }
-	} else {
-	    if (fseeko(fp, node * 4L, SEEK_CUR)) {	/* sind */
-		return ELIO_FSEEK_ERR;
-	    }
-	    if (fread(&itmp, sizeof(int), 1, fp) != 1) {
-		return ELIO_FREAD_ERR;
-	    }
-	}
-	*sind = itmp - 1;
-	npts = (h->nvrt - h->bi[node]) * h->ivs;	/* number of points to read for this node */
-	if (fseeko(fp, skip + (off_t) ((2 + h->np + h->no[node]) * 4), SEEK_SET)) {	/* skip time, it, and the surf indexes */
-	    return ELIO_FSEEK_ERR;
-	}
-	if (fread(d, sizeof(float), npts, fp) != npts) {
-	    return ELIO_FREAD_ERR;
-	}
-    } else if (h->i23d == 2) {	/* 2d data - just one or 2 values to read */
-	skip = (off_t) h->hsize + (off_t) step *(off_t) h->ssize;
-	if (fseeko(fp, skip, SEEK_SET)) {	/* Read time, it, and sind */
-	    return ELIO_FSEEK_ERR;
-	}
-	if (fread(t, sizeof(float), 1, fp) != 1) {
-	    return ELIO_FREAD_ERR;
-	}
-	if (fread(it, sizeof(int), 1, fp) != 1) {
-	    return ELIO_FREAD_ERR;
-	}
-	if (h->v == 4) {
-	    itmp = h->nvrt;
-	    *bind = 0;
-	    if (fseeko(fp, node * 4L, SEEK_CUR)) {	/* elevation */
-		return ELIO_FSEEK_ERR;
-	    }
-	    if (fread(&e, sizeof(float), 1, fp) != 1) {
-		return ELIO_FREAD_ERR;
-	    }
-	} else if (h->v == 5) {
-	    itmp = h->nvrt;
-	    if (fseeko(fp, node * 4L, SEEK_CUR)) {	/* elevation */
-		return ELIO_FSEEK_ERR;
-	    }
-	    if (fread(&e, sizeof(float), 1, fp) != 1) {
-		return ELIO_FREAD_ERR;
-	    }
-	} else {
-	    if (fseeko(fp, node * 4L, SEEK_CUR)) {	/* Read time, it, and sind */
-		return ELIO_FSEEK_ERR;
-	    }
-	    if (fread(&itmp, sizeof(int), 1, fp) != 1) {
-		return ELIO_FREAD_ERR;
-	    }
+	int npts, itmp;
+	float e;
+	off_t skip;
+	*bind = h->bi[node];
+	if (h->i23d == 3) { /* 3d data */
+		skip = (off_t) h->hsize + (off_t) step * (off_t) h->ssize;
+		if (fseeko(fp, skip, SEEK_SET)) { /* Read time, it, and sind */
+			return ELIO_FSEEK_ERR;
+		}
+		if (fread(t, sizeof(float), 1, fp) != 1) {
+			return ELIO_FREAD_ERR;
+		}
+		if (fread(it, sizeof(int), 1, fp) != 1) {
+			return ELIO_FREAD_ERR;
+		}
+		if (h->v == 4) {
+			itmp = h->nvrt;
+			*bind = 0;
+			if (fseeko(fp, node * 4L, SEEK_CUR)) { /* elevation */
+				return ELIO_FSEEK_ERR;
+			}
+			if (fread(&e, sizeof(float), 1, fp) != 1) {
+				return ELIO_FREAD_ERR;
+			}
+		}
+		else if (h->v == 5) {
+			itmp = h->nvrt;
+			if (fseeko(fp, node * 4L, SEEK_CUR)) { /* elevation */
+				return ELIO_FSEEK_ERR;
+			}
+			if (fread(&e, sizeof(float), 1, fp) != 1) {
+				return ELIO_FREAD_ERR;
+			}
+		}
+		else {
+			if (fseeko(fp, node * 4L, SEEK_CUR)) { /* sind */
+				return ELIO_FSEEK_ERR;
+			}
+			if (fread(&itmp, sizeof(int), 1, fp) != 1) {
+				return ELIO_FREAD_ERR;
+			}
+		}
+		*sind = itmp - 1;
+		npts = (h->nvrt - h->bi[node]) * h->ivs; /* number of points to read for this node */
+		if (fseeko(fp, skip + (off_t) ((2 + h->np + h->no[node]) * 4), SEEK_SET)) { /* skip time, it, and the surf indexes */
+			return ELIO_FSEEK_ERR;
+		}
+		if (fread(d, sizeof(float), npts, fp) != npts) {
+			return ELIO_FREAD_ERR;
+		}
 	}
-	*sind = itmp - 1;
-	npts = h->ivs;		/* number of points to read for this node */
-	if (fseeko(fp, skip + (off_t) (2L + h->np) * 4L + (off_t) (node * 4L), SEEK_SET)) {	/* skip time, it, and the surf indexes */
-	    return ELIO_FSEEK_ERR;
+	else if (h->i23d == 2) { /* 2d data - just one or 2 values to read */
+		skip = (off_t) h->hsize + (off_t) step * (off_t) h->ssize;
+		if (fseeko(fp, skip, SEEK_SET)) { /* Read time, it, and sind */
+			return ELIO_FSEEK_ERR;
+		}
+		if (fread(t, sizeof(float), 1, fp) != 1) {
+			return ELIO_FREAD_ERR;
+		}
+		if (fread(it, sizeof(int), 1, fp) != 1) {
+			return ELIO_FREAD_ERR;
+		}
+		if (h->v == 4) {
+			itmp = h->nvrt;
+			*bind = 0;
+			if (fseeko(fp, node * 4L, SEEK_CUR)) { /* elevation */
+				return ELIO_FSEEK_ERR;
+			}
+			if (fread(&e, sizeof(float), 1, fp) != 1) {
+				return ELIO_FREAD_ERR;
+			}
+		}
+		else if (h->v == 5) {
+			itmp = h->nvrt;
+			if (fseeko(fp, node * 4L, SEEK_CUR)) { /* elevation */
+				return ELIO_FSEEK_ERR;
+			}
+			if (fread(&e, sizeof(float), 1, fp) != 1) {
+				return ELIO_FREAD_ERR;
+			}
+		}
+		else {
+			if (fseeko(fp, node * 4L, SEEK_CUR)) { /* Read time, it, and sind */
+				return ELIO_FSEEK_ERR;
+			}
+			if (fread(&itmp, sizeof(int), 1, fp) != 1) {
+				return ELIO_FREAD_ERR;
+			}
+		}
+		*sind = itmp - 1;
+		npts = h->ivs; /* number of points to read for this node */
+		if (fseeko(fp, skip + (off_t) (2L + h->np) * 4L + (off_t) (node * 4L), SEEK_SET)) { /* skip time, it, and the surf indexes */
+			return ELIO_FSEEK_ERR;
+		}
+		if (fread(d, sizeof(float), npts, fp) != npts) {
+			return ELIO_FREAD_ERR;
+		}
 	}
-	if (fread(d, sizeof(float), npts, fp) != npts) {
-	    return ELIO_FREAD_ERR;
+	else {
+		return ELIO_ERR;
 	}
-    } else {
-	return ELIO_ERR;
-    }
-    return ELIO_OK;
+	return ELIO_OK;
 }
 
 /*!
  * Extract data for a single node from one previously time step.
  * Works for 2d and 3d data, vector and scalar.
- * 
+ *
  * Input variables:
  *
  * \param t = Pointer to previously read time step.
@@ -635,29 +641,32 @@
  */
 int ElioExtractNode(ElcircTimeStep * t, ElcircHeader * h, int node, int bind, int sind, float *d)
 {
-    int i;
-    if (h->i23d == 2) {
-	if (h->ivs == 2) {
-	    d[0] = t->d[h->no[node]];
-	    d[1] = t->d[h->no[node] + 1];
-	} else {
-	    d[0] = t->d[h->no[node]];
-	}
-    } else {
-	for (i = bind; i <= sind; i++) {
-	    if (h->ivs == 2) {
-		d[2 * i] = t->d[h->no[node] + 2 * i - 2 * bind];
-		d[2 * i + 1] = t->d[h->no[node] + 2 * i + 1 - 2 * bind];
-	    } else {
-		d[i] = t->d[h->no[node] + i - bind];
-	    }
+	int i;
+	if (h->i23d == 2) {
+		if (h->ivs == 2) {
+			d[0] = t->d[h->no[node]];
+			d[1] = t->d[h->no[node] + 1];
+		}
+		else {
+			d[0] = t->d[h->no[node]];
+		}
+	}
+	else {
+		for (i = bind; i <= sind; i++) {
+			if (h->ivs == 2) {
+				d[2 * i] = t->d[h->no[node] + 2 * i - 2 * bind];
+				d[2 * i + 1] = t->d[h->no[node] + 2 * i + 1 - 2 * bind];
+			}
+			else {
+				d[i] = t->d[h->no[node] + i - bind];
+			}
+		}
 	}
-    }
-    return ELIO_OK;
+	return ELIO_OK;
 }
 
 /*!
- * Get data for a single node from one time step - fills in missing data 
+ * Get data for a single node from one time step - fills in missing data
  * values to match the old format.
  *
  * Input variables:
@@ -678,87 +687,89 @@
  */
 int ElioGetNodeOld(FILE * fp, int step, int node, ElcircHeader * h, float *t, int *it, float *d)
 {
-    int i, npts, bind, sind, rval = 0;
-    off_t skip;
-    float *tmp;
-    tmp = (float *) malloc(h->nvrt * h->ivs * sizeof(float));
-    bind = h->bi[node];
-    if (h->i23d == 3) {		/* 3d data */
-	skip = (off_t) h->hsize + (off_t) step *(off_t) h->ssize;
-	if (fseeko(fp, skip, SEEK_SET)) {	/* Read time, it, and sind */
-	    rval = ELIO_FSEEK_ERR;
-	    goto out;
-	}
-	if (fread(t, sizeof(float), 1, fp) != 1) {
-	    rval = ELIO_FREAD_ERR;
-	    goto out;
-	}
-	if (fread(it, sizeof(int), 1, fp) != 1) {
-	    rval = ELIO_FREAD_ERR;
-	    goto out;
-	}
-	if (fseeko(fp, (off_t) (node * 4L), SEEK_CUR)) {
-	    rval = ELIO_FSEEK_ERR;
-	    goto out;
-	}			/* sind */
-	if (fread(&sind, sizeof(int), 1, fp) != 1) {
-	    rval = ELIO_FREAD_ERR;
-	    goto out;
-	}
-	npts = (h->nvrt - h->bi[node]) * h->ivs;	/* number of points to read for this node */
-	if (fseeko(fp, skip + (off_t) ((2 + h->np + h->no[node]) * 4), SEEK_SET)) {	/* skip time, it, and the surf indexes */
-	    rval = ELIO_FSEEK_ERR;
-	    goto out;
-	}
-	if (fread(tmp, sizeof(float), npts, fp) != npts) {
-	    rval = ELIO_FREAD_ERR;
-	    goto out;
-	}
-    } else if (h->i23d == 2) {	/* 2d data - just one or 2 values to read */
-	skip = (off_t) h->hsize + (off_t) step *(off_t) h->ssize;
-	if (fseeko(fp, skip, SEEK_SET)) {	/* Read time, it, and sind */
-	    rval = ELIO_FSEEK_ERR;
-	    goto out;
-	}
-	if (fread(&t, sizeof(float), 1, fp) != 1) {
-	    rval = ELIO_FREAD_ERR;
-	    goto out;
-	}
-	if (fread(&it, sizeof(int), 1, fp) != 1) {
-	    rval = ELIO_FREAD_ERR;
-	    goto out;
-	}
-	if (fseeko(fp, (off_t) (node * 4L), SEEK_CUR)) {	/* Read time, it, and sind */
-	    rval = ELIO_FSEEK_ERR;
-	    goto out;
-	}
-	if (fread(&sind, sizeof(int), 1, fp) != 1) {
-	    rval = ELIO_FREAD_ERR;
-	    goto out;
-	}
-	npts = h->ivs;		/* number of points to read for this node */
-	if (fseeko(fp, skip + (off_t) ((2 + h->np) * 4), SEEK_SET)) {	/* skip time, it, and the surf indexes */
-	    rval = ELIO_FSEEK_ERR;
-	    goto out;
-	}
-	if (fread(tmp, sizeof(float), npts, fp) != npts) {
-	    rval = ELIO_FREAD_ERR;
-	    goto out;
-	}
-    } else {
-	rval = 9;
-	goto out;
-    }
-    for (i = 0; i < (sind - bind) * h->ivs; i++) {
-	d[i + bind * h->ivs] = tmp[i];
-    }
-  out:;
-    free(tmp);
-    return rval;
+	int i, npts, bind, sind, rval = 0;
+	off_t skip;
+	float *tmp;
+	tmp = (float *) malloc(h->nvrt * h->ivs * sizeof(float));
+	bind = h->bi[node];
+	if (h->i23d == 3) { /* 3d data */
+		skip = (off_t) h->hsize + (off_t) step * (off_t) h->ssize;
+		if (fseeko(fp, skip, SEEK_SET)) { /* Read time, it, and sind */
+			rval = ELIO_FSEEK_ERR;
+			goto out;
+		}
+		if (fread(t, sizeof(float), 1, fp) != 1) {
+			rval = ELIO_FREAD_ERR;
+			goto out;
+		}
+		if (fread(it, sizeof(int), 1, fp) != 1) {
+			rval = ELIO_FREAD_ERR;
+			goto out;
+		}
+		if (fseeko(fp, (off_t) (node * 4L), SEEK_CUR)) {
+			rval = ELIO_FSEEK_ERR;
+			goto out;
+		} /* sind */
+		if (fread(&sind, sizeof(int), 1, fp) != 1) {
+			rval = ELIO_FREAD_ERR;
+			goto out;
+		}
+		npts = (h->nvrt - h->bi[node]) * h->ivs; /* number of points to read for this node */
+		if (fseeko(fp, skip + (off_t) ((2 + h->np + h->no[node]) * 4), SEEK_SET)) { /* skip time, it, and the surf indexes */
+			rval = ELIO_FSEEK_ERR;
+			goto out;
+		}
+		if (fread(tmp, sizeof(float), npts, fp) != npts) {
+			rval = ELIO_FREAD_ERR;
+			goto out;
+		}
+	}
+	else if (h->i23d == 2) { /* 2d data - just one or 2 values to read */
+		skip = (off_t) h->hsize + (off_t) step * (off_t) h->ssize;
+		if (fseeko(fp, skip, SEEK_SET)) { /* Read time, it, and sind */
+			rval = ELIO_FSEEK_ERR;
+			goto out;
+		}
+		if (fread(&t, sizeof(float), 1, fp) != 1) {
+			rval = ELIO_FREAD_ERR;
+			goto out;
+		}
+		if (fread(&it, sizeof(int), 1, fp) != 1) {
+			rval = ELIO_FREAD_ERR;
+			goto out;
+		}
+		if (fseeko(fp, (off_t) (node * 4L), SEEK_CUR)) { /* Read time, it, and sind */
+			rval = ELIO_FSEEK_ERR;
+			goto out;
+		}
+		if (fread(&sind, sizeof(int), 1, fp) != 1) {
+			rval = ELIO_FREAD_ERR;
+			goto out;
+		}
+		npts = h->ivs; /* number of points to read for this node */
+		if (fseeko(fp, skip + (off_t) ((2 + h->np) * 4), SEEK_SET)) { /* skip time, it, and the surf indexes */
+			rval = ELIO_FSEEK_ERR;
+			goto out;
+		}
+		if (fread(tmp, sizeof(float), npts, fp) != npts) {
+			rval = ELIO_FREAD_ERR;
+			goto out;
+		}
+	}
+	else {
+		rval = 9;
+		goto out;
+	}
+	for (i = 0; i < (sind - bind) * h->ivs; i++) {
+		d[i + bind * h->ivs] = tmp[i];
+	}
+	out: ;
+	free(tmp);
+	return rval;
 }
 
 /*!
- * Get data for a single node from one time step should work for both 
+ * Get data for a single node from one time step should work for both
  * sigma and z-level grids.
  *
  * Input variables:
@@ -780,97 +791,107 @@
  * Returns ELIO_OK on success.
  * Returns ELIO_FSEEK_ERR and ELIO_FREAD_ERR on error.
  */
-int ElioGetXYData2(FILE * fp, int step, int elem, ElcircHeader * h, double *hh, float *t, int *it, int *bind, int *sind, float *d)
+int ElioGetXYData2(FILE * fp, int step, int elem, ElcircHeader * h, double *hh, float *t, int *it, int *bind, int *sind,
+		float *d)
 {
-    int i, j, nn[4], tcnt, cnt[4];
-    double uret, vret;
-    double  dd[4], vv[4];//*u[4], *v[4],
-    float dtmp[4][400];
-    float dt[400];
-
-/* get the nodes for the element */
-    for (i = 0; i < h->nvrt * h->ivs; i++) {
-	dt[i] = d[i] = 0.0;
-    }
-    for (i = 0; i < h->etype[elem]; i++) {
-	nn[i] = h->icon[i][elem];
-	ElioGetNode(fp, step, nn[i], h, t, it, &bind[i], &sind[i], dt);
-	//printf("Node %d element %d %d %d\n", nn[i], elem, bind[i], sind[i]);
-	for (j = 0; j < h->nvrt; j++) {
-	    if (h->ivs == 2) {
-		// printf("%d %f %f\n", i, dt[2 * j], dt[2 * j + 1]);
-		if (bind[i] <= j && sind[i] >= j) {
-		    dtmp[i][2 * j] = dt[2 * (j - bind[i])];
-		    dtmp[i][2 * j + 1] = dt[2 * (j - bind[i]) + 1];
-		} else {
-		    dtmp[i][2 * j] = 0.0;
-		    dtmp[i][2 * j + 1] = 0.0;
-		}
-	    } else if (h->ivs == 1) {
-		//printf("ElioGetXYData2 = %d, %d: %f\n", i, j, dt[j]);
-		if (bind[i] <= j && sind[i] >= j) {
-		    dtmp[i][j] = dt[j - bind[i]];
-		} else {
-		    dtmp[i][j] = -99.0;
-		}
-	    }
-	}
-    }
-    for (j = 0; j < h->nvrt; j++) {
-	uret = -99;
-	tcnt = 0;
+	int i, j, nn[4], tcnt, cnt[4];
+	double uret, vret;
+	double dd[4], vv[4]; //*u[4], *v[4],
+	float dtmp[4][400];
+	float dt[400];
+
+	/* get the nodes for the element */
+	for (i = 0; i < h->nvrt * h->ivs; i++) {
+		dt[i] = d[i] = 0.0;
+	}
 	for (i = 0; i < h->etype[elem]; i++) {
-	    cnt[i] = 0;
-	    if (h->ivs == 2) {
-		if (bind[i] <= j && sind[i] >= j) {
-		    dd[i] = dtmp[i][2 * j];
-		    vv[i] = dtmp[i][2 * j + 1];
-		    cnt[i]++;
-		    tcnt++;
-		} else {
-		    dd[i] = 0.0;
-		    vv[i] = 0.0;
-		}
-	    } else if (h->ivs == 1) {
-		if (bind[i] <= j && sind[i] >= j) {
-		    dd[i] = dtmp[i][j];
-		    cnt[i]++;
-		    tcnt++;
-		} else {
-		    dd[i] = -99.0;
-		}
-	    }
-	}
-	if (h->ivs == 2) {
-	    if (tcnt && tcnt != h->etype[elem]) {
-		uret = 0.0;
-		vret = 0.0;
-		for (i = 0; i < h->etype[elem]; i++) {
-		    uret = uret + cnt[i] * dd[i];
-		    vret = vret + cnt[i] * vv[i];
+		nn[i] = h->icon[i][elem];
+		ElioGetNode(fp, step, nn[i], h, t, it, &bind[i], &sind[i], dt);
+		//printf("Node %d element %d %d %d\n", nn[i], elem, bind[i], sind[i]);
+		for (j = 0; j < h->nvrt; j++) {
+			if (h->ivs == 2) {
+				// printf("%d %f %f\n", i, dt[2 * j], dt[2 * j + 1]);
+				if (bind[i] <= j && sind[i] >= j) {
+					dtmp[i][2 * j] = dt[2 * (j - bind[i])];
+					dtmp[i][2 * j + 1] = dt[2 * (j - bind[i]) + 1];
+				}
+				else {
+					dtmp[i][2 * j] = 0.0;
+					dtmp[i][2 * j + 1] = 0.0;
+				}
+			}
+			else if (h->ivs == 1) {
+				//printf("ElioGetXYData2 = %d, %d: %f\n", i, j, dt[j]);
+				if (bind[i] <= j && sind[i] >= j) {
+					dtmp[i][j] = dt[j - bind[i]];
+				}
+				else {
+					dtmp[i][j] = -99.0;
+				}
+			}
 		}
-		uret = uret / tcnt;
-		vret = vret / tcnt;
-	    } else if (tcnt == h->etype[elem]) {
-		ElioEval(h->etype[elem], hh, dd, &uret);
-		ElioEval(h->etype[elem], hh, vv, &vret);
-	    }
-	    d[2 * j] = uret;
-	    d[2 * j + 1] = vret;
-	} else if (h->ivs == 1) {
-	    if (tcnt && tcnt != h->etype[elem]) {
-		uret = 0.0;
+	}
+	for (j = 0; j < h->nvrt; j++) {
+		uret = -99;
+		tcnt = 0;
 		for (i = 0; i < h->etype[elem]; i++) {
-		    uret = uret + cnt[i] * dd[i];
+			cnt[i] = 0;
+			if (h->ivs == 2) {
+				if (bind[i] <= j && sind[i] >= j) {
+					dd[i] = dtmp[i][2 * j];
+					vv[i] = dtmp[i][2 * j + 1];
+					cnt[i]++;
+					tcnt++;
+				}
+				else {
+					dd[i] = 0.0;
+					vv[i] = 0.0;
+				}
+			}
+			else if (h->ivs == 1) {
+				if (bind[i] <= j && sind[i] >= j) {
+					dd[i] = dtmp[i][j];
+					cnt[i]++;
+					tcnt++;
+				}
+				else {
+					dd[i] = -99.0;
+				}
+			}
+		}
+		if (h->ivs == 2) {
+			if (tcnt && tcnt != h->etype[elem]) {
+				uret = 0.0;
+				vret = 0.0;
+				for (i = 0; i < h->etype[elem]; i++) {
+					uret = uret + cnt[i] * dd[i];
+					vret = vret + cnt[i] * vv[i];
+				}
+				uret = uret / tcnt;
+				vret = vret / tcnt;
+			}
+			else if (tcnt == h->etype[elem]) {
+				ElioEval(h->etype[elem], hh, dd, &uret);
+				ElioEval(h->etype[elem], hh, vv, &vret);
+			}
+			d[2 * j] = uret;
+			d[2 * j + 1] = vret;
+		}
+		else if (h->ivs == 1) {
+			if (tcnt && tcnt != h->etype[elem]) {
+				uret = 0.0;
+				for (i = 0; i < h->etype[elem]; i++) {
+					uret = uret + cnt[i] * dd[i];
+				}
+				uret = uret / tcnt;
+			}
+			else if (tcnt == h->etype[elem]) {
+				ElioEval(h->etype[elem], hh, dd, &uret);
+			}
+			d[j] = uret;
 		}
-		uret = uret / tcnt;
-	    } else if (tcnt == h->etype[elem]) {
-		ElioEval(h->etype[elem], hh, dd, &uret);
-	    }
-	    d[j] = uret;
 	}
-    }
-    return ELIO_OK;
+	return ELIO_OK;
 }
 
 /*!
@@ -894,148 +915,161 @@
  */
 int ElioInterpTimeStepSigma(ElcircHeader * h, int elem, double x, double y, double *hh, ElcircTimeStep * t, float *d)
 {
-    int i, j, nn[4];// tcnt, cnt[4];
-    double uret, vret;
-    double dd[4], vv[4];//*u[4], *v[4], 
-    float dtmp[4][400];
-    float dt[400];
-/* get the nodes for the element */
-    for (i = 0; i < h->nvrt * h->ivs; i++) {
-	dt[i] = d[i] = 0.0;
-    }
-    for (i = 0; i < h->etype[elem]; i++) {
-	nn[i] = h->icon[i][elem];
-	ElioExtractNode(t, h, nn[i], 0, h->nvrt - 1, dt);
-	for (j = 0; j < h->nvrt; j++) {
-//printf("%d, %d: %f\n", i, j, dt[j]);
-	    if (h->ivs == 2) {
-		dtmp[i][2 * j] = dt[2 * j];
-		dtmp[i][2 * j + 1] = dt[2 * j + 1];
-	    } else if (h->ivs == 1) {
-		dtmp[i][j] = dt[j];
-	    }
+	int i, j, nn[4]; // tcnt, cnt[4];
+	double uret, vret;
+	double dd[4], vv[4]; //*u[4], *v[4],
+	float dtmp[4][400];
+	float dt[400];
+	/* get the nodes for the element */
+	for (i = 0; i < h->nvrt * h->ivs; i++) {
+		dt[i] = d[i] = 0.0;
 	}
-    }
-    for (j = 0; j < h->nvrt; j++) {
 	for (i = 0; i < h->etype[elem]; i++) {
-	    if (h->ivs == 2) {
-		dd[i] = dtmp[i][2 * j];
-		vv[i] = dtmp[i][2 * j + 1];
-	    } else if (h->ivs == 1) {
-		dd[i] = dtmp[i][j];
-	    }
-	}
-	if (h->ivs == 2) {
-	    ElioEval(h->etype[elem], hh, dd, &uret);
-	    ElioEval(h->etype[elem], hh, vv, &vret);
-	    d[2 * j] = uret;
-	    d[2 * j + 1] = vret;
-	} else {
-	    ElioEval(h->etype[elem], hh, dd, &uret);
-	    d[j] = uret;
+		nn[i] = h->icon[i][elem];
+		ElioExtractNode(t, h, nn[i], 0, h->nvrt - 1, dt);
+		for (j = 0; j < h->nvrt; j++) {
+//printf("%d, %d: %f\n", i, j, dt[j]);
+			if (h->ivs == 2) {
+				dtmp[i][2 * j] = dt[2 * j];
+				dtmp[i][2 * j + 1] = dt[2 * j + 1];
+			}
+			else if (h->ivs == 1) {
+				dtmp[i][j] = dt[j];
+			}
+		}
 	}
+	for (j = 0; j < h->nvrt; j++) {
+		for (i = 0; i < h->etype[elem]; i++) {
+			if (h->ivs == 2) {
+				dd[i] = dtmp[i][2 * j];
+				vv[i] = dtmp[i][2 * j + 1];
+			}
+			else if (h->ivs == 1) {
+				dd[i] = dtmp[i][j];
+			}
+		}
+		if (h->ivs == 2) {
+			ElioEval(h->etype[elem], hh, dd, &uret);
+			ElioEval(h->etype[elem], hh, vv, &vret);
+			d[2 * j] = uret;
+			d[2 * j + 1] = vret;
+		}
+		else {
+			ElioEval(h->etype[elem], hh, dd, &uret);
+			d[j] = uret;
+		}
 //printf("uret = %d, %d: %f\n", i, j, d[j]);
-    }
-    return ELIO_OK;
+	}
+	return ELIO_OK;
 }
 
-int ElioInterpTimeStep(ElcircHeader * h, int elem, double x, double y, double *hh, ElcircTimeStep * t, int *bind, int *sind, float *d)
+int ElioInterpTimeStep(ElcircHeader * h, int elem, double x, double y, double *hh, ElcircTimeStep * t, int *bind,
+		int *sind, float *d)
 {
-    int i, j, nn[4], tcnt, cnt[4];
-    double uret, vret;
-    double  dd[4], vv[4];//*u[4], *v[4],
-    float dtmp[4][400];
-    float dt[400];
-
-/* get the nodes for the element */
-    for (i = 0; i < h->nvrt * h->ivs; i++) {
-	dt[i] = d[i] = 0.0;
-    }
-    for (i = 0; i < h->etype[elem]; i++) {
-	nn[i] = h->icon[i][elem];
-	bind[i] = h->bi[nn[i]];
-	sind[i] = t->surfind[nn[i]] - 1;
-	ElioExtractNode(t, h, nn[i], bind[i], sind[i], dt);
-	for (j = 0; j < h->nvrt; j++) {
-	    if (h->ivs == 2) {
-		if (bind[i] <= j && sind[i] >= j) {
-		    dtmp[i][2 * j] = dt[2 * j];
-		    dtmp[i][2 * j + 1] = dt[2 * j + 1];
-		    //printf("values = %d, %d: %f %f\n", i, j, dt[2 * j], dt[2 * j + 1]);
-		} else {
-		    dtmp[i][2 * j] = 0.0;
-		    dtmp[i][2 * j + 1] = 0.0;
-		}
-	    } else if (h->ivs == 1) {
-		//if (h->nvrt == 1) printf("InterpTimeStep = %d, %d: %f %d %d\n", i, j, dt[j], bind[i], sind[i]);
-		if (bind[i] <= j && sind[i] >= j) {
+	int i, j, nn[4], tcnt, cnt[4];
+	double uret, vret;
+	double dd[4], vv[4]; //*u[4], *v[4],
+	float dtmp[4][400];
+	float dt[400];
+
+	/* get the nodes for the element */
+	for (i = 0; i < h->nvrt * h->ivs; i++) {
+		dt[i] = d[i] = 0.0;
+	}
+	for (i = 0; i < h->etype[elem]; i++) {
+		nn[i] = h->icon[i][elem];
+		bind[i] = h->bi[nn[i]];
+		sind[i] = t->surfind[nn[i]] - 1;
+		ElioExtractNode(t, h, nn[i], bind[i], sind[i], dt);
+		for (j = 0; j < h->nvrt; j++) {
+			if (h->ivs == 2) {
+				if (bind[i] <= j && sind[i] >= j) {
+					dtmp[i][2 * j] = dt[2 * j];
+					dtmp[i][2 * j + 1] = dt[2 * j + 1];
+					//printf("values = %d, %d: %f %f\n", i, j, dt[2 * j], dt[2 * j + 1]);
+				}
+				else {
+					dtmp[i][2 * j] = 0.0;
+					dtmp[i][2 * j + 1] = 0.0;
+				}
+			}
+			else if (h->ivs == 1) {
+				//if (h->nvrt == 1) printf("InterpTimeStep = %d, %d: %f %d %d\n", i, j, dt[j], bind[i], sind[i]);
+				if (bind[i] <= j && sind[i] >= j) {
 //if (tdebug && dt[j] < 0.0) {
 //    printf("InterpTimeStep = %d, %d: %f %d %d\n", i, j, dt[j], bind[i], sind[i]);
 //}
-		    dtmp[i][j] = dt[j];
-		} else {
-		    dtmp[i][j] = 0.0;
-		}
-	    }
-	}
-    }
-    for (j = 0; j < h->nvrt; j++) {
-	uret = -99;
-	tcnt = 0;
-	for (i = 0; i < h->etype[elem]; i++) {
-	    cnt[i] = 0;
-	    if (h->ivs == 2) {
-		if (bind[i] <= j && sind[i] >= j) {
-		    dd[i] = dtmp[i][2 * j];
-		    vv[i] = dtmp[i][2 * j + 1];
-		    cnt[i]++;
-		    tcnt++;
-		} else {
-		    dd[i] = 0.0;
-		    vv[i] = 0.0;
-		}
-	    } else if (h->ivs == 1) {
-		if (bind[i] <= j && sind[i] >= j) {
-		    dd[i] = dtmp[i][j];
-		    cnt[i]++;
-		    tcnt++;
-		} else {
-		    dd[i] = 0.0;
-		}
-	    }
-	}
-	if (h->ivs == 2) {
-	    if (tcnt && tcnt != h->etype[elem]) {
-		uret = 0.0;
-		vret = 0.0;
-		for (i = 0; i < h->etype[elem]; i++) {
-		    uret = uret + cnt[i] * dd[i];
-		    vret = vret + cnt[i] * vv[i];
-		    //printf("ElioInterpTimeStep: %d %d %d %lf %lf\n", tcnt, i, cnt[i], dd[i], vv[i]);
-		}
-		uret = uret / tcnt;
-		vret = vret / tcnt;
-	    } else if (tcnt == h->etype[elem]) {
-		ElioEval(h->etype[elem], hh, dd, &uret);
-		ElioEval(h->etype[elem], hh, vv, &vret);
-		//printf("ElioInterpTimeStep OK: %lf %lf\n", uret, vret);
-	    }
-	    d[2 * j] = uret;
-	    d[2 * j + 1] = vret;
-	} else if (h->ivs == 1) {
-	    if (tcnt && tcnt != h->etype[elem]) {
-		uret = 0.0;
+					dtmp[i][j] = dt[j];
+				}
+				else {
+					dtmp[i][j] = 0.0;
+				}
+			}
+		}
+	}
+	for (j = 0; j < h->nvrt; j++) {
+		uret = -99;
+		tcnt = 0;
 		for (i = 0; i < h->etype[elem]; i++) {
-		    uret = uret + cnt[i] * dd[i];
+			cnt[i] = 0;
+			if (h->ivs == 2) {
+				if (bind[i] <= j && sind[i] >= j) {
+					dd[i] = dtmp[i][2 * j];
+					vv[i] = dtmp[i][2 * j + 1];
+					cnt[i]++;
+					tcnt++;
+				}
+				else {
+					dd[i] = 0.0;
+					vv[i] = 0.0;
+				}
+			}
+			else if (h->ivs == 1) {
+				if (bind[i] <= j && sind[i] >= j) {
+					dd[i] = dtmp[i][j];
+					cnt[i]++;
+					tcnt++;
+				}
+				else {
+					dd[i] = 0.0;
+				}
+			}
+		}
+		if (h->ivs == 2) {
+			if (tcnt && tcnt != h->etype[elem]) {
+				uret = 0.0;
+				vret = 0.0;
+				for (i = 0; i < h->etype[elem]; i++) {
+					uret = uret + cnt[i] * dd[i];
+					vret = vret + cnt[i] * vv[i];
+					//printf("ElioInterpTimeStep: %d %d %d %lf %lf\n", tcnt, i, cnt[i], dd[i], vv[i]);
+				}
+				uret = uret / tcnt;
+				vret = vret / tcnt;
+			}
+			else if (tcnt == h->etype[elem]) {
+				ElioEval(h->etype[elem], hh, dd, &uret);
+				ElioEval(h->etype[elem], hh, vv, &vret);
+				//printf("ElioInterpTimeStep OK: %lf %lf\n", uret, vret);
+			}
+			d[2 * j] = uret;
+			d[2 * j + 1] = vret;
+		}
+		else if (h->ivs == 1) {
+			if (tcnt && tcnt != h->etype[elem]) {
+				uret = 0.0;
+				for (i = 0; i < h->etype[elem]; i++) {
+					uret = uret + cnt[i] * dd[i];
+				}
+				uret = uret / tcnt;
+			}
+			else if (tcnt == h->etype[elem]) {
+				ElioEval(h->etype[elem], hh, dd, &uret);
+			}
+			d[j] = uret;
 		}
-		uret = uret / tcnt;
-	    } else if (tcnt == h->etype[elem]) {
-		ElioEval(h->etype[elem], hh, dd, &uret);
-	    }
-	    d[j] = uret;
 	}
-    }
-    return ELIO_OK;
+	return ELIO_OK;
 }
 
 /*!
@@ -1043,11 +1077,11 @@
  *
  * Get data at (x, y) by interpolation.
  *
- * \param fp - Open file handle for the file to read. 
- * \param step  - Step to read starting from 0 - the first step. 
+ * \param fp - Open file handle for the file to read.
+ * \param step  - Step to read starting from 0 - the first step.
  * \param x - X.
  * \param y - Y.
- * \param h - Elcirc header information previously read. 
+ * \param h - Elcirc header information previously read.
  * \param t - Return time from the file.
  * \param it - Return time step from file.
  * \param bind - Integer array of 4 values for returning bottom indexes for the element (x, y) is in.
@@ -1059,51 +1093,53 @@
  * Returns ELIO_FSEEK_ERR on seek failures.
  * Returns ELIO_FREAD_ERR on read failures.
  */
-int ElioGetXYData(FILE * fp, int step, double x, double y, ElcircHeader * h, float *t, int *it, int *bind, int *sind, float *d)
+int ElioGetXYData(FILE * fp, int step, double x, double y, ElcircHeader * h, float *t, int *it, int *bind, int *sind,
+		float *d)
 {
-    int i, j, elem, nn[4];
-    double hh[4], uret;
-    double dd[4];//*u[4], *v[4], 
-    float dtmp[4][400];
-
-/* find the element that contains the point */
-    if ((elem = ElioFindElementXY(h, x, y)) < 0) {
-	printf("elio.GetXY(): Unable to locate element.\n");
-	return 1;
-    }
-/* get the nodes for the element */
-    for (i = 0; i < h->etype[elem]; i++) {
-	nn[i] = h->icon[i][elem];
-	ElioGetNode(fp, step, nn[i], h, t, it, &bind[i], &sind[i], &dtmp[i][0]);
-    }
-    ElioGetCoefficients(h, elem, x, y, hh);
-    for (i = 0; i < h->nvrt * h->ivs; i++) {
-	d[i] = 0.0;
-    }
-    for (j = 0; j < h->nvrt; j++) {
+	int i, j, elem, nn[4];
+	double hh[4], uret;
+	double dd[4]; //*u[4], *v[4],
+	float dtmp[4][400];
+
+	/* find the element that contains the point */
+	if ((elem = ElioFindElementXY(h, x, y)) < 0) {
+		printf("elio.GetXY(): Unable to locate element.\n");
+		return 1;
+	}
+	/* get the nodes for the element */
 	for (i = 0; i < h->etype[elem]; i++) {
-	    if (bind[i] >= j && sind[i] < h->nvrt) {
-		dd[i] = dtmp[i][j - bind[i]];
-	    } else {
-		dd[i] = -99.0;
-	    }
+		nn[i] = h->icon[i][elem];
+		ElioGetNode(fp, step, nn[i], h, t, it, &bind[i], &sind[i], &dtmp[i][0]);
 	}
-	ElioEval(h->etype[elem], hh, dd, &uret);
-	d[j] = uret;
-    }
-    return ELIO_OK;
+	ElioGetCoefficients(h, elem, x, y, hh);
+	for (i = 0; i < h->nvrt * h->ivs; i++) {
+		d[i] = 0.0;
+	}
+	for (j = 0; j < h->nvrt; j++) {
+		for (i = 0; i < h->etype[elem]; i++) {
+			if (bind[i] >= j && sind[i] < h->nvrt) {
+				dd[i] = dtmp[i][j - bind[i]];
+			}
+			else {
+				dd[i] = -99.0;
+			}
+		}
+		ElioEval(h->etype[elem], hh, dd, &uret);
+		d[j] = uret;
+	}
+	return ELIO_OK;
 }
 
 /*!
  *  int ElioGetPoint(FILE * fp, int step, int node, int level, ElcircHeader * h, float *t, int *it, float *d)
  * Get data for a single node from one time step at a particular level (numbered from 0)
  *
- * \param fp - Open file handle for the file to read. 
- * \param step  - Step to read starting from 0 - the first step. 
+ * \param fp - Open file handle for the file to read.
+ * \param step  - Step to read starting from 0 - the first step.
  * \param node  - Node to read starting from 0.
- * \param level - Level to read starting from 0. 
- * \param h - Elcirc header information previously read. 
- * \param t         - Return time value from data file. 
+ * \param level - Level to read starting from 0.
+ * \param h - Elcirc header information previously read.
+ * \param t         - Return time value from data file.
  * \param it,         - Return time step from data file.
  * \param d         - Reurn data value.
  *
@@ -1114,72 +1150,74 @@
  */
 int ElioGetPoint(FILE * fp, int step, int node, int level, ElcircHeader * h, float *t, int *it, float *d)
 {
-    int npts, sind;
-    off_t skip;
-    if (h->i23d == 3) {		/* 3d data */
-	skip = (off_t) h->hsize + (off_t) step *(off_t) h->ssize;
-	if (fseeko(fp, skip, SEEK_SET)) {	/* Read time, it, and sind */
-	    return ELIO_FSEEK_ERR;
-	}
-	if (fread(t, sizeof(float), 1, fp) != 1) {
-	    return ELIO_FREAD_ERR;
-	}
-	if (fread(it, sizeof(int), 1, fp) != 1) {
-	    return ELIO_FREAD_ERR;
-	}
-	if (fseeko(fp, node * 4L, SEEK_CUR)) {	/* sind */
-	    return ELIO_FSEEK_ERR;
-	}
-	if (fread(&sind, sizeof(int), 1, fp) != 1) {
-	    return ELIO_FREAD_ERR;
-	}
-	npts = h->ivs;		/* number of points to read for this node */
-	if (fseeko(fp, skip + (off_t) ((2 + h->np + h->no[node] + level) * 4), SEEK_SET)) {	/* skip time, it, and the surf indexes and go to the particular level of interest */
-	    return ELIO_FSEEK_ERR;
-	}
-	if (fread(d, sizeof(float), npts, fp) != npts) {
-	    return ELIO_FREAD_ERR;
-	}
-	//printf("Starting level %d ending level %d\n", h->bi[node], sind);
-	//for (i = 0; i < npts; i++) {
-	//    printf("Data %d = %f\n", i + h->bi[node], d[i]);
-	//}
-	//printf("Completed Read of Time Step (%d): Time, Step = %f, %d\n", step, *t, *it);
-    } else if (h->i23d == 2) {	/* 2d data - just one or 2 values to read */
-	skip = (off_t) h->hsize + (off_t) step *(off_t) h->ssize;
-	if (fseeko(fp, skip, SEEK_SET)) {	/* Read time, it, and sind */
-	    return ELIO_FSEEK_ERR;
-	}
-	if (fread(&t, sizeof(float), 1, fp) != 1) {
-	    return ELIO_FREAD_ERR;
-	}
-	if (fread(&it, sizeof(int), 1, fp) != 1) {
-	    return ELIO_FREAD_ERR;
-	}
-	if (fseeko(fp, node * 4L, SEEK_CUR)) {	/* Read time, it, and sind */
-	    return ELIO_FSEEK_ERR;
-	}
-	if (fread(&sind, sizeof(int), 1, fp) != 1) {
-	    return ELIO_FREAD_ERR;
-	}
-	npts = h->ivs;		/* number of points to read for this node */
-	if (fseeko(fp, skip + (off_t) ((2 + h->np) * 4), SEEK_SET)) {	/* skip time, it, and the surf indexes */
-	    return ELIO_FSEEK_ERR;
-	}
-	if (fread(d, sizeof(float), npts, fp) != npts) {
-	    return ELIO_FREAD_ERR;
-	}
-/*
-	printf("Starting level %d ending level %d\n", h->bi[node], sind);
-	for (i = 0; i < npts; i++) {
-	    printf("Data %d = %f\n", i, d[i]);
-	}
-*/
-	printf("Completed Read of Time Step (%d): Time, Step = %f, %d\n", step, *t, *it);
-    } else {
-	return ELIO_ERR;
-    }
-    return ELIO_OK;
+	int npts, sind;
+	off_t skip;
+	if (h->i23d == 3) { /* 3d data */
+		skip = (off_t) h->hsize + (off_t) step * (off_t) h->ssize;
+		if (fseeko(fp, skip, SEEK_SET)) { /* Read time, it, and sind */
+			return ELIO_FSEEK_ERR;
+		}
+		if (fread(t, sizeof(float), 1, fp) != 1) {
+			return ELIO_FREAD_ERR;
+		}
+		if (fread(it, sizeof(int), 1, fp) != 1) {
+			return ELIO_FREAD_ERR;
+		}
+		if (fseeko(fp, node * 4L, SEEK_CUR)) { /* sind */
+			return ELIO_FSEEK_ERR;
+		}
+		if (fread(&sind, sizeof(int), 1, fp) != 1) {
+			return ELIO_FREAD_ERR;
+		}
+		npts = h->ivs; /* number of points to read for this node */
+		if (fseeko(fp, skip + (off_t) ((2 + h->np + h->no[node] + level) * 4), SEEK_SET)) { /* skip time, it, and the surf indexes and go to the particular level of interest */
+			return ELIO_FSEEK_ERR;
+		}
+		if (fread(d, sizeof(float), npts, fp) != npts) {
+			return ELIO_FREAD_ERR;
+		}
+		//printf("Starting level %d ending level %d\n", h->bi[node], sind);
+		//for (i = 0; i < npts; i++) {
+		//    printf("Data %d = %f\n", i + h->bi[node], d[i]);
+		//}
+		//printf("Completed Read of Time Step (%d): Time, Step = %f, %d\n", step, *t, *it);
+	}
+	else if (h->i23d == 2) { /* 2d data - just one or 2 values to read */
+		skip = (off_t) h->hsize + (off_t) step * (off_t) h->ssize;
+		if (fseeko(fp, skip, SEEK_SET)) { /* Read time, it, and sind */
+			return ELIO_FSEEK_ERR;
+		}
+		if (fread(&t, sizeof(float), 1, fp) != 1) {
+			return ELIO_FREAD_ERR;
+		}
+		if (fread(&it, sizeof(int), 1, fp) != 1) {
+			return ELIO_FREAD_ERR;
+		}
+		if (fseeko(fp, node * 4L, SEEK_CUR)) { /* Read time, it, and sind */
+			return ELIO_FSEEK_ERR;
+		}
+		if (fread(&sind, sizeof(int), 1, fp) != 1) {
+			return ELIO_FREAD_ERR;
+		}
+		npts = h->ivs; /* number of points to read for this node */
+		if (fseeko(fp, skip + (off_t) ((2 + h->np) * 4), SEEK_SET)) { /* skip time, it, and the surf indexes */
+			return ELIO_FSEEK_ERR;
+		}
+		if (fread(d, sizeof(float), npts, fp) != npts) {
+			return ELIO_FREAD_ERR;
+		}
+		/*
+		 printf("Starting level %d ending level %d\n", h->bi[node], sind);
+		 for (i = 0; i < npts; i++) {
+		 printf("Data %d = %f\n", i, d[i]);
+		 }
+		 */
+		printf("Completed Read of Time Step (%d): Time, Step = %f, %d\n", step, *t, *it);
+	}
+	else {
+		return ELIO_ERR;
+	}
+	return ELIO_OK;
 }
 
 /*!
@@ -1197,220 +1235,212 @@
  * Returns ELIO_OK on success.
  * Returns non-zero on failure.
  *
- * Notes: There are some transformations of header variables performed for 
- * convenience. For 2d variables such as elevations and winds, nvrt (the 
- * number of levels) is set to one, the bottom index for each node is set 
- * to 0 for all nodes. In the case of 3d variables the bottom indices 
+ * Notes: There are some transformations of header variables performed for
+ * convenience. For 2d variables such as elevations and winds, nvrt (the
+ * number of levels) is set to one, the bottom index for each node is set
+ * to 0 for all nodes. In the case of 3d variables the bottom indices
  * ('bi') are decremented by one.
  *
  */
 int ElioGetHeader(char *fname, ElcircHeader * h)
 {
-    FILE *fp;
-    int *itmp, i, j;// ss;
-    if (sizeof(int) != 4 || sizeof(char) != 1 || sizeof(float) != 4) {
-	fprintf(stderr, "Sizeof problems, please investigate: sizeof(char,int,float) = (%d,%d,%d)\n", sizeof(int), sizeof(char), sizeof(float));
-	exit(1);
-    }
-    fp = fopen(fname, "rb");
-    if (fp == NULL) {
-	fprintf(stderr, "GetElioHeader(): Unable to open file %s\n", fname);
-	return 1;
-    }
-    if (fread(h->magic, sizeof(char), 48, fp) != 48)
-	return ELIO_FREAD_ERR;
-    h->magic[48] = 0;
-    /* DataFormat v3.0 */
-    if (strncmp(h->magic, "DataFormat v5.0", 15) == 0) {
-	h->v = 5;
-	h->sigma = 2;		/* Sigma + Z-level grid */
-    } else if (strncmp(h->magic, "DataFormat v4.0", 15) == 0) {
-	h->v = 4;
-	h->sigma = 1;		/* sigma-level grid */
-    } else if (strncmp(h->magic, "DataFormat v3.0", 15) == 0) {
-	h->v = 3;
-	h->sigma = 0;		/* Z-level grid */
-    } else if (strncmp(h->magic, "DataFormat v2.0", 15) == 0) {
-	h->v = 2;
-	h->sigma = 0;		/* Z-level grid */
-    } else {
-	fprintf(stderr, "GetElioHeader(): Unknown version identifier %s\n", h->magic);
-	return (3);
-    }
-    if (fread(h->version, sizeof(char), 48, fp) != 48)
-	return ELIO_FREAD_ERR;
-    h->version[48] = 0;
-    if (fread(h->start_time, sizeof(char), 48, fp) != 48)
-	return ELIO_FREAD_ERR;
-    h->start_time[48] = 0;
-    if (fread(h->variable_nm, sizeof(char), 48, fp) != 48)
-	return ELIO_FREAD_ERR;
-    h->variable_nm[48] = 0;
-    if (fread(h->variable_dim, sizeof(char), 48, fp) != 48)
-	return ELIO_FREAD_ERR;
-    h->variable_dim[48] = 0;
-    if (fread(&h->nsteps, sizeof(int), 1, fp) != 1)
-	return ELIO_FREAD_ERR;
-    if (fread(&h->timestep, sizeof(float), 1, fp) != 1)
-	return ELIO_FREAD_ERR;
-    if (fread(&h->skip, sizeof(int), 1, fp) != 1)
-	return ELIO_FREAD_ERR;
-    if (fread(&h->ivs, sizeof(int), 1, fp) != 1)
-	return ELIO_FREAD_ERR;
-    if (fread(&h->i23d, sizeof(int), 1, fp) != 1)
-	return ELIO_FREAD_ERR;
-
-    if (h->v == 2 || h->v == 3) {
-	if (fread(&h->vpos, sizeof(float), 1, fp) != 1)
-	    return ELIO_FREAD_ERR;
-	if (fread(&h->zmsl, sizeof(float), 1, fp) != 1)
-	    return ELIO_FREAD_ERR;
-	if (fread(&h->nvrt, sizeof(int), 1, fp) != 1)
-	    return ELIO_FREAD_ERR;
-    } else if (h->v == 4) {
-	if (fread(&h->ivcor, sizeof(int), 1, fp) != 1)
-	    return ELIO_FREAD_ERR;
-	if (fread(&h->h0, sizeof(float), 1, fp) != 1)
-	    return ELIO_FREAD_ERR;
-	if (fread(&h->hc, sizeof(float), 1, fp) != 1)
-	    return ELIO_FREAD_ERR;
-	if (fread(&h->thetab, sizeof(float), 1, fp) != 1)
-	    return ELIO_FREAD_ERR;
-	if (fread(&h->thetaf, sizeof(float), 1, fp) != 1)
-	    return ELIO_FREAD_ERR;
-	if (fread(&h->nvrt, sizeof(int), 1, fp) != 1)
-	    return ELIO_FREAD_ERR;
-    } else if (h->v == 5) {
-	if (fread(&h->nvrt, sizeof(int), 1, fp) != 1)
-	    return ELIO_FREAD_ERR;
-	if (fread(&h->kz, sizeof(int), 1, fp) != 1)
-	    return ELIO_FREAD_ERR;
-	h->ks = h->nvrt - h->kz;
-	if (fread(&h->h0, sizeof(float), 1, fp) != 1)
-	    return ELIO_FREAD_ERR;
-	if (fread(&h->hs, sizeof(float), 1, fp) != 1)
-	    return ELIO_FREAD_ERR;
-	if (fread(&h->hc, sizeof(float), 1, fp) != 1)
-	    return ELIO_FREAD_ERR;
-	if (fread(&h->thetab, sizeof(float), 1, fp) != 1)
-	    return ELIO_FREAD_ERR;
-	if (fread(&h->thetaf, sizeof(float), 1, fp) != 1)
-	    return ELIO_FREAD_ERR;
-    }
-    h->zcor = (float *) malloc(h->nvrt * sizeof(float));
-    if (fread(h->zcor, sizeof(float), h->nvrt, fp) != h->nvrt)
-	return ELIO_FREAD_ERR;
+	FILE *fp;
+	int *itmp, i, j;	// ss;
+	// FIXME type error sizeof() returns long unsigned int on 64-bit machines
+	if (sizeof(int) != 4 || sizeof(char) != 1 || sizeof(float) != 4) {
+		fprintf(stderr, "Sizeof problems, please investigate: sizeof(char,int,float) = (%ld,%ld,%ld)\n", sizeof(int),
+				sizeof(char), sizeof(float));
+		exit(1);
+	}
+	fp = fopen(fname, "rb");
+	if (fp == NULL ) {
+		fprintf(stderr, "GetElioHeader(): Unable to open file %s\n", fname);
+		return 1;
+	}
+	if (fread(h->magic, sizeof(char), 48, fp) != 48) {
+		fclose(fp);
+		return ELIO_FREAD_ERR;
+	}
 
-    if (fread(&h->np, sizeof(int), 1, fp) != 1)
-	return ELIO_FREAD_ERR;
-    if (fread(&h->ne, sizeof(int), 1, fp) != 1)
-	return ELIO_FREAD_ERR;
-    h->x = (float *) malloc(h->np * sizeof(float));
-    h->y = (float *) malloc(h->np * sizeof(float));
-    h->d = (float *) malloc(h->np * sizeof(float));
-    h->bi = (int *) malloc(h->np * sizeof(int));
-    h->no = (int *) malloc(h->np * sizeof(int));	/* offset into data for each node */
-    for (i = 0; i < h->np; i++) {
-	if (fread(h->x + i, sizeof(float), 1, fp) != 1)
-	    return ELIO_FREAD_ERR;
-	if (fread(h->y + i, sizeof(float), 1, fp) != 1)
-	    return ELIO_FREAD_ERR;
-	if (fread(h->d + i, sizeof(float), 1, fp) != 1)
-	    return ELIO_FREAD_ERR;
+	h->magic[48] = 0;
+	/* DataFormat v3.0 */
+	if (strncmp(h->magic, "DataFormat v5.0", 15) == 0) {
+		h->v = 5;
+		h->sigma = 2; /* Sigma + Z-level grid */
+	}
+	else if (strncmp(h->magic, "DataFormat v4.0", 15) == 0) {
+		h->v = 4;
+		h->sigma = 1; /* sigma-level grid */
+	}
+	else if (strncmp(h->magic, "DataFormat v3.0", 15) == 0) {
+		h->v = 3;
+		h->sigma = 0; /* Z-level grid */
+	}
+	else if (strncmp(h->magic, "DataFormat v2.0", 15) == 0) {
+		h->v = 2;
+		h->sigma = 0; /* Z-level grid */
+	}
+	else {
+		fprintf(stderr, "GetElioHeader(): Unknown version identifier %s\n", h->magic);
+		fclose(fp);		// 4/10/14 jhrg
+		return (3);
+	}
+
+	if (fread(h->version, sizeof(char), 48, fp) != 48) goto elio_fread_error;
+	h->version[48] = 0;
+	if (fread(h->start_time, sizeof(char), 48, fp) != 48) goto elio_fread_error;
+	h->start_time[48] = 0;
+	if (fread(h->variable_nm, sizeof(char), 48, fp) != 48) goto elio_fread_error;
+	h->variable_nm[48] = 0;
+	if (fread(h->variable_dim, sizeof(char), 48, fp) != 48) goto elio_fread_error;
+	h->variable_dim[48] = 0;
+	if (fread(&h->nsteps, sizeof(int), 1, fp) != 1) goto elio_fread_error;
+	if (fread(&h->timestep, sizeof(float), 1, fp) != 1) goto elio_fread_error;
+	if (fread(&h->skip, sizeof(int), 1, fp) != 1) goto elio_fread_error;
+	if (fread(&h->ivs, sizeof(int), 1, fp) != 1) goto elio_fread_error;
+	if (fread(&h->i23d, sizeof(int), 1, fp) != 1) goto elio_fread_error;
+
+	if (h->v == 2 || h->v == 3) {
+		if (fread(&h->vpos, sizeof(float), 1, fp) != 1) goto elio_fread_error;
+		if (fread(&h->zmsl, sizeof(float), 1, fp) != 1) goto elio_fread_error;
+		if (fread(&h->nvrt, sizeof(int), 1, fp) != 1) goto elio_fread_error;
+	}
+	else if (h->v == 4) {
+		if (fread(&h->ivcor, sizeof(int), 1, fp) != 1) goto elio_fread_error;
+		if (fread(&h->h0, sizeof(float), 1, fp) != 1) goto elio_fread_error;
+		if (fread(&h->hc, sizeof(float), 1, fp) != 1) goto elio_fread_error;
+		if (fread(&h->thetab, sizeof(float), 1, fp) != 1) goto elio_fread_error;
+		if (fread(&h->thetaf, sizeof(float), 1, fp) != 1) goto elio_fread_error;
+		if (fread(&h->nvrt, sizeof(int), 1, fp) != 1) goto elio_fread_error;
+	}
+	else if (h->v == 5) {
+		if (fread(&h->nvrt, sizeof(int), 1, fp) != 1) goto elio_fread_error;
+		if (fread(&h->kz, sizeof(int), 1, fp) != 1) goto elio_fread_error;
+		h->ks = h->nvrt - h->kz;
+		if (fread(&h->h0, sizeof(float), 1, fp) != 1) goto elio_fread_error;
+		if (fread(&h->hs, sizeof(float), 1, fp) != 1) goto elio_fread_error;
+		if (fread(&h->hc, sizeof(float), 1, fp) != 1) goto elio_fread_error;
+		if (fread(&h->thetab, sizeof(float), 1, fp) != 1) goto elio_fread_error;
+		if (fread(&h->thetaf, sizeof(float), 1, fp) != 1) goto elio_fread_error;
+	}
+	h->zcor = (float *) malloc(h->nvrt * sizeof(float));
+	if (fread(h->zcor, sizeof(float), h->nvrt, fp) != h->nvrt) goto elio_fread_error;
+
+	if (fread(&h->np, sizeof(int), 1, fp) != 1) goto elio_fread_error;
+	if (fread(&h->ne, sizeof(int), 1, fp) != 1) goto elio_fread_error;
+	h->x = (float *) malloc(h->np * sizeof(float));
+	h->y = (float *) malloc(h->np * sizeof(float));
+	h->d = (float *) malloc(h->np * sizeof(float));
+	h->bi = (int *) malloc(h->np * sizeof(int));
+	h->no = (int *) malloc(h->np * sizeof(int)); /* offset into data for each node */
+	for (i = 0; i < h->np; i++) {
+		if (fread(h->x + i, sizeof(float), 1, fp) != 1) goto elio_fread_error;
+		if (fread(h->y + i, sizeof(float), 1, fp) != 1) goto elio_fread_error;
+		if (fread(h->d + i, sizeof(float), 1, fp) != 1) goto elio_fread_error;
 
-	if (h->v != 4) {
-	    if (fread(h->bi + i, sizeof(int), 1, fp) != 1)
-		return ELIO_FREAD_ERR;
-	} else {
-	    h->bi[i] = 1;
+		if (h->v != 4) {
+			if (fread(h->bi + i, sizeof(int), 1, fp) != 1) goto elio_fread_error;
+		}
+		else {
+			h->bi[i] = 1;
+		}
 	}
-    }
-    h->icon[0] = (int *) malloc(h->ne * sizeof(int));
-    h->icon[1] = (int *) malloc(h->ne * sizeof(int));
-    h->icon[2] = (int *) malloc(h->ne * sizeof(int));
-    h->etype = (int *) malloc(h->ne * sizeof(int));
-    if (h->v == 2) {		/* format version 2 */
-	itmp = (int *) malloc(h->ne * 3 * sizeof(int));
-	if (fread(itmp, sizeof(int), h->ne * 3, fp) != h->ne * 3)
-	    return ELIO_FREAD_ERR;
-	for (i = 0; i < h->ne; i++) {
-	    h->etype[i] = 3;
-	    h->icon[0][i] = itmp[i * 3] - 1;
-	    h->icon[1][i] = itmp[i * 3 + 1] - 1;
-	    h->icon[2][i] = itmp[i * 3 + 2] - 1;
+	h->icon[0] = (int *) malloc(h->ne * sizeof(int));
+	h->icon[1] = (int *) malloc(h->ne * sizeof(int));
+	h->icon[2] = (int *) malloc(h->ne * sizeof(int));
+	h->etype = (int *) malloc(h->ne * sizeof(int));
+	if (h->v == 2) { /* format version 2 */
+		itmp = (int *) malloc(h->ne * 3 * sizeof(int));
+		if (fread(itmp, sizeof(int), h->ne * 3, fp) != h->ne * 3) goto elio_fread_error;
+		for (i = 0; i < h->ne; i++) {
+			h->etype[i] = 3;
+			h->icon[0][i] = itmp[i * 3] - 1;
+			h->icon[1][i] = itmp[i * 3 + 1] - 1;
+			h->icon[2][i] = itmp[i * 3 + 2] - 1;
+		}
+		free(itmp);
 	}
-	free(itmp);
-    } else if (h->v == 3) {	/* format version 3 support for quads */
-	h->icon[3] = (int *) malloc(h->ne * sizeof(int));
-	for (i = 0; i < h->ne; i++) {
-	    if (fread(&h->etype[i], sizeof(int), 1, fp) != 1)
-		return ELIO_FREAD_ERR;
-	    for (j = 0; j < h->etype[i]; j++) {
-		if (fread(&h->icon[j][i], sizeof(int), 1, fp) != 1)
-		    return ELIO_FREAD_ERR;
-		h->icon[j][i]--;
-	    }
+	else if (h->v == 3) { /* format version 3 support for quads */
+		h->icon[3] = (int *) malloc(h->ne * sizeof(int));
+		for (i = 0; i < h->ne; i++) {
+			if (fread(&h->etype[i], sizeof(int), 1, fp) != 1) goto elio_fread_error;
+			for (j = 0; j < h->etype[i]; j++) {
+				if (fread(&h->icon[j][i], sizeof(int), 1, fp) != 1) goto elio_fread_error;
+				h->icon[j][i]--;
+			}
+		}
 	}
-    } else if (h->v == 4 || h->v == 5) {	/* format version 4 no support for quads */
-	for (i = 0; i < h->ne; i++) {
-	    if (fread(&h->etype[i], sizeof(int), 1, fp) != 1)
-		return ELIO_FREAD_ERR;
-	    for (j = 0; j < h->etype[i]; j++) {
-		if (fread(&h->icon[j][i], sizeof(int), 1, fp) != 1)
-		    return ELIO_FREAD_ERR;
-		h->icon[j][i]--;
-	    }
-	}
-    }
-/* compute size of data in time step and offsets to each node */
-    if (h->i23d == 3) {
-	if (h->v != 4) {
-	    h->nitems = 0;
-	    for (i = 0; i < h->np; i++) {
-                if (h->bi[i] > 0) {
-		    h->bi[i]--;
-                } else {
-                }
-		h->no[i] = h->nitems;
-		h->nitems += (h->nvrt - h->bi[i]) * h->ivs;
-//printf("%d: %d %d %d %d %d\n", i, h->nvrt, h->ivs, h->bi[i], h->no[i], h->nitems);
-	    }
-	} else {
-	    h->nitems = h->ivs * h->nvrt * h->np;
-	    for (i = 0; i < h->np; i++) {
-		h->bi[i] = 0;
-		h->no[i] = i * h->ivs * h->nvrt;
-	    }
+	else if (h->v == 4 || h->v == 5) { /* format version 4 no support for quads */
+		for (i = 0; i < h->ne; i++) {
+			if (fread(&h->etype[i], sizeof(int), 1, fp) != 1) goto elio_fread_error;
+			for (j = 0; j < h->etype[i]; j++) {
+				if (fread(&h->icon[j][i], sizeof(int), 1, fp) != 1) goto elio_fread_error;
+				h->icon[j][i]--;
+			}
+		}
 	}
-    } else {
-	h->nvrt = 1;		/* only 1 level */
-	if (h->v != 4) {
-	    h->nitems = 0;
-	    for (i = 0; i < h->np; i++) {
-		h->bi[i] = 0;	/* bottom index is always 0 */
-		h->no[i] = h->nitems;
-		h->nitems += h->ivs;
-	    }
-	} else {
-	    h->nitems = h->ivs * h->np;
-	    for (i = 0; i < h->np; i++) {
-		h->bi[i] = 0;	/* bottom index is always 0 */
-		h->no[i] = i * h->ivs;
-	    }
-	}
-    }
-/* get the header size in bytes */
-    h->hsize = ftello(fp);
-/* get time step size in bytes */
-    if (h->v == 3 || h->v == 4 || h->v == 5) {	/* version 4 has elevation so size is the same */
-	h->ssize = 8 + h->np * 4 + h->nitems * 4;
-    } else if (h->v == 2) {
-	h->ssize = 8 + h->np * 4 + h->nitems * 4;
-    }
-    if (fclose(fp)) {
-	return ELIO_FCLOSE_ERR;
-    }
-    return ELIO_OK;
+	/* compute size of data in time step and offsets to each node */
+	if (h->i23d == 3) {
+		if (h->v != 4) {
+			h->nitems = 0;
+			for (i = 0; i < h->np; i++) {
+				if (h->bi[i] > 0) {
+					h->bi[i]--;
+				}
+				else {
+				}
+				h->no[i] = h->nitems;
+				h->nitems += (h->nvrt - h->bi[i]) * h->ivs;
+				//printf("%d: %d %d %d %d %d\n", i, h->nvrt, h->ivs, h->bi[i], h->no[i], h->nitems);
+			}
+		}
+		else {
+			h->nitems = h->ivs * h->nvrt * h->np;
+			for (i = 0; i < h->np; i++) {
+				h->bi[i] = 0;
+				h->no[i] = i * h->ivs * h->nvrt;
+			}
+		}
+	}
+	else {
+		h->nvrt = 1; /* only 1 level */
+		if (h->v != 4) {
+			h->nitems = 0;
+			for (i = 0; i < h->np; i++) {
+				h->bi[i] = 0; /* bottom index is always 0 */
+				h->no[i] = h->nitems;
+				h->nitems += h->ivs;
+			}
+		}
+		else {
+			h->nitems = h->ivs * h->np;
+			for (i = 0; i < h->np; i++) {
+				h->bi[i] = 0; /* bottom index is always 0 */
+				h->no[i] = i * h->ivs;
+			}
+		}
+	}
+	/* get the header size in bytes */
+	h->hsize = ftello(fp);
+	/* get time step size in bytes */
+	if (h->v == 3 || h->v == 4 || h->v == 5) { /* version 4 has elevation so size is the same */
+		h->ssize = 8 + h->np * 4 + h->nitems * 4;
+	}
+	else if (h->v == 2) {
+		h->ssize = 8 + h->np * 4 + h->nitems * 4;
+	}
+
+	if (fclose(fp)) {
+		return ELIO_FCLOSE_ERR;
+	}
+	return ELIO_OK;
+
+	// Use goto to handle the many potential errors and
+	// avoid leaking resources. 4/10/14 jhrg
+	elio_fread_error:
+
+	fclose(fp);
+	return ELIO_FREAD_ERR;
 }
 
 /*!
@@ -1420,7 +1450,7 @@
  *
  * \param h = Pointer to ElcircHeader header. Memory will be allocated
  *     to accomodate the internal variables. Assumes suitable defaults
- *     have been set for np, ne, and nvrt. Also that other variables 
+ *     have been set for np, ne, and nvrt. Also that other variables
  *     have proper defaults set.
  *
  * Returns ELIO_OK on success.
@@ -1429,287 +1459,296 @@
  */
 int ElioAllocateHeader(ElcircHeader * h)
 {
-    h->zcor = (float *) malloc(h->nvrt * sizeof(float));
-    h->x = (float *) malloc(h->np * sizeof(float));
-    h->y = (float *) malloc(h->np * sizeof(float));
-    h->d = (float *) malloc(h->np * sizeof(float));
-    h->bi = (int *) malloc(h->np * sizeof(int));
-    h->no = (int *) malloc(h->np * sizeof(int));	/* offset into data for each node */
-    h->icon[0] = (int *) malloc(h->ne * sizeof(int));
-    h->icon[1] = (int *) malloc(h->ne * sizeof(int));
-    h->icon[2] = (int *) malloc(h->ne * sizeof(int));
-    h->icon[3] = (int *) malloc(h->ne * sizeof(int));
-    h->etype = (int *) malloc(h->ne * sizeof(int));
-    return ELIO_OK;
+	h->zcor = (float *) malloc(h->nvrt * sizeof(float));
+	h->x = (float *) malloc(h->np * sizeof(float));
+	h->y = (float *) malloc(h->np * sizeof(float));
+	h->d = (float *) malloc(h->np * sizeof(float));
+	h->bi = (int *) malloc(h->np * sizeof(int));
+	h->no = (int *) malloc(h->np * sizeof(int)); /* offset into data for each node */
+	h->icon[0] = (int *) malloc(h->ne * sizeof(int));
+	h->icon[1] = (int *) malloc(h->ne * sizeof(int));
+	h->icon[2] = (int *) malloc(h->ne * sizeof(int));
+	h->icon[3] = (int *) malloc(h->ne * sizeof(int));
+	h->etype = (int *) malloc(h->ne * sizeof(int));
+	return ELIO_OK;
 }
 
 int ElioMakeScalarsOld(ElcircHeader * h, float *d, float *dd)
 {
-    int i, j, k;
-    for (i = 0; i < h->np * h->nvrt; i++) {
-	dd[i] = -99.0;
-    }
-    for (j = 0; j < h->np; j++) {
-	for (k = h->bi[j]; k < h->nvrt; k++) {
-	    dd[j * h->nvrt + k] = d[h->no[j] + k - h->bi[j]];
+	int i, j, k;
+	for (i = 0; i < h->np * h->nvrt; i++) {
+		dd[i] = -99.0;
 	}
-    }
-    return ELIO_OK;
+	for (j = 0; j < h->np; j++) {
+		for (k = h->bi[j]; k < h->nvrt; k++) {
+			dd[j * h->nvrt + k] = d[h->no[j] + k - h->bi[j]];
+		}
+	}
+	return ELIO_OK;
 }
 
 int ElioMakeVectorsOld(ElcircHeader * h, float *d, float *dd)
 {
-    int i, j, k;
-    float tmp;
-    for (i = 0; i < 2 * h->np * h->nvrt; i++) {
-	dd[i] = 0.0;
-    }
-    for (j = 0; j < h->np; j++) {
-	for (k = h->bi[j]; k < h->nvrt; k++) {
-	    tmp = d[h->no[j] + (k - h->bi[j]) * 2];
-	    dd[2 * (j * h->nvrt + k)] = tmp;
-	    tmp = d[h->no[j] + (k - h->bi[j]) * 2 + 1];
-	    dd[2 * (j * h->nvrt + k) + 1] = tmp;
-/*
-	    dd[2 * (j * h->nvrt + k)] = d[h->no[j] + (k - h->bi[j]) * 2];
-	    dd[2 * (j * h->nvrt + k) + 1] = d[h->no[j] + (k - h->bi[j]) * 2 + 1];
-*/
+	int i, j, k;
+	float tmp;
+	for (i = 0; i < 2 * h->np * h->nvrt; i++) {
+		dd[i] = 0.0;
+	}
+	for (j = 0; j < h->np; j++) {
+		for (k = h->bi[j]; k < h->nvrt; k++) {
+			tmp = d[h->no[j] + (k - h->bi[j]) * 2];
+			dd[2 * (j * h->nvrt + k)] = tmp;
+			tmp = d[h->no[j] + (k - h->bi[j]) * 2 + 1];
+			dd[2 * (j * h->nvrt + k) + 1] = tmp;
+			/*
+			 dd[2 * (j * h->nvrt + k)] = d[h->no[j] + (k - h->bi[j]) * 2];
+			 dd[2 * (j * h->nvrt + k) + 1] = d[h->no[j] + (k - h->bi[j]) * 2 + 1];
+			 */
+		}
 	}
-    }
-    return ELIO_OK;
+	return ELIO_OK;
 }
 
-/*! 
- * Return the actual number of time steps in a data file regardless of 
+/*!
+ * Return the actual number of time steps in a data file regardless of
  * what the ElcircHeader says.
  */
 int ElioGetNStepsInFile(char *fname, ElcircHeader * h)
 {
- //   char id[5];
-    int n;
-    off_t fsize = 0;
-    FILE *fp = fopen(fname, "rb");
-    if (fp == NULL) {
-	fprintf(stderr, "GetNStepsInFile(): Unable to open file %s\n", fname);
-	return ELIO_OK;
-    }
-    if (fseeko(fp, 0L, SEEK_END)) {
-	return ELIO_FSEEK_ERR;
-    }
-    fsize = ftello(fp);
-    if (fclose(fp)) {
-	return ELIO_FCLOSE_ERR;
-    }
-    fsize = fsize - (off_t) h->hsize;
-    if (h->ssize > 0) {
-	n = fsize / h->ssize;
-    } else {
-	n = -1;
-    }
-    return n;
+	//   char id[5];
+	int n;
+	off_t fsize = 0;
+	FILE *fp = fopen(fname, "rb");
+	if (fp == NULL ) {
+		fprintf(stderr, "GetNStepsInFile(): Unable to open file %s\n", fname);
+		return ELIO_OK;
+	}
+	if (fseeko(fp, 0L, SEEK_END)) {
+		fclose(fp); 		// 4/10/14 jhrg
+		return ELIO_FSEEK_ERR;
+	}
+	fsize = ftello(fp);
+	if (fclose(fp)) {
+		return ELIO_FCLOSE_ERR;
+	}
+	fsize = fsize - (off_t) h->hsize;
+	if (h->ssize > 0) {
+		n = fsize / h->ssize;
+	}
+	else {
+		n = -1;
+	}
+	return n;
 }
 
-/*! 
+/*!
  * Extract a Header for the extracted grid
  * x, y, isin need to be allocated in advance.
  */
 int ElioExtractGrid(ElcircHeader * h1, int nb, double *xb, double *yb, int *isin, ElcircHeader * h2)
 {
-    int i;
-    int n;
-    //int np ne;
-    int n1, n2, n3, n4;
-    double x, y;
-
-    *h2 = *h1;			/* copy the easy stuff */
-
-/*
- * Find the 'in' nodes and assign the new node numbers for the reduced grid.
- */
-    n = 1;			/* start from 1 for truth testing (0 is not in) */
-    for (i = 0; i < h1->np; i++) {
-	x = (double) h1->x[i];
-	y = (double) h1->y[i];
-	if (ElioInPolygon(x, y, nb, xb, yb)) {
-	    isin[i] = n;
-	    n++;
-	} else {
-	    isin[i] = 0;
-	}
-    }
-
-    h2->np = n - 1;		/* one extra */
-    h2->x = (float *) malloc(h2->np * sizeof(float));
-    h2->y = (float *) malloc(h2->np * sizeof(float));
-    h2->d = (float *) malloc(h2->np * sizeof(float));
-    h2->bi = (int *) malloc(h2->np * sizeof(int));
-    h2->no = (int *) malloc(h2->np * sizeof(int));
-/*
- * count the number of elements in the new grid
- */
-    n = 0;
-    for (i = 0; i < h1->ne; i++) {
-	n1 = h1->icon[0][i];
-	n2 = h1->icon[1][i];
-	n3 = h1->icon[2][i];
-	if (h1->etype[i] == 3) {
-	    if (isin[n1] && isin[n2] && isin[n3]) {
-		++n;
-	    }
-	} else if (h1->etype[i] == 4) {
-	    n4 = h1->icon[3][i];
-	    if (isin[n1] && isin[n2] && isin[n3] && isin[n4]) {
-		++n;
-	    }
-	}
-    }
-    h2->ne = n;
-    h2->icon[0] = (int *) malloc(h2->ne * sizeof(int));
-    h2->icon[1] = (int *) malloc(h2->ne * sizeof(int));
-    h2->icon[2] = (int *) malloc(h2->ne * sizeof(int));
-    h2->icon[3] = (int *) malloc(h2->ne * sizeof(int));
-    h2->etype = (int *) malloc(h2->ne * sizeof(int));
-
-/*
- * Build new header
- */
-    n = 0;
-    for (i = 0; i < h1->np; i++) {
-	if (isin[i]) {
-	    h2->x[n] = h1->x[i];
-	    h2->y[n] = h1->y[i];
-	    h2->d[n] = h1->d[i];
-	    h2->bi[n] = h1->bi[i];
-	    n++;
-	}
-    }
-/*
- * use the old node numbers to hash into the list containing the new
- * node numbers when writing out the table of elements.
- */
-    n = 0;
-    for (i = 0; i < h1->ne; i++) {
-	n1 = h1->icon[0][i];
-	n2 = h1->icon[1][i];
-	n3 = h1->icon[2][i];
-	h2->etype[n] = h1->etype[i];
-	if (h1->etype[i] == 4) {
-	    n4 = h1->icon[3][i];
-	    if (isin[n1] && isin[n2] && isin[n3] && isin[n4]) {
-		h2->icon[0][n] = isin[n1] - 1;	/* isin starts from 1 */
-		h2->icon[1][n] = isin[n2] - 1;
-		h2->icon[2][n] = isin[n3] - 1;
-		h2->icon[3][n] = isin[n4] - 1;
-		n++;
-	    }
-	} else {
-	    if (isin[n1] && isin[n2] && isin[n3]) {
-		h2->icon[0][n] = isin[n1] - 1;	/* isin starts from 1 */
-		h2->icon[1][n] = isin[n2] - 1;
-		h2->icon[2][n] = isin[n3] - 1;
-		n++;
-	    }
-	}
-    }
-/* get the computed elements of the header */
-    if (h2->i23d == 3) {
-	h2->nitems = 0;
-	for (i = 0; i < h2->np; i++) {
-	    h2->no[i] = h2->nitems;
-	    h2->nitems += (h2->nvrt - h2->bi[i]) * h2->ivs;
+	int i;
+	int n;
+	//int np ne;
+	int n1, n2, n3, n4;
+	double x, y;
+
+	*h2 = *h1; /* copy the easy stuff */
+
+	/*
+	 * Find the 'in' nodes and assign the new node numbers for the reduced grid.
+	 */
+	n = 1; /* start from 1 for truth testing (0 is not in) */
+	for (i = 0; i < h1->np; i++) {
+		x = (double) h1->x[i];
+		y = (double) h1->y[i];
+		if (ElioInPolygon(x, y, nb, xb, yb)) {
+			isin[i] = n;
+			n++;
+		}
+		else {
+			isin[i] = 0;
+		}
 	}
-    } else {
-	h2->nvrt = 1;		/* only 1 level */
-	h2->nitems = 0;
-	for (i = 0; i < h2->np; i++) {
-	    h2->bi[i] = 0;	/* bottom index is always 0 */
-	    h2->no[i] = h2->nitems;
-	    h2->nitems += h2->ivs;
-	}
-    }
-/* get the header size in bytes TODO */
-    /*h2->hsize = ftello(fp); */
-/* get time step size in bytes */
-    h2->ssize = 8 + h2->np * 4 + h2->nitems * 4;
-    return ELIO_OK;
+
+	h2->np = n - 1; /* one extra */
+	h2->x = (float *) malloc(h2->np * sizeof(float));
+	h2->y = (float *) malloc(h2->np * sizeof(float));
+	h2->d = (float *) malloc(h2->np * sizeof(float));
+	h2->bi = (int *) malloc(h2->np * sizeof(int));
+	h2->no = (int *) malloc(h2->np * sizeof(int));
+	/*
+	 * count the number of elements in the new grid
+	 */
+	n = 0;
+	for (i = 0; i < h1->ne; i++) {
+		n1 = h1->icon[0][i];
+		n2 = h1->icon[1][i];
+		n3 = h1->icon[2][i];
+		if (h1->etype[i] == 3) {
+			if (isin[n1] && isin[n2] && isin[n3]) {
+				++n;
+			}
+		}
+		else if (h1->etype[i] == 4) {
+			n4 = h1->icon[3][i];
+			if (isin[n1] && isin[n2] && isin[n3] && isin[n4]) {
+				++n;
+			}
+		}
+	}
+	h2->ne = n;
+	h2->icon[0] = (int *) malloc(h2->ne * sizeof(int));
+	h2->icon[1] = (int *) malloc(h2->ne * sizeof(int));
+	h2->icon[2] = (int *) malloc(h2->ne * sizeof(int));
+	h2->icon[3] = (int *) malloc(h2->ne * sizeof(int));
+	h2->etype = (int *) malloc(h2->ne * sizeof(int));
+
+	/*
+	 * Build new header
+	 */
+	n = 0;
+	for (i = 0; i < h1->np; i++) {
+		if (isin[i]) {
+			h2->x[n] = h1->x[i];
+			h2->y[n] = h1->y[i];
+			h2->d[n] = h1->d[i];
+			h2->bi[n] = h1->bi[i];
+			n++;
+		}
+	}
+	/*
+	 * use the old node numbers to hash into the list containing the new
+	 * node numbers when writing out the table of elements.
+	 */
+	n = 0;
+	for (i = 0; i < h1->ne; i++) {
+		n1 = h1->icon[0][i];
+		n2 = h1->icon[1][i];
+		n3 = h1->icon[2][i];
+		h2->etype[n] = h1->etype[i];
+		if (h1->etype[i] == 4) {
+			n4 = h1->icon[3][i];
+			if (isin[n1] && isin[n2] && isin[n3] && isin[n4]) {
+				h2->icon[0][n] = isin[n1] - 1; /* isin starts from 1 */
+				h2->icon[1][n] = isin[n2] - 1;
+				h2->icon[2][n] = isin[n3] - 1;
+				h2->icon[3][n] = isin[n4] - 1;
+				n++;
+			}
+		}
+		else {
+			if (isin[n1] && isin[n2] && isin[n3]) {
+				h2->icon[0][n] = isin[n1] - 1; /* isin starts from 1 */
+				h2->icon[1][n] = isin[n2] - 1;
+				h2->icon[2][n] = isin[n3] - 1;
+				n++;
+			}
+		}
+	}
+	/* get the computed elements of the header */
+	if (h2->i23d == 3) {
+		h2->nitems = 0;
+		for (i = 0; i < h2->np; i++) {
+			h2->no[i] = h2->nitems;
+			h2->nitems += (h2->nvrt - h2->bi[i]) * h2->ivs;
+		}
+	}
+	else {
+		h2->nvrt = 1; /* only 1 level */
+		h2->nitems = 0;
+		for (i = 0; i < h2->np; i++) {
+			h2->bi[i] = 0; /* bottom index is always 0 */
+			h2->no[i] = h2->nitems;
+			h2->nitems += h2->ivs;
+		}
+	}
+	/* get the header size in bytes TODO */
+	/*h2->hsize = ftello(fp); */
+	/* get time step size in bytes */
+	h2->ssize = 8 + h2->np * 4 + h2->nitems * 4;
+	return ELIO_OK;
 }
 
 /*!
  * Extract data from a sampled grid
- * The header must be created before this function is called 
+ * The header must be created before this function is called
  */
 int ElioExtractData(ElcircHeader * h1, ElcircHeader * h2, int *isin, ElcircTimeStep t1, ElcircTimeStep * t2)
 {
-    int i, j, n, *si;// npts;
-   // float *d;
-    *t2 = t1;
-    si = (int *) malloc(h2->np * sizeof(int));
-    n = 0;
-    for (i = 0; i < h1->np; i++) {
-	if (isin[i]) {
-	    si[n] = t1.surfind[i];
-	    n++;
-	}
-    }
-    t2->surfind = si;
-    t2->d = (float *) malloc(h2->nitems * sizeof(float));
-    n = 0;
-    for (i = 0; i < h1->np; i++) {
-	if (isin[i]) {
-	    for (j = 0; j < h1->nvrt - h1->bi[i]; j++) {
-		t2->d[n] = t1.d[h1->no[i] + j];
-		n++;
-	    }
+	int i, j, n, *si;    // npts;
+	// float *d;
+	*t2 = t1;
+	si = (int *) malloc(h2->np * sizeof(int));
+	n = 0;
+	for (i = 0; i < h1->np; i++) {
+		if (isin[i]) {
+			si[n] = t1.surfind[i];
+			n++;
+		}
 	}
-    }
-    return ELIO_OK;
+	t2->surfind = si;
+	t2->d = (float *) malloc(h2->nitems * sizeof(float));
+	n = 0;
+	for (i = 0; i < h1->np; i++) {
+		if (isin[i]) {
+			for (j = 0; j < h1->nvrt - h1->bi[i]; j++) {
+				t2->d[n] = t1.d[h1->no[i] + j];
+				n++;
+			}
+		}
+	}
+	return ELIO_OK;
 }
 
 /*!
  * Routines to determine if a point lies in a polygon
-*/
+ */
 int ElioIntersectToLeft(double x, double y, double x1, double y1, double x2, double y2)
 {
-    double xtmp, m, b;
+	double xtmp, m, b;
 
-    /* ignore horizontal lines */
-    if (y1 == y2) {
-	return 0;
-    }
-    /* not contained vertically */
-    if (((y < y1) && (y < y2)) || ((y > y1) && (y > y2))) {
-	return 0;
-    }
-    /* none of the above, compute the intersection */
-    if ((xtmp = x2 - x1) != 0.0) {
-	m = (y2 - y1) / xtmp;
-	b = y1 - m * x1;
-	xtmp = (y - b) / m;
-    } else {
-	xtmp = x1;
-    }
-    if (xtmp <= x) {
-	/* check for intersections at a vertex */
-	/* if this is the max ordinate then accept */
-	if (y == y1) {
-	    if (y1 > y2) {
-		return 1;
-	    } else {
+	/* ignore horizontal lines */
+	if (y1 == y2) {
 		return 0;
-	    }
 	}
-	/* check for intersections at a vertex */
-	if (y == y2) {
-	    if (y2 > y1) {
-		return 1;
-	    } else {
+	/* not contained vertically */
+	if (((y < y1) && (y < y2)) || ((y > y1) && (y > y2))) {
 		return 0;
-	    }
 	}
-	/* no vertices intersected */
-	return 1;
-    }
-    return 0;
+	/* none of the above, compute the intersection */
+	if ((xtmp = x2 - x1) != 0.0) {
+		m = (y2 - y1) / xtmp;
+		b = y1 - m * x1;
+		xtmp = (y - b) / m;
+	}
+	else {
+		xtmp = x1;
+	}
+	if (xtmp <= x) {
+		/* check for intersections at a vertex */
+		/* if this is the max ordinate then accept */
+		if (y == y1) {
+			if (y1 > y2) {
+				return 1;
+			}
+			else {
+				return 0;
+			}
+		}
+		/* check for intersections at a vertex */
+		if (y == y2) {
+			if (y2 > y1) {
+				return 1;
+			}
+			else {
+				return 0;
+			}
+		}
+		/* no vertices intersected */
+		return 1;
+	}
+	return 0;
 }
 
 /*!
@@ -1717,19 +1756,18 @@
  */
 int ElioInPolygon(double x, double y, int n, double *xlist, double *ylist)
 {
-    int i, l = 0;// ll = 0;
+	int i, l = 0;   // ll = 0;
 
-    for (i = 0; i < n; i++) {
-	if ((y < ylist[i] && y < ylist[(i + 1) % n])
-	    || (y > ylist[i] && y > ylist[(i + 1) % n])) {
-	    continue;
-	}
-	if ((x < xlist[i] && x < xlist[(i + 1) % n])) {
-	    continue;
-	}
-	l += ElioIntersectToLeft(x, y, xlist[i], ylist[i], xlist[(i + 1) % n], ylist[(i + 1) % n]);
-    }
-    return l % 2;
+	for (i = 0; i < n; i++) {
+		if ((y < ylist[i] && y < ylist[(i + 1) % n]) || (y > ylist[i] && y > ylist[(i + 1) % n])) {
+			continue;
+		}
+		if ((x < xlist[i] && x < xlist[(i + 1) % n])) {
+			continue;
+		}
+		l += ElioIntersectToLeft(x, y, xlist[i], ylist[i], xlist[(i + 1) % n], ylist[(i + 1) % n]);
+	}
+	return l % 2;
 }
 
 /*!
@@ -1740,25 +1778,26 @@
  */
 int ElioFindElementXY(ElcircHeader * h, double xp, double yp)
 {
-    int i, j;
-    //int n0, n1, n2, n3;
-    double x[4], y[4];
-    for (i = 0; i < h->ne; i++) {
-	for (j = 0; j < h->etype[i]; j++) {
-	    x[j] = h->x[h->icon[j][i]];
-	    y[j] = h->y[h->icon[j][i]];
-	}
-	if (h->etype[i] == 3) {
-	    if (ElioInsideElement(xp, yp, x[0], y[0], x[1], y[1], x[2], y[2])) {
-		return i;
-	    }
-	} else {
-	    if (ElioInsideElement4(xp, yp, x[0], y[0], x[1], y[1], x[2], y[2], x[3], y[3])) {
-		return i;
-	    }
+	int i, j;
+	//int n0, n1, n2, n3;
+	double x[4], y[4];
+	for (i = 0; i < h->ne; i++) {
+		for (j = 0; j < h->etype[i]; j++) {
+			x[j] = h->x[h->icon[j][i]];
+			y[j] = h->y[h->icon[j][i]];
+		}
+		if (h->etype[i] == 3) {
+			if (ElioInsideElement(xp, yp, x[0], y[0], x[1], y[1], x[2], y[2])) {
+				return i;
+			}
+		}
+		else {
+			if (ElioInsideElement4(xp, yp, x[0], y[0], x[1], y[1], x[2], y[2], x[3], y[3])) {
+				return i;
+			}
+		}
 	}
-    }
-    return -1;
+	return -1;
 }
 
 /*!
@@ -1771,7 +1810,7 @@
  */
 void ElioSetInsideElementTol(double tol)
 {
-    ElioInsideElementTol = -tol;
+	ElioInsideElementTol = -tol;
 }
 
 /*!
@@ -1779,29 +1818,23 @@
  */
 int ElioInsideElement(double x, double y, double x1, double y1, double x2, double y2, double x3, double y3)
 {
-    if ((x - x1) * (y1 - y2) + (y - y1) * (x2 - x1) < ElioInsideElementTol)
-	return 0;
-    if ((x - x2) * (y2 - y3) + (y - y2) * (x3 - x2) < ElioInsideElementTol)
-	return 0;
-    if ((x - x3) * (y3 - y1) + (y - y3) * (x1 - x3) < ElioInsideElementTol)
-	return 0;
-    return 1;
+	if ((x - x1) * (y1 - y2) + (y - y1) * (x2 - x1) < ElioInsideElementTol) return 0;
+	if ((x - x2) * (y2 - y3) + (y - y2) * (x3 - x2) < ElioInsideElementTol) return 0;
+	if ((x - x3) * (y3 - y1) + (y - y3) * (x1 - x3) < ElioInsideElementTol) return 0;
+	return 1;
 }
 
 /*!
  * Determine if (x, y) is inside the convex quadrangle given by (x1, y1), (x2, y2), (x3, y3), (x4, y4).
  */
-int ElioInsideElement4(double x, double y, double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4)
+int ElioInsideElement4(double x, double y, double x1, double y1, double x2, double y2, double x3, double y3, double x4,
+		double y4)
 {
-    if ((x - x1) * (y1 - y2) + (y - y1) * (x2 - x1) < ElioInsideElementTol)
-	return 0;
-    if ((x - x2) * (y2 - y3) + (y - y2) * (x3 - x2) < ElioInsideElementTol)
-	return 0;
-    if ((x - x3) * (y3 - y4) + (y - y3) * (x4 - x3) < ElioInsideElementTol)
-	return 0;
-    if ((x - x4) * (y4 - y1) + (y - y4) * (x1 - x4) < ElioInsideElementTol)
-	return 0;
-    return 1;
+	if ((x - x1) * (y1 - y2) + (y - y1) * (x2 - x1) < ElioInsideElementTol) return 0;
+	if ((x - x2) * (y2 - y3) + (y - y2) * (x3 - x2) < ElioInsideElementTol) return 0;
+	if ((x - x3) * (y3 - y4) + (y - y3) * (x4 - x3) < ElioInsideElementTol) return 0;
+	if ((x - x4) * (y4 - y1) + (y - y4) * (x1 - x4) < ElioInsideElementTol) return 0;
+	return 1;
 }
 
 /*!
@@ -1816,46 +1849,49 @@
  */
 int ElioEvalFlowXY(int n, double *h, double *u, double *v, double *uret, double *vret)
 {
-    int i;
-    *uret = 0.0;
-    *vret = 0.0;
-    if (n != 3 && n != 4) {
-	return 1;
-    } else {
-	for (i = 0; i < n; i++) {
-	    *uret += h[i] * u[i];
-	    *vret += h[i] * v[i];
+	int i;
+	*uret = 0.0;
+	*vret = 0.0;
+	if (n != 3 && n != 4) {
+		return 1;
+	}
+	else {
+		for (i = 0; i < n; i++) {
+			*uret += h[i] * u[i];
+			*vret += h[i] * v[i];
+		}
 	}
-    }
-    return ELIO_OK;
+	return ELIO_OK;
 }
 
 int ElioEval(int n, double *h, double *c, double *uret)
 {
-    int i;
-    *uret = 0.0;
-    if (n != 3 && n != 4) {
-	return 1;
-    } else {
-	for (i = 0; i < n; i++) {
-	    *uret += h[i] * c[i];
+	int i;
+	*uret = 0.0;
+	if (n != 3 && n != 4) {
+		return 1;
 	}
-    }
-    return ELIO_OK;
+	else {
+		for (i = 0; i < n; i++) {
+			*uret += h[i] * c[i];
+		}
+	}
+	return ELIO_OK;
 }
 
 int ElioEvalScalarXY(int n, double *h, double *c, double *uret)
 {
-    int i;
-    *uret = 0.0;
-    if (n != 3 && n != 4) {
-	return 1;
-    } else {
-	for (i = 0; i < n; i++) {
-	    *uret += h[i] * c[i];
+	int i;
+	*uret = 0.0;
+	if (n != 3 && n != 4) {
+		return 1;
+	}
+	else {
+		for (i = 0; i < n; i++) {
+			*uret += h[i] * c[i];
+		}
 	}
-    }
-    return ELIO_OK;
+	return ELIO_OK;
 }
 
 /*! Compute coefficients for interpolation for both triangles and quads using
@@ -1871,97 +1907,99 @@
  */
 int ElioGetCoefficients(ElcircHeader * h, int elem, double xp, double yp, double *w)
 {
-    double aum, ado, atr, bum, bdo, btr, cum, cdo, ctr;
-    double x1, y1, x2, y2, x3, y3, x4, y4,  arei;//c1, c2, c3,
-    double xi, eta;
-    int nn[4];
-    nn[0] = h->icon[0][elem];
-    nn[1] = h->icon[1][elem];
-    nn[2] = h->icon[2][elem];
-    x1 = h->x[nn[0]];
-    y1 = h->y[nn[0]];
-    x2 = h->x[nn[1]];
-    y2 = h->y[nn[1]];
-    x3 = h->x[nn[2]];
-    y3 = h->y[nn[2]];
-    if (h->etype[elem] == 3) {
-	aum = x2 * y3 - x3 * y2;
-	bum = y2 - y3;
-	cum = x3 - x2;
-	ado = x3 * y1 - x1 * y3;
-	bdo = y3 - y1;
-	cdo = x1 - x3;
-	atr = x1 * y2 - x2 * y1;
-	btr = y1 - y2;
-	ctr = x2 - x1;
-	arei = 1.0 / (aum + ado + atr);
-	w[2] = (atr + btr * xp + ctr * yp) * arei;
-	w[1] = (ado + bdo * xp + cdo * yp) * arei;
-	w[0] = 1.0 - w[1] - w[2];
-	return ELIO_OK;
-    } else {
-	nn[3] = h->icon[3][elem];
-	x4 = h->x[nn[3]];
-	y4 = h->y[nn[3]];
-	ibilinear(x1, x2, x3, x4, y1, y2, y3, y4, xp, yp, &xi, &eta, w);
-	return ELIO_OK;
-    }
-    return ELIO_ERR;
+	double aum, ado, atr, bum, bdo, btr, cum, cdo, ctr;
+	double x1, y1, x2, y2, x3, y3, x4, y4, arei;   //c1, c2, c3,
+	double xi, eta;
+	int nn[4];
+	nn[0] = h->icon[0][elem];
+	nn[1] = h->icon[1][elem];
+	nn[2] = h->icon[2][elem];
+	x1 = h->x[nn[0]];
+	y1 = h->y[nn[0]];
+	x2 = h->x[nn[1]];
+	y2 = h->y[nn[1]];
+	x3 = h->x[nn[2]];
+	y3 = h->y[nn[2]];
+	if (h->etype[elem] == 3) {
+		aum = x2 * y3 - x3 * y2;
+		bum = y2 - y3;
+		cum = x3 - x2;
+		ado = x3 * y1 - x1 * y3;
+		bdo = y3 - y1;
+		cdo = x1 - x3;
+		atr = x1 * y2 - x2 * y1;
+		btr = y1 - y2;
+		ctr = x2 - x1;
+		arei = 1.0 / (aum + ado + atr);
+		w[2] = (atr + btr * xp + ctr * yp) * arei;
+		w[1] = (ado + bdo * xp + cdo * yp) * arei;
+		w[0] = 1.0 - w[1] - w[2];
+		return ELIO_OK;
+	}
+	else {
+		nn[3] = h->icon[3][elem];
+		x4 = h->x[nn[3]];
+		y4 = h->y[nn[3]];
+		ibilinear(x1, x2, x3, x4, y1, y2, y3, y4, xp, yp, &xi, &eta, w);
+		return ELIO_OK;
+	}
+	return ELIO_ERR;
 }
 
 /*! Compute coefficients for interpolation for both triangles and quads using
  * information from the element number.
- * 
+ *
  *  \param h Header struct to write.
  *  \param elem  Number of the element from 0.
  *  \param xp X-coordinate of point for interpolation.
  *  \param yp Y-coordinate of point for interpolation.
  *  \param w Coefficients of interpolator.
- * 
+ *
  *  Returns ELIO_OK on success and ELIO_ERR on failure.
  */
 
 int ElioGetCoefficientsGrid(ElioGrid * g, int elem, double xp, double yp, double *w)
 {
-    double aum, ado, atr, bum, bdo, btr, cum, cdo, ctr;
-    double x1, y1, x2, y2, x3, y3, x4, y4, arei;//c1, c2, c3, 
-    double xi, eta;
-    int nn[4];
-    if (g == NULL || elem < 0 || elem >= g->ne) {
+	double aum, ado, atr, bum, bdo, btr, cum, cdo, ctr;
+	double x1, y1, x2, y2, x3, y3, x4, y4, arei;   //c1, c2, c3,
+	double xi, eta;
+	int nn[4];
+	if (g == NULL || elem < 0 || elem >= g->ne) {
+		return ELIO_ERR;
+	}
+	nn[0] = g->icon[0][elem];
+	nn[1] = g->icon[1][elem];
+	nn[2] = g->icon[2][elem];
+	x1 = g->x[nn[0]];
+	y1 = g->y[nn[0]];
+	x2 = g->x[nn[1]];
+	y2 = g->y[nn[1]];
+	x3 = g->x[nn[2]];
+	y3 = g->y[nn[2]];
+	if (g->etype[elem] == 3) {
+		aum = x2 * y3 - x3 * y2;
+		bum = y2 - y3;
+		cum = x3 - x2;
+		ado = x3 * y1 - x1 * y3;
+		bdo = y3 - y1;
+		cdo = x1 - x3;
+		atr = x1 * y2 - x2 * y1;
+		btr = y1 - y2;
+		ctr = x2 - x1;
+		arei = 1.0 / (aum + ado + atr);
+		w[2] = (atr + btr * xp + ctr * yp) * arei;
+		w[1] = (ado + bdo * xp + cdo * yp) * arei;
+		w[0] = 1.0 - w[1] - w[2];
+		return ELIO_OK;
+	}
+	else {
+		nn[3] = g->icon[3][elem];
+		x4 = g->x[nn[3]];
+		y4 = g->y[nn[3]];
+		ibilinear(x1, x2, x3, x4, y1, y2, y3, y4, xp, yp, &xi, &eta, w);
+		return ELIO_OK;
+	}
 	return ELIO_ERR;
-    }
-    nn[0] = g->icon[0][elem];
-    nn[1] = g->icon[1][elem];
-    nn[2] = g->icon[2][elem];
-    x1 = g->x[nn[0]];
-    y1 = g->y[nn[0]];
-    x2 = g->x[nn[1]];
-    y2 = g->y[nn[1]];
-    x3 = g->x[nn[2]];
-    y3 = g->y[nn[2]];
-    if (g->etype[elem] == 3) {
-	aum = x2 * y3 - x3 * y2;
-	bum = y2 - y3;
-	cum = x3 - x2;
-	ado = x3 * y1 - x1 * y3;
-	bdo = y3 - y1;
-	cdo = x1 - x3;
-	atr = x1 * y2 - x2 * y1;
-	btr = y1 - y2;
-	ctr = x2 - x1;
-	arei = 1.0 / (aum + ado + atr);
-	w[2] = (atr + btr * xp + ctr * yp) * arei;
-	w[1] = (ado + bdo * xp + cdo * yp) * arei;
-	w[0] = 1.0 - w[1] - w[2];
-	return ELIO_OK;
-    } else {
-	nn[3] = g->icon[3][elem];
-	x4 = g->x[nn[3]];
-	y4 = g->y[nn[3]];
-	ibilinear(x1, x2, x3, x4, y1, y2, y3, y4, xp, yp, &xi, &eta, w);
-	return ELIO_OK;
-    }
-    return ELIO_ERR;
 }
 
 /*! Compute coefficients for interpolation for both triangles and quads using
@@ -1978,98 +2016,99 @@
  */
 int ElioGetCoefficientsXY(int n, double *x, double *y, double xp, double yp, double *w)
 {
-    double aum, ado, atr, bum, bdo, btr, cum, cdo, ctr;
-    double x1, y1, x2, y2, x3, y3, x4, y4,  arei;//c1, c2, c3,
-    double xi, eta;
-    x1 = x[0];
-    y1 = y[0];
-    x2 = x[1];
-    y2 = y[1];
-    x3 = x[2];
-    y3 = y[2];
-    if (n == 3) {
-	aum = x2 * y3 - x3 * y2;
-	bum = y2 - y3;
-	cum = x3 - x2;
-	ado = x3 * y1 - x1 * y3;
-	bdo = y3 - y1;
-	cdo = x1 - x3;
-	atr = x1 * y2 - x2 * y1;
-	btr = y1 - y2;
-	ctr = x2 - x1;
-	arei = 1.0 / (aum + ado + atr);
-	w[2] = (atr + btr * xp + ctr * yp) * arei;
-	w[1] = (ado + bdo * xp + cdo * yp) * arei;
-	w[0] = 1.0 - w[1] - w[2];
-	return ELIO_OK;
-    }
-    if (n == 4) {
-	x4 = x[3];
-	y4 = y[3];
-	ibilinear(x1, x2, x3, x4, y1, y2, y3, y4, xp, yp, &xi, &eta, w);
-	return ELIO_OK;
-    } else {
+	double aum, ado, atr, bum, bdo, btr, cum, cdo, ctr;
+	double x1, y1, x2, y2, x3, y3, x4, y4, arei;   //c1, c2, c3,
+	double xi, eta;
+	x1 = x[0];
+	y1 = y[0];
+	x2 = x[1];
+	y2 = y[1];
+	x3 = x[2];
+	y3 = y[2];
+	if (n == 3) {
+		aum = x2 * y3 - x3 * y2;
+		bum = y2 - y3;
+		cum = x3 - x2;
+		ado = x3 * y1 - x1 * y3;
+		bdo = y3 - y1;
+		cdo = x1 - x3;
+		atr = x1 * y2 - x2 * y1;
+		btr = y1 - y2;
+		ctr = x2 - x1;
+		arei = 1.0 / (aum + ado + atr);
+		w[2] = (atr + btr * xp + ctr * yp) * arei;
+		w[1] = (ado + bdo * xp + cdo * yp) * arei;
+		w[0] = 1.0 - w[1] - w[2];
+		return ELIO_OK;
+	}
+	if (n == 4) {
+		x4 = x[3];
+		y4 = y[3];
+		ibilinear(x1, x2, x3, x4, y1, y2, y3, y4, xp, yp, &xi, &eta, w);
+		return ELIO_OK;
+	}
+	else {
+		return ELIO_ERR;
+	}
 	return ELIO_ERR;
-    }
-    return ELIO_ERR;
 }
 
 /*!
  * Define a header for the surface.
-*/
+ */
 int ElioGetSurfaceHeader(ElcircHeader * h1, ElcircHeader * h2)
 {
-    int i;// j;
-    strncpy(h2->magic, h1->magic, 48);
-    strncpy(h2->version, h1->version, 48);
-    strncpy(h2->start_time, h1->start_time, 48);
-    strncpy(h2->variable_nm, h1->variable_nm, 48);
-    strncpy(h2->variable_dim, h1->variable_dim, 48);
-    h2->nsteps = h1->nsteps;
-    h2->timestep = h1->timestep;
-    h2->skip = h1->skip;
-    h2->ivs = h1->ivs;
-    h2->i23d = h1->i23d;
-    h2->vpos = h1->vpos;
-    h2->zmsl = h1->zmsl;
-    h2->nvrt = h1->nvrt;
-    h2->zcor = (float *) malloc(h1->nvrt * sizeof(float));
-    for (i = 0; i < h1->nvrt; i++) {
-	h2->zcor = h1->zcor;
-    }
-    h2->np = h1->np;
-    h2->ne = h1->ne;
-    h2->x = (float *) malloc(h1->np * sizeof(float));
-    h2->y = (float *) malloc(h1->np * sizeof(float));
-    h2->d = (float *) malloc(h1->np * sizeof(float));
-    h2->bi = (int *) malloc(h1->np * sizeof(int));
-    h2->no = (int *) malloc(h1->np * sizeof(int));	/* offset into data for each node */
-    for (i = 0; i < h1->np; i++) {
-	h2->x[i] = h1->x[i];
-	h2->y[i] = h1->y[i];
-	h2->d[i] = h1->d[i];
-	h2->bi[i] = h1->bi[i];
-    }
-    h2->icon[0] = (int *) malloc(h1->ne * sizeof(int));
-    h2->icon[1] = (int *) malloc(h1->ne * sizeof(int));
-    h2->icon[2] = (int *) malloc(h1->ne * sizeof(int));
-    for (i = 0; i < h1->ne; i++) {
-	h2->icon[0][i] = h1->icon[0][i];
-	h2->icon[1][i] = h1->icon[0][i];
-	h2->icon[2][i] = h1->icon[0][i];
-    }
-/* compute size of data in time step and offsets to each node */
-    h2->nitems = 0;
-    for (i = 0; i < h1->np; i++) {
-	h2->bi[i] = 1;
-	h2->no[i] = h2->nitems;
-	h2->nitems += 1;
-    }
-/* get the header size in bytes */
-    /*h2->hsize = ftello(fp); */
-/* get time step size in bytes */
-    h2->ssize = 8 + h2->np * 4 + h2->nitems * 4;
-    return ELIO_OK;
+	int i;   // j;
+	strncpy(h2->magic, h1->magic, 48);
+	strncpy(h2->version, h1->version, 48);
+	strncpy(h2->start_time, h1->start_time, 48);
+	strncpy(h2->variable_nm, h1->variable_nm, 48);
+	strncpy(h2->variable_dim, h1->variable_dim, 48);
+	h2->nsteps = h1->nsteps;
+	h2->timestep = h1->timestep;
+	h2->skip = h1->skip;
+	h2->ivs = h1->ivs;
+	h2->i23d = h1->i23d;
+	h2->vpos = h1->vpos;
+	h2->zmsl = h1->zmsl;
+	h2->nvrt = h1->nvrt;
+	h2->zcor = (float *) malloc(h1->nvrt * sizeof(float));
+	for (i = 0; i < h1->nvrt; i++) {
+		h2->zcor = h1->zcor;
+	}
+	h2->np = h1->np;
+	h2->ne = h1->ne;
+	h2->x = (float *) malloc(h1->np * sizeof(float));
+	h2->y = (float *) malloc(h1->np * sizeof(float));
+	h2->d = (float *) malloc(h1->np * sizeof(float));
+	h2->bi = (int *) malloc(h1->np * sizeof(int));
+	h2->no = (int *) malloc(h1->np * sizeof(int)); /* offset into data for each node */
+	for (i = 0; i < h1->np; i++) {
+		h2->x[i] = h1->x[i];
+		h2->y[i] = h1->y[i];
+		h2->d[i] = h1->d[i];
+		h2->bi[i] = h1->bi[i];
+	}
+	h2->icon[0] = (int *) malloc(h1->ne * sizeof(int));
+	h2->icon[1] = (int *) malloc(h1->ne * sizeof(int));
+	h2->icon[2] = (int *) malloc(h1->ne * sizeof(int));
+	for (i = 0; i < h1->ne; i++) {
+		h2->icon[0][i] = h1->icon[0][i];
+		h2->icon[1][i] = h1->icon[0][i];
+		h2->icon[2][i] = h1->icon[0][i];
+	}
+	/* compute size of data in time step and offsets to each node */
+	h2->nitems = 0;
+	for (i = 0; i < h1->np; i++) {
+		h2->bi[i] = 1;
+		h2->no[i] = h2->nitems;
+		h2->nitems += 1;
+	}
+	/* get the header size in bytes */
+	/*h2->hsize = ftello(fp); */
+	/* get time step size in bytes */
+	h2->ssize = 8 + h2->np * 4 + h2->nitems * 4;
+	return ELIO_OK;
 }
 
 /*!
@@ -2077,7 +2116,7 @@
  */
 int ElioGetSurfaceStep(ElcircHeader * h1, ElcircHeader * h2, ElcircTimeStep t1, ElcircTimeStep * t2)
 {
-    return ELIO_OK;
+	return ELIO_OK;
 }
 
 /*!
@@ -2085,56 +2124,57 @@
  */
 int ElioGetBottomHeader(ElcircHeader * h1, ElcircHeader * h2)
 {
-    return ELIO_OK;
+	return ELIO_OK;
 }
 
 /*! Not implemented.
  */
 int ElioGetBottomStep(ElcircHeader * h1, ElcircHeader * h2, ElcircTimeStep t1, ElcircTimeStep * t2)
 {
-    return ELIO_OK;
+	return ELIO_OK;
 }
 
 /*! Not implemented.
  */
 int ElioGetTransectHeader(ElcircHeader * h1, int n, double *x, double *y, ElcircHeader * h2)
 {
-    return ELIO_OK;
+	return ELIO_OK;
 }
 
 /*! Not implemented.
  */
-int ElioGetTransectStep(ElcircHeader * h1, ElcircHeader * h2, int step, int n, double *x, double *y, ElcircTimeStep t1, ElcircTimeStep * t2)
+int ElioGetTransectStep(ElcircHeader * h1, ElcircHeader * h2, int step, int n, double *x, double *y, ElcircTimeStep t1,
+		ElcircTimeStep * t2)
 {
-    return ELIO_OK;
+	return ELIO_OK;
 }
 
 /*! Not implemented.
  */
 int ElioGetLevelHeader(ElcircHeader * h1, ElcircHeader * h2)
 {
-    return ELIO_OK;
+	return ELIO_OK;
 }
 
 /*! Not implemented.
  */
 int ElioGetLevelStep(ElcircHeader * h1, ElcircHeader * h2, ElcircTimeStep t1, int level, ElcircTimeStep * t2)
 {
-    return ELIO_OK;
+	return ELIO_OK;
 }
 
 /*! Not implemented.
  */
 int ElioGetZLevelHeader(ElcircHeader * h1, ElcircHeader * h2)
 {
-    return ELIO_OK;
+	return ELIO_OK;
 }
 
 /*! Not implemented.
  */
 int ElioGetZLevelStep(ElcircHeader * h1, ElcircHeader * h2, ElcircTimeStep t1, float z, ElcircTimeStep * t2)
 {
-    return ELIO_OK;
+	return ELIO_OK;
 }
 
 /*! Write the ELCIRC header.
@@ -2146,92 +2186,66 @@
  */
 int ElioPutHeader(FILE * fp, ElcircHeader * h)
 {
-    int  i, j, bitmp, etmp;//*itmp,
-    if (fp == NULL) {
-	fprintf(stderr, "Bad file pointer\n");
-	return ELIO_ERR;
-    }
-    /*if (!(strncmp(h->magic, "DataFormat v3.0", 15) == 0)) {
-       fprintf(stderr, "ElioPutHeader(): Version identifier %s, must be 'DataFormat v3.0'\n", h->magic);
-       return (ELIO_ERR);
-       } */
-    if (fwrite(h->magic, sizeof(char), 48, fp) != 48)
-	return ELIO_FWRITE_ERR;
-    h->magic[48] = 0;
-    if (fseeko(fp, 48L, SEEK_SET)) {
-	return ELIO_FSEEK_ERR;
-    }
-    if (fwrite(h->version, sizeof(char), 48, fp) != 48)
-	return ELIO_FWRITE_ERR;
-    h->version[48] = 0;
-    if (fwrite(h->start_time, sizeof(char), 48, fp) != 48)
-	return ELIO_FWRITE_ERR;
-    h->start_time[48] = 0;
-    if (fwrite(h->variable_nm, sizeof(char), 48, fp) != 48)
-	return ELIO_FWRITE_ERR;
-    h->variable_nm[48] = 0;
-    if (fwrite(h->variable_dim, sizeof(char), 48, fp) != 48)
-	return ELIO_FWRITE_ERR;
-    h->variable_dim[48] = 0;
-    if (fwrite(&h->nsteps, sizeof(int), 1, fp) != 1)
-	return ELIO_FWRITE_ERR;
-    if (fwrite(&h->timestep, sizeof(float), 1, fp) != 1)
-	return ELIO_FWRITE_ERR;
-    if (fwrite(&h->skip, sizeof(int), 1, fp) != 1)
-	return ELIO_FWRITE_ERR;
-    if (fwrite(&h->ivs, sizeof(int), 1, fp) != 1)
-	return ELIO_FWRITE_ERR;
-    if (fwrite(&h->i23d, sizeof(int), 1, fp) != 1)
-	return ELIO_FWRITE_ERR;
-    if (h->v == 3) {
-	if (fwrite(&h->vpos, sizeof(float), 1, fp) != 1)
-	    return ELIO_FWRITE_ERR;
-	if (fwrite(&h->zmsl, sizeof(float), 1, fp) != 1)
-	    return ELIO_FWRITE_ERR;
-    } else if (h->v == 4) {
-	if (fwrite(&h->ivcor, sizeof(int), 1, fp) != 1)
-	    return ELIO_FWRITE_ERR;
-	if (fwrite(&h->h0, sizeof(float), 1, fp) != 1)
-	    return ELIO_FWRITE_ERR;
-	if (fwrite(&h->hc, sizeof(float), 1, fp) != 1)
-	    return ELIO_FWRITE_ERR;
-	if (fwrite(&h->thetab, sizeof(float), 1, fp) != 1)
-	    return ELIO_FWRITE_ERR;
-	if (fwrite(&h->thetaf, sizeof(float), 1, fp) != 1)
-	    return ELIO_FWRITE_ERR;
-    }
-    if (fwrite(&h->nvrt, sizeof(int), 1, fp) != 1)
-	return ELIO_FWRITE_ERR;
-    if (fwrite(h->zcor, sizeof(float), h->nvrt, fp) != h->nvrt)
-	return ELIO_FWRITE_ERR;
-    if (fwrite(&h->np, sizeof(int), 1, fp) != 1)
-	return ELIO_FWRITE_ERR;
-    if (fwrite(&h->ne, sizeof(int), 1, fp) != 1)
-	return ELIO_FWRITE_ERR;
-    for (i = 0; i < h->np; i++) {
-	if (fwrite(h->x + i, sizeof(float), 1, fp) != 1)
-	    return ELIO_FWRITE_ERR;
-	if (fwrite(h->y + i, sizeof(float), 1, fp) != 1)
-	    return ELIO_FWRITE_ERR;
-	if (fwrite(h->d + i, sizeof(float), 1, fp) != 1)
-	    return ELIO_FWRITE_ERR;
-	if (h->v != 4) {
-	    bitmp = h->bi[i] + 1;	/* subtracted 1 previously, have to add it back */
-	    if (fwrite(&bitmp, sizeof(int), 1, fp) != 1)
-		return ELIO_FWRITE_ERR;
-	}
-    }
-    /* for hybrid grids */
-    for (i = 0; i < h->ne; i++) {
-	if (fwrite(&h->etype[i], sizeof(int), 1, fp) != 1)
-	    return ELIO_FWRITE_ERR;
-	for (j = 0; j < h->etype[i]; j++) {
-	    etmp = h->icon[j][i] + 1;	/* node number start from 0 internally, need to add 1 */
-	    if (fwrite(&etmp, sizeof(int), 1, fp) != 1)
-		return ELIO_FWRITE_ERR;
+	int i, j, bitmp, etmp;   //*itmp,
+	if (fp == NULL ) {
+		fprintf(stderr, "Bad file pointer\n");
+		return ELIO_ERR;
 	}
-    }
-    return ELIO_OK;
+	/*if (!(strncmp(h->magic, "DataFormat v3.0", 15) == 0)) {
+	 fprintf(stderr, "ElioPutHeader(): Version identifier %s, must be 'DataFormat v3.0'\n", h->magic);
+	 return (ELIO_ERR);
+	 } */
+	if (fwrite(h->magic, sizeof(char), 48, fp) != 48) return ELIO_FWRITE_ERR;
+	h->magic[48] = 0;
+	if (fseeko(fp, 48L, SEEK_SET)) {
+		return ELIO_FSEEK_ERR;
+	}
+	if (fwrite(h->version, sizeof(char), 48, fp) != 48) return ELIO_FWRITE_ERR;
+	h->version[48] = 0;
+	if (fwrite(h->start_time, sizeof(char), 48, fp) != 48) return ELIO_FWRITE_ERR;
+	h->start_time[48] = 0;
+	if (fwrite(h->variable_nm, sizeof(char), 48, fp) != 48) return ELIO_FWRITE_ERR;
+	h->variable_nm[48] = 0;
+	if (fwrite(h->variable_dim, sizeof(char), 48, fp) != 48) return ELIO_FWRITE_ERR;
+	h->variable_dim[48] = 0;
+	if (fwrite(&h->nsteps, sizeof(int), 1, fp) != 1) return ELIO_FWRITE_ERR;
+	if (fwrite(&h->timestep, sizeof(float), 1, fp) != 1) return ELIO_FWRITE_ERR;
+	if (fwrite(&h->skip, sizeof(int), 1, fp) != 1) return ELIO_FWRITE_ERR;
+	if (fwrite(&h->ivs, sizeof(int), 1, fp) != 1) return ELIO_FWRITE_ERR;
+	if (fwrite(&h->i23d, sizeof(int), 1, fp) != 1) return ELIO_FWRITE_ERR;
+	if (h->v == 3) {
+		if (fwrite(&h->vpos, sizeof(float), 1, fp) != 1) return ELIO_FWRITE_ERR;
+		if (fwrite(&h->zmsl, sizeof(float), 1, fp) != 1) return ELIO_FWRITE_ERR;
+	}
+	else if (h->v == 4) {
+		if (fwrite(&h->ivcor, sizeof(int), 1, fp) != 1) return ELIO_FWRITE_ERR;
+		if (fwrite(&h->h0, sizeof(float), 1, fp) != 1) return ELIO_FWRITE_ERR;
+		if (fwrite(&h->hc, sizeof(float), 1, fp) != 1) return ELIO_FWRITE_ERR;
+		if (fwrite(&h->thetab, sizeof(float), 1, fp) != 1) return ELIO_FWRITE_ERR;
+		if (fwrite(&h->thetaf, sizeof(float), 1, fp) != 1) return ELIO_FWRITE_ERR;
+	}
+	if (fwrite(&h->nvrt, sizeof(int), 1, fp) != 1) return ELIO_FWRITE_ERR;
+	if (fwrite(h->zcor, sizeof(float), h->nvrt, fp) != h->nvrt) return ELIO_FWRITE_ERR;
+	if (fwrite(&h->np, sizeof(int), 1, fp) != 1) return ELIO_FWRITE_ERR;
+	if (fwrite(&h->ne, sizeof(int), 1, fp) != 1) return ELIO_FWRITE_ERR;
+	for (i = 0; i < h->np; i++) {
+		if (fwrite(h->x + i, sizeof(float), 1, fp) != 1) return ELIO_FWRITE_ERR;
+		if (fwrite(h->y + i, sizeof(float), 1, fp) != 1) return ELIO_FWRITE_ERR;
+		if (fwrite(h->d + i, sizeof(float), 1, fp) != 1) return ELIO_FWRITE_ERR;
+		if (h->v != 4) {
+			bitmp = h->bi[i] + 1; /* subtracted 1 previously, have to add it back */
+			if (fwrite(&bitmp, sizeof(int), 1, fp) != 1) return ELIO_FWRITE_ERR;
+		}
+	}
+	/* for hybrid grids */
+	for (i = 0; i < h->ne; i++) {
+		if (fwrite(&h->etype[i], sizeof(int), 1, fp) != 1) return ELIO_FWRITE_ERR;
+		for (j = 0; j < h->etype[i]; j++) {
+			etmp = h->icon[j][i] + 1; /* node number start from 0 internally, need to add 1 */
+			if (fwrite(&etmp, sizeof(int), 1, fp) != 1) return ELIO_FWRITE_ERR;
+		}
+	}
+	return ELIO_OK;
 }
 
 /*!
@@ -2243,21 +2257,17 @@
  */
 int ElioPutTimeStep(FILE * fp, ElcircHeader * h, ElcircTimeStep t)
 {
-    if (fwrite(&t.t, sizeof(float), 1, fp) != 1)
-	return ELIO_FWRITE_ERR;
-    if (fwrite(&t.it, sizeof(int), 1, fp) != 1)
-	return ELIO_FWRITE_ERR;
-    if (h->v != 4) {
-	if (fwrite(t.surfind, sizeof(int), h->np, fp) != h->np)
-	    return ELIO_FWRITE_ERR;
-    } else {
-	if (fwrite(t.e, sizeof(float), h->np, fp) != h->np)
-	    return ELIO_FWRITE_ERR;
-    }
-    if (fwrite(t.d, sizeof(float), h->nitems, fp) != h->nitems)
-	return ELIO_FWRITE_ERR;
-    //printf("Completed Write of Time Step: Time, Step = %f, %d\n", t.t, t.it);
-    return ELIO_OK;
+	if (fwrite(&t.t, sizeof(float), 1, fp) != 1) return ELIO_FWRITE_ERR;
+	if (fwrite(&t.it, sizeof(int), 1, fp) != 1) return ELIO_FWRITE_ERR;
+	if (h->v != 4) {
+		if (fwrite(t.surfind, sizeof(int), h->np, fp) != h->np) return ELIO_FWRITE_ERR;
+	}
+	else {
+		if (fwrite(t.e, sizeof(float), h->np, fp) != h->np) return ELIO_FWRITE_ERR;
+	}
+	if (fwrite(t.d, sizeof(float), h->nitems, fp) != h->nitems) return ELIO_FWRITE_ERR;
+	//printf("Completed Write of Time Step: Time, Step = %f, %d\n", t.t, t.it);
+	return ELIO_OK;
 }
 
 /*! Not implemented
@@ -2265,7 +2275,7 @@
  */
 int ElioPutHeaderOld(FILE * fp, ElcircHeader * h)
 {
-    return ELIO_OK;
+	return ELIO_OK;
 }
 
 /*! Not implemented
@@ -2273,34 +2283,37 @@
  */
 int ElioPutTimeStepOld(FILE * fp, ElcircHeader * h, ElcircTimeStep t)
 {
-    return ELIO_OK;
+	return ELIO_OK;
 }
 
 /*! Return the file type.
  *
  * Returns -1 on error.
-*/
+ */
 int ElioGetFileType(FILE * fp)
 {
-    char id[100];
-    int retval = -1;
-    if (fread(id, sizeof(char), 15, fp) != 15) {
-	return retval;
-    }
-    id[15] = 0;
-    if (fseeko(fp, 0L, SEEK_SET)) {
+	char id[100];
+	int retval = -1;
+	if (fread(id, sizeof(char), 15, fp) != 15) {
+		return retval;
+	}
+	id[15] = 0;
+	if (fseeko(fp, 0L, SEEK_SET)) {
+		return retval;
+	}
+	if (strcmp(id, "DataFormat v2.0") == 0) {
+		retval = 2;
+	}
+	else if (strcmp(id, "DataFormat v3.0") == 0) {
+		retval = 3;
+	}
+	else if (strcmp(id, "DataFormat v4.0") == 0) {
+		retval = 4;
+	}
+	else if (strcmp(id, "DataFormat v5.0") == 0) {
+		retval = 5;
+	}
 	return retval;
-    }
-    if (strcmp(id, "DataFormat v2.0") == 0) {
-	retval = 2;
-    } else if (strcmp(id, "DataFormat v3.0") == 0) {
-	retval = 3;
-    } else if (strcmp(id, "DataFormat v4.0") == 0) {
-	retval = 4;
-    } else if (strcmp(id, "DataFormat v5.0") == 0) {
-	retval = 5;
-    }
-    return retval;
 }
 
 /*!
@@ -2308,54 +2321,54 @@
  */
 int ElioCopyHeader(ElcircHeader * h1, ElcircHeader * h2)
 {
-    //FILE *fp;
-    int  i;//*itmp, j, ss;
-    *h2 = *h1;
-    memcpy(h2->magic, h1->magic, 48);
-    memcpy(h2->version, h1->version, 48);
-    memcpy(h2->start_time, h1->start_time, 48);
-    memcpy(h2->variable_nm, h1->variable_nm, 48);
-    memcpy(h2->variable_dim, h1->variable_dim, 48);
-    h2->nsteps = h1->nsteps;
-    h2->timestep = h1->timestep;
-    h2->skip = h1->skip;
-    h2->ivs = h1->ivs;
-    h2->i23d = h1->i23d;
-    h2->vpos = h1->vpos;
-    h2->sigma = h1->sigma;
-    h2->zmsl = h1->zmsl;
-    h2->nvrt = h1->nvrt;
-    h2->zcor = (float *) malloc(h1->nvrt * sizeof(float));
-    for (i = 0; i < h1->nvrt; i++) {
-	h2->zcor[i] = h2->zcor[i];
-    }
-    h2->np = h1->np;
-    h2->ne = h1->ne;
-    h2->x = (float *) malloc(h1->np * sizeof(float));
-    h2->y = (float *) malloc(h1->np * sizeof(float));
-    h2->d = (float *) malloc(h1->np * sizeof(float));
-    h2->bi = (int *) malloc(h1->np * sizeof(int));
-    h2->no = (int *) malloc(h1->np * sizeof(int));
-    memcpy(h2->x, h1->x, h1->np * sizeof(float));
-    memcpy(h2->y, h1->y, h1->np * sizeof(float));
-    memcpy(h2->d, h1->d, h1->np * sizeof(float));
-    memcpy(h2->bi, h1->bi, h1->np * sizeof(int));
-    h2->etype = (int *) malloc(h1->ne * sizeof(int));
-    memcpy(h2->etype, h1->etype, h1->ne * sizeof(int));
-    h2->icon[0] = (int *) malloc(h1->ne * sizeof(int));
-    h2->icon[1] = (int *) malloc(h1->ne * sizeof(int));
-    h2->icon[2] = (int *) malloc(h1->ne * sizeof(int));
-    h2->icon[3] = (int *) malloc(h1->ne * sizeof(int));
-    memcpy(h2->icon[0], h1->icon[0], h1->ne * sizeof(int));
-    memcpy(h2->icon[1], h1->icon[1], h1->ne * sizeof(int));
-    memcpy(h2->icon[2], h1->icon[2], h1->ne * sizeof(int));
-    memcpy(h2->icon[3], h1->icon[3], h1->ne * sizeof(int));
-    h2->nitems = h1->nitems;
-    memcpy(h2->bi, h1->bi, h1->np * sizeof(int));
-    memcpy(h2->no, h1->no, h1->np * sizeof(int));
-    h2->hsize = h1->hsize;
-    h2->ssize = h1->ssize;
-    return 0;
+	//FILE *fp;
+	int i;   //*itmp, j, ss;
+	*h2 = *h1;
+	memcpy(h2->magic, h1->magic, 48);
+	memcpy(h2->version, h1->version, 48);
+	memcpy(h2->start_time, h1->start_time, 48);
+	memcpy(h2->variable_nm, h1->variable_nm, 48);
+	memcpy(h2->variable_dim, h1->variable_dim, 48);
+	h2->nsteps = h1->nsteps;
+	h2->timestep = h1->timestep;
+	h2->skip = h1->skip;
+	h2->ivs = h1->ivs;
+	h2->i23d = h1->i23d;
+	h2->vpos = h1->vpos;
+	h2->sigma = h1->sigma;
+	h2->zmsl = h1->zmsl;
+	h2->nvrt = h1->nvrt;
+	h2->zcor = (float *) malloc(h1->nvrt * sizeof(float));
+	for (i = 0; i < h1->nvrt; i++) {
+		h2->zcor[i] = h2->zcor[i];
+	}
+	h2->np = h1->np;
+	h2->ne = h1->ne;
+	h2->x = (float *) malloc(h1->np * sizeof(float));
+	h2->y = (float *) malloc(h1->np * sizeof(float));
+	h2->d = (float *) malloc(h1->np * sizeof(float));
+	h2->bi = (int *) malloc(h1->np * sizeof(int));
+	h2->no = (int *) malloc(h1->np * sizeof(int));
+	memcpy(h2->x, h1->x, h1->np * sizeof(float));
+	memcpy(h2->y, h1->y, h1->np * sizeof(float));
+	memcpy(h2->d, h1->d, h1->np * sizeof(float));
+	memcpy(h2->bi, h1->bi, h1->np * sizeof(int));
+	h2->etype = (int *) malloc(h1->ne * sizeof(int));
+	memcpy(h2->etype, h1->etype, h1->ne * sizeof(int));
+	h2->icon[0] = (int *) malloc(h1->ne * sizeof(int));
+	h2->icon[1] = (int *) malloc(h1->ne * sizeof(int));
+	h2->icon[2] = (int *) malloc(h1->ne * sizeof(int));
+	h2->icon[3] = (int *) malloc(h1->ne * sizeof(int));
+	memcpy(h2->icon[0], h1->icon[0], h1->ne * sizeof(int));
+	memcpy(h2->icon[1], h1->icon[1], h1->ne * sizeof(int));
+	memcpy(h2->icon[2], h1->icon[2], h1->ne * sizeof(int));
+	memcpy(h2->icon[3], h1->icon[3], h1->ne * sizeof(int));
+	h2->nitems = h1->nitems;
+	memcpy(h2->bi, h1->bi, h1->np * sizeof(int));
+	memcpy(h2->no, h1->no, h1->np * sizeof(int));
+	h2->hsize = h1->hsize;
+	h2->ssize = h1->ssize;
+	return 0;
 }
 
 /*!
@@ -2368,30 +2381,31 @@
  */
 double ElioGetElementArea(ElcircHeader * h, int elem)
 {
-    int n1, n2, n3, n4;
-    double ar = 0.0;
-    double x1, y1, x2, y2, x3, y3, x4, y4;
-
-    if (elem >= 0 && elem < h->ne) {
-	n1 = h->icon[0][elem];
-	n2 = h->icon[1][elem];
-	n3 = h->icon[2][elem];
-	x1 = h->x[n1];
-	x2 = h->x[n2];
-	x3 = h->x[n3];
-	y1 = h->y[n1];
-	y2 = h->y[n2];
-	y3 = h->y[n3];
-	if (h->etype[elem] == 3) {
-	    ar = 0.5 * ((x1 * y2 - x2 * y1) + (x2 * y3 - x3 * y2) + (x3 * y1 - x1 * y3));
-	} else if (h->etype[elem] == 4) {
-	    n4 = h->icon[3][elem];
-	    x4 = h->x[n4];
-	    y4 = h->y[n4];
-	    ar = 0.5 * ((x1 * y2 - x2 * y1) + (x2 * y3 - x3 * y2) + (x3 * y4 - x4 * y3) + (x4 * y1 - x1 * y4));
+	int n1, n2, n3, n4;
+	double ar = 0.0;
+	double x1, y1, x2, y2, x3, y3, x4, y4;
+
+	if (elem >= 0 && elem < h->ne) {
+		n1 = h->icon[0][elem];
+		n2 = h->icon[1][elem];
+		n3 = h->icon[2][elem];
+		x1 = h->x[n1];
+		x2 = h->x[n2];
+		x3 = h->x[n3];
+		y1 = h->y[n1];
+		y2 = h->y[n2];
+		y3 = h->y[n3];
+		if (h->etype[elem] == 3) {
+			ar = 0.5 * ((x1 * y2 - x2 * y1) + (x2 * y3 - x3 * y2) + (x3 * y1 - x1 * y3));
+		}
+		else if (h->etype[elem] == 4) {
+			n4 = h->icon[3][elem];
+			x4 = h->x[n4];
+			y4 = h->y[n4];
+			ar = 0.5 * ((x1 * y2 - x2 * y1) + (x2 * y3 - x3 * y2) + (x3 * y4 - x4 * y3) + (x4 * y1 - x1 * y4));
+		}
 	}
-    }
-    return ar;
+	return ar;
 }
 
 /*!
@@ -2407,19 +2421,19 @@
  */
 int ElioGetElementCenter(ElcircHeader * h, int elem, double *cx, double *cy)
 {
-    int i, n;
-    if (!h || h->ne <= 0 || elem < 0 || (h->etype[elem] != 3 && h->etype[elem] != 4)) {
-	return ELIO_ERR;
-    }
-    *cx = *cy = 0.0;
-    for (i = 0; i < h->etype[elem]; i++) {
-	n = h->icon[i][elem];
-	*cx += h->x[n];
-	*cy += h->y[n];
-    }
-    *cx /= h->etype[elem];
-    *cy /= h->etype[elem];
-    return ELIO_OK;
+	int i, n;
+	if (!h || h->ne <= 0 || elem < 0 || (h->etype[elem] != 3 && h->etype[elem] != 4)) {
+		return ELIO_ERR;
+	}
+	*cx = *cy = 0.0;
+	for (i = 0; i < h->etype[elem]; i++) {
+		n = h->icon[i][elem];
+		*cx += h->x[n];
+		*cy += h->y[n];
+	}
+	*cx /= h->etype[elem];
+	*cy /= h->etype[elem];
+	return ELIO_OK;
 }
 
 /*!
@@ -2435,19 +2449,19 @@
  */
 int ElioGetGridElementCenter(ElioGrid * g, int elem, double *cx, double *cy)
 {
-    int i, n;
-    if (!g || g->ne <= 0 || elem < 0 || (g->etype[elem] != 3 && g->etype[elem] != 4)) {
-	return ELIO_ERR;
-    }
-    *cx = *cy = 0.0;
-    for (i = 0; i < g->etype[elem]; i++) {
-	n = g->icon[i][elem];
-	*cx += g->x[n];
-	*cy += g->y[n];
-    }
-    *cx /= g->etype[elem];
-    *cy /= g->etype[elem];
-    return ELIO_OK;
+	int i, n;
+	if (!g || g->ne <= 0 || elem < 0 || (g->etype[elem] != 3 && g->etype[elem] != 4)) {
+		return ELIO_ERR;
+	}
+	*cx = *cy = 0.0;
+	for (i = 0; i < g->etype[elem]; i++) {
+		n = g->icon[i][elem];
+		*cx += g->x[n];
+		*cy += g->y[n];
+	}
+	*cx /= g->etype[elem];
+	*cy /= g->etype[elem];
+	return ELIO_OK;
 }
 
 /*!
@@ -2460,160 +2474,174 @@
  */
 double ElioGetGridElementArea(ElioGrid * g, int elem)
 {
-    int n1, n2, n3, n4;
-    double ar = 0.0;
-    double x1, y1, x2, y2, x3, y3, x4, y4;
-
-    if (elem >= 0 && elem < g->ne) {
-	n1 = g->icon[0][elem];
-	n2 = g->icon[1][elem];
-	n3 = g->icon[2][elem];
-	x1 = g->x[n1];
-	x2 = g->x[n2];
-	x3 = g->x[n3];
-	y1 = g->y[n1];
-	y2 = g->y[n2];
-	y3 = g->y[n3];
-	if (g->etype[elem] == 3) {
-	    ar = 0.5 * ((x1 * y2 - x2 * y1) + (x2 * y3 - x3 * y2) + (x3 * y1 - x1 * y3));
-	} else if (g->etype[elem] == 4) {
-	    n4 = g->icon[3][elem];
-	    x4 = g->x[n4];
-	    y4 = g->y[n4];
-	    ar = 0.5 * ((x1 * y2 - x2 * y1) + (x2 * y3 - x3 * y2) + (x3 * y4 - x4 * y3) + (x4 * y1 - x1 * y4));
+	int n1, n2, n3, n4;
+	double ar = 0.0;
+	double x1, y1, x2, y2, x3, y3, x4, y4;
+
+	if (elem >= 0 && elem < g->ne) {
+		n1 = g->icon[0][elem];
+		n2 = g->icon[1][elem];
+		n3 = g->icon[2][elem];
+		x1 = g->x[n1];
+		x2 = g->x[n2];
+		x3 = g->x[n3];
+		y1 = g->y[n1];
+		y2 = g->y[n2];
+		y3 = g->y[n3];
+		if (g->etype[elem] == 3) {
+			ar = 0.5 * ((x1 * y2 - x2 * y1) + (x2 * y3 - x3 * y2) + (x3 * y1 - x1 * y3));
+		}
+		else if (g->etype[elem] == 4) {
+			n4 = g->icon[3][elem];
+			x4 = g->x[n4];
+			y4 = g->y[n4];
+			ar = 0.5 * ((x1 * y2 - x2 * y1) + (x2 * y3 - x3 * y2) + (x3 * y4 - x4 * y3) + (x4 * y1 - x1 * y4));
+		}
 	}
-    }
-    return ar;
+	return ar;
 }
 
 int ElioReadGrid(char *gname, ElioGrid * g)
 {
-    FILE *fp;
-    char buf[1024];
-    int i;
-    if ((fp = fopen(gname, "rb")) == NULL) {
-	return ELIO_ERR;
-    }
-    char* creturn=fgets(buf, 255, fp);
-    creturn=fgets(buf, 255, fp);
-    sscanf(buf, "%d %d", &g->ne, &g->np);
-    g->x = (double *) malloc(g->np * sizeof(double));
-    g->y = (double *) malloc(g->np * sizeof(double));
-    g->d = (double *) malloc(g->np * sizeof(double));
-    g->etype = (int *) malloc(g->ne * sizeof(int));
-    for (i = 0; i < 4; i++) {
-	g->icon[i] = (int *) malloc(g->ne * sizeof(int));
-    }
-    for (i = 0; i < g->np; i++) {
-	creturn=fgets(buf, 255, fp);
-	sscanf(buf, "%*d %lf %lf %lf", &g->x[i], &g->y[i], &g->d[i]);
-    }
-    for (i = 0; i < g->ne; i++) {
-	creturn=fgets(buf, 255, fp);
-	sscanf(buf, "%*d %d %d %d %d %d", &g->etype[i], &g->icon[0][i], &g->icon[1][i], &g->icon[2][i], &g->icon[3][i]);
-	g->icon[0][i]--;
-	g->icon[1][i]--;
-	g->icon[2][i]--;
-	if (g->etype[i] == 3) {
-	    g->icon[3][i] = -1;
-	} else {
-	    g->icon[3][i]--;
+	FILE *fp;
+	char buf[1024];
+	int i;
+	if ((fp = fopen(gname, "rb")) == NULL ) {
+		return ELIO_ERR;
 	}
-    }
-    return ELIO_OK;
+	char* creturn = fgets(buf, 255, fp);
+	creturn = fgets(buf, 255, fp);
+	sscanf(buf, "%d %d", &g->ne, &g->np);
+	g->x = (double *) malloc(g->np * sizeof(double));
+	g->y = (double *) malloc(g->np * sizeof(double));
+	g->d = (double *) malloc(g->np * sizeof(double));
+	g->etype = (int *) malloc(g->ne * sizeof(int));
+	for (i = 0; i < 4; i++) {
+		g->icon[i] = (int *) malloc(g->ne * sizeof(int));
+	}
+	for (i = 0; i < g->np; i++) {
+		creturn = fgets(buf, 255, fp);
+		sscanf(buf, "%*d %lf %lf %lf", &g->x[i], &g->y[i], &g->d[i]);
+	}
+	for (i = 0; i < g->ne; i++) {
+		creturn = fgets(buf, 255, fp);
+		// NB %*d --> The '*' is the assignment suppression character. jhrg 4/10/14
+		// Playing around with the fortify rules - these two lines do the same thing
+		// but fortify seems to not see that... Staying with the original code. jhrg
+		sscanf(buf, "%*d %d %d %d %d %d", &g->etype[i], &g->icon[0][i], &g->icon[1][i], &g->icon[2][i], &g->icon[3][i]);
+		// sscanf(buf, "%*d %d %d %d %d %d", g->etype + i, g->icon[0] + i, g->icon[1] + i, g->icon[2] + i, g->icon[3] + i);
+		g->icon[0][i]--;
+		g->icon[1][i]--;
+		g->icon[2][i]--;
+		if (g->etype[i] == 3) {
+			g->icon[3][i] = -1;
+		}
+		else {
+			g->icon[3][i]--;
+		}
+	}
+
+	fclose(fp); 	// Added 4/10/14 jhrg
+
+	return ELIO_OK;
 }
 
 int ElioFindElementInGrid(ElioGrid * g, double xp, double yp)
 {
-    int i, j;
-   // int n0, n1, n2, n3;
-    double x[4], y[4];
-    for (i = 0; i < g->ne; i++) {
-	for (j = 0; j < g->etype[i]; j++) {
-	    x[j] = g->x[g->icon[j][i]];
-	    y[j] = g->y[g->icon[j][i]];
-	}
-	//printf("ElioInsideElement %lf %lf %lf %lf %lf %lf %lf %lf\n", xp, yp, x[0], y[0], x[1], y[1], x[2], y[2]);
-	if (g->etype[i] == 3) {
-	    if (ElioInsideElement(xp, yp, x[0], y[0], x[1], y[1], x[2], y[2])) {
-		return i;
-	    }
-	} else {
-	    if (ElioInsideElement4(xp, yp, x[0], y[0], x[1], y[1], x[2], y[2], x[3], y[3])) {
-		return i;
-	    }
+	int i, j;
+	// int n0, n1, n2, n3;
+	double x[4], y[4];
+	for (i = 0; i < g->ne; i++) {
+		for (j = 0; j < g->etype[i]; j++) {
+			x[j] = g->x[g->icon[j][i]];
+			y[j] = g->y[g->icon[j][i]];
+		}
+		//printf("ElioInsideElement %lf %lf %lf %lf %lf %lf %lf %lf\n", xp, yp, x[0], y[0], x[1], y[1], x[2], y[2]);
+		if (g->etype[i] == 3) {
+			if (ElioInsideElement(xp, yp, x[0], y[0], x[1], y[1], x[2], y[2])) {
+				return i;
+			}
+		}
+		else {
+			if (ElioInsideElement4(xp, yp, x[0], y[0], x[1], y[1], x[2], y[2], x[3], y[3])) {
+				return i;
+			}
+		}
 	}
-    }
-    return -1;
+	return -1;
 }
 
 int ElioGridFindNearestNode(ElioGrid * g, double x, double y)
 {
-    int i, ind = -1;
-    double radius;
-    double tmp, *xord = g->x, *yord = g->y;
-
-    if (g->np > 0) {
-	radius = hypot((x - xord[0]), (y - yord[0]));
-	ind = 0;
-	for (i = 1; i < g->np; i++) {
-	    tmp = hypot((x - xord[i]), (y - yord[i]));
-	    if (tmp < radius) {
-		radius = tmp;
-		ind = i;
-	    }
-	}
-    } else {
-	ind = -1;
-    }
-    return ind;
+	int i, ind = -1;
+	double radius;
+	double tmp, *xord = g->x, *yord = g->y;
+
+	if (g->np > 0) {
+		radius = hypot((x - xord[0]), (y - yord[0]));
+		ind = 0;
+		for (i = 1; i < g->np; i++) {
+			tmp = hypot((x - xord[i]), (y - yord[i]));
+			if (tmp < radius) {
+				radius = tmp;
+				ind = i;
+			}
+		}
+	}
+	else {
+		ind = -1;
+	}
+	return ind;
 }
 
 int ElioFindNearestNode(ElcircHeader * h, double x, double y)
 {
-    int i, ind;
-    double radius;
-    double tmp;
-    float *xord = h->x, *yord = h->y;
-
-    if (h->np > 0) {
-	radius = hypot((x - xord[0]), (y - yord[0]));
-	ind = 0;
-	for (i = 1; i < h->np; i++) {
-	    tmp = hypot((x - xord[i]), (y - yord[i]));
-	    if (tmp < radius) {
-		radius = tmp;
-		ind = i;
-	    }
-	}
-    } else {
-	ind = -1;
-    }
-    return ind;
+	int i, ind;
+	double radius;
+	double tmp;
+	float *xord = h->x, *yord = h->y;
+
+	if (h->np > 0) {
+		radius = hypot((x - xord[0]), (y - yord[0]));
+		ind = 0;
+		for (i = 1; i < h->np; i++) {
+			tmp = hypot((x - xord[i]), (y - yord[i]));
+			if (tmp < radius) {
+				radius = tmp;
+				ind = i;
+			}
+		}
+	}
+	else {
+		ind = -1;
+	}
+	return ind;
 }
 
 int ElioWriteGrid(char *gname, ElioGrid * g)
 {
-    FILE *fp;
- //   char buf[1024];
-    int i;
-    if ((fp = fopen(gname, "wb")) == NULL) {
-	return ELIO_ERR;
-    }
-    fprintf(fp, "Grid\n");
-    fprintf(fp, "%d %d\n", g->ne, g->np);
-    for (i = 0; i < g->np; i++) {
-	fprintf(fp, "%d %lf %lf %lf\n", i + 1, g->x[i], g->y[i], g->d[i]);
-    }
-    for (i = 0; i < g->ne; i++) {
-	if (g->etype[i] == 3) {
-	    fprintf(fp, "%d 3 %d %d %d\n", i + 1, g->icon[0][i] + 1, g->icon[1][i] + 1, g->icon[2][i] + 1);
-	} else if (g->etype[i] == 4) {
-	    fprintf(fp, "%d 4 %d %d %d %d\n", i + 1, g->icon[0][i] + 1, g->icon[1][i] + 1, g->icon[2][i] + 1, g->icon[3][i] + 1);
-	}
-    }
-    fclose(fp);
-    return ELIO_OK;
+	FILE *fp;
+	//   char buf[1024];
+	int i;
+	if ((fp = fopen(gname, "wb")) == NULL ) {
+		return ELIO_ERR;
+	}
+	fprintf(fp, "Grid\n");
+	fprintf(fp, "%d %d\n", g->ne, g->np);
+	for (i = 0; i < g->np; i++) {
+		fprintf(fp, "%d %lf %lf %lf\n", i + 1, g->x[i], g->y[i], g->d[i]);
+	}
+	for (i = 0; i < g->ne; i++) {
+		if (g->etype[i] == 3) {
+			fprintf(fp, "%d 3 %d %d %d\n", i + 1, g->icon[0][i] + 1, g->icon[1][i] + 1, g->icon[2][i] + 1);
+		}
+		else if (g->etype[i] == 4) {
+			fprintf(fp, "%d 4 %d %d %d %d\n", i + 1, g->icon[0][i] + 1, g->icon[1][i] + 1, g->icon[2][i] + 1,
+					g->icon[3][i] + 1);
+		}
+	}
+	fclose(fp);
+	return ELIO_OK;
 }
 
 /*!
@@ -2628,13 +2656,14 @@
  */
 void ElioSetCorieTime(int b)
 {
-    corietime = b;
-    if (b) {
-	putenv("TZ=PST");
-	coriestart = ElioGetDay(12, 31, 1995, 0, 0, 0);
-    } else {
-	coriestart = 0.0;
-    }
+	corietime = b;
+	if (b) {
+		putenv("TZ=PST");
+		coriestart = ElioGetDay(12, 31, 1995, 0, 0, 0);
+	}
+	else {
+		coriestart = 0.0;
+	}
 }
 
 /*!
@@ -2642,14 +2671,15 @@
  */
 void ElioSetStartTime(int b, char *t)
 {
-    int y, m, d, h, mi, s;
-    corietime = b;
-    if (b) {
-	sscanf(t, "%4d%2d%2d%2d%2d%2d", &y, &m, &d, &h, &mi, &s);
-	coriestart = ElioGetDay(m, d, y, h, mi, s);
-    } else {
-	coriestart = 0.0;
-    }
+	int y, m, d, h, mi, s;
+	corietime = b;
+	if (b) {
+		sscanf(t, "%4d%2d%2d%2d%2d%2d", &y, &m, &d, &h, &mi, &s);
+		coriestart = ElioGetDay(m, d, y, h, mi, s);
+	}
+	else {
+		coriestart = 0.0;
+	}
 }
 
 /*!
@@ -2657,7 +2687,7 @@
  */
 int ElioGetCorieDayConstant(void)
 {
-    return corietime;
+	return corietime;
 }
 
 /*!
@@ -2665,12 +2695,12 @@
  */
 double ElioGetCorieDay(int when)
 {
-    double jd = 1;
-    time_t t;
-    t = time(NULL) + when * 86400;
-    jd = ElioGetDay(12, 31, 1995, 0, 0, 0);
-    jd = t / 86400.0 - jd;
-    return jd;
+	double jd = 1;
+	time_t t;
+	t = time(NULL ) + when * 86400;
+	jd = ElioGetDay(12, 31, 1995, 0, 0, 0);
+	jd = t / 86400.0 - jd;
+	return jd;
 }
 
 /*!
@@ -2679,16 +2709,16 @@
 double ElioGetDay(int mon, int day, int year, int h, int mi, double se)
 {
 //    double frac = (int) se - se;
-    struct tm t;
-    time_t j;
-    t.tm_sec = se;
-    t.tm_min = mi;
-    t.tm_hour = h;
-    t.tm_mday = day;
-    t.tm_mon = mon - 1;
-    t.tm_year = year - 1900;
-    j = mktime(&t);
-    return ((double) j / 86400.0 - coriestart);
+	struct tm t;
+	time_t j;
+	t.tm_sec = se;
+	t.tm_min = mi;
+	t.tm_hour = h;
+	t.tm_mday = day;
+	t.tm_mon = mon - 1;
+	t.tm_year = year - 1900;
+	j = mktime(&t);
+	return ((double) j / 86400.0 - coriestart);
 }
 
 /*!
@@ -2696,15 +2726,15 @@
  */
 void ElioGetDate(double jd, int *m, int *d, int *y, int *h, int *mi, double *sec)
 {
-    struct tm *t;
-    time_t seconds = (jd + coriestart) * 86400.0;
-    t = gmtime(&seconds);
-    *sec = t->tm_sec;
-    *mi = t->tm_min;
-    *h = t->tm_hour;
-    *d = t->tm_mday;
-    *m = t->tm_mon + 1;
-    *y = t->tm_year + 1900;
+	struct tm *t;
+	time_t seconds = (jd + coriestart) * 86400.0;
+	t = gmtime(&seconds);
+	*sec = t->tm_sec;
+	*mi = t->tm_min;
+	*h = t->tm_hour;
+	*d = t->tm_mday;
+	*m = t->tm_mon + 1;
+	*y = t->tm_year + 1900;
 }
 
 /*!
@@ -2712,130 +2742,139 @@
  */
 void ElioGetYearDay(double jd, int *y, int *yd, int *h, int *mi, double *sec)
 {
-    struct tm *t;
-    time_t seconds = (jd + coriestart) * 86400.0;
-    t = gmtime(&seconds);
-    *sec = t->tm_sec;
-    *mi = t->tm_min;
-    *h = t->tm_hour;
-    *yd = t->tm_yday + 1;
-    *y = t->tm_year + 1900;
+	struct tm *t;
+	time_t seconds = (jd + coriestart) * 86400.0;
+	t = gmtime(&seconds);
+	*sec = t->tm_sec;
+	*mi = t->tm_min;
+	*h = t->tm_hour;
+	*yd = t->tm_yday + 1;
+	*y = t->tm_year + 1900;
 }
 
 /*!
  * Inverse bilinear mapping for quadrangles from Joseph.
- * Convexity of the quad must have been checked, and (x,y) must 
+ * Convexity of the quad must have been checked, and (x,y) must
  * be inside the quad.
  *
  */
-int ibilinear(double x1, double x2, double x3, double x4, double y1, double y2, double y3, double y4, double x, double y, double *xi, double *eta, double *shapef)
+int ibilinear(double x1, double x2, double x3, double x4, double y1, double y2, double y3, double y4, double x,
+		double y, double *xi, double *eta, double *shapef)
 {
-    double axi[2], aet[2], bxy[2], root_xi[2], root_et[2];
-    double x0, y0, dxi, deta, dd, beta, delta, dgamma;
-    int i, icount, icaseno;
+	double axi[2], aet[2], bxy[2], root_xi[2], root_et[2];
+	double x0, y0, dxi, deta, dd, beta, delta, dgamma;
+	int i, icount, icaseno;
 
-    static double SMALL = 1.0e-5;
+	static double SMALL = 1.0e-5;
 
 //!...  Consts.
-    x0 = (x1 + x2 + x3 + x4) / 4.0;
-    y0 = (y1 + y2 + y3 + y4) / 4.0;
-    axi[0] = x2 - x1 + x3 - x4;
-    axi[1] = y2 - y1 + y3 - y4;
-    aet[0] = x3 + x4 - x1 - x2;
-    aet[1] = y3 + y4 - y1 - y2;
-    bxy[0] = x1 - x2 + x3 - x4;
-    bxy[1] = y1 - y2 + y3 - y4;
-    dxi = 2 * ((x3 - x4) * (y1 - y2) - (y3 - y4) * (x1 - x2));
-    deta = 2 * ((x4 - x1) * (y3 - y2) - (y4 - y1) * (x3 - x2));
+	x0 = (x1 + x2 + x3 + x4) / 4.0;
+	y0 = (y1 + y2 + y3 + y4) / 4.0;
+	axi[0] = x2 - x1 + x3 - x4;
+	axi[1] = y2 - y1 + y3 - y4;
+	aet[0] = x3 + x4 - x1 - x2;
+	aet[1] = y3 + y4 - y1 - y2;
+	bxy[0] = x1 - x2 + x3 - x4;
+	bxy[1] = y1 - y2 + y3 - y4;
+	dxi = 2 * ((x3 - x4) * (y1 - y2) - (y3 - y4) * (x1 - x2));
+	deta = 2 * ((x4 - x1) * (y3 - y2) - (y4 - y1) * (x3 - x2));
 
 //!...  Inverse mapping
-    if ((fabs(bxy[0]) < SMALL && fabs(bxy[1]) < SMALL)
-	|| (fabs(dxi) < SMALL && fabs(deta) < SMALL)) {
-	icaseno = 1;
+	if ((fabs(bxy[0]) < SMALL && fabs(bxy[1]) < SMALL) || (fabs(dxi) < SMALL && fabs(deta) < SMALL)) {
+		icaseno = 1;
 //    if (dxi == 0.0 && deta == 0.0) {
-	dd = axi[0] * aet[1] - axi[1] * aet[0];
-	if (dd == 0.0) {
-	    fprintf(stderr, "Case 1 error: %lf\n", dd);
-	    return ELIO_ERR;
-	}
-	*xi = 4 * (aet[1] * (x - x0) - aet[0] * (y - y0)) / dd;
-	*eta = 4 * (axi[0] * (y - y0) - axi[1] * (x - x0)) / dd;
+		dd = axi[0] * aet[1] - axi[1] * aet[0];
+		if (dd == 0.0) {
+			fprintf(stderr, "Case 1 error: %lf\n", dd);
+			return ELIO_ERR;
+		}
+		*xi = 4 * (aet[1] * (x - x0) - aet[0] * (y - y0)) / dd;
+		*eta = 4 * (axi[0] * (y - y0) - axi[1] * (x - x0)) / dd;
 
-    } else if (fabs(dxi) < SMALL && fabs(deta) >= SMALL) {
+	}
+	else if (fabs(dxi) < SMALL && fabs(deta) >= SMALL) {
 //    } else if (dxi == 0 && deta != 0) {
-	icaseno = 2;
-	*eta = 4 * (bxy[1] * (x - x0) - bxy[1] * (y - y0)) / deta;
-	dd = (axi[0] + *eta * bxy[0]) * (axi[0] + *eta * bxy[0]) + (axi[1] + *eta * bxy[1]) * (axi[1] + *eta * bxy[1]);
-	if (dd == 0) {
-	    fprintf(stderr, "Case 2 error: %lf\n", dd);
-	    return ELIO_ERR;
-	}
-	*xi = ((4 * (x - x0) - *eta * aet[0]) * (axi[0] + *eta * bxy[0]) + (4 * (y - y0) - *eta * aet[1]) * (axi[1] + *eta * bxy[1])) / dd;
-	;
-    } else if (fabs(dxi) >= SMALL && fabs(deta) < SMALL) {
-	icaseno = 3;
+		icaseno = 2;
+		*eta = 4 * (bxy[1] * (x - x0) - bxy[1] * (y - y0)) / deta;
+		dd = (axi[0] + *eta * bxy[0]) * (axi[0] + *eta * bxy[0]) + (axi[1] + *eta * bxy[1]) * (axi[1] + *eta * bxy[1]);
+		if (dd == 0) {
+			fprintf(stderr, "Case 2 error: %lf\n", dd);
+			return ELIO_ERR;
+		}
+		*xi = ((4 * (x - x0) - *eta * aet[0]) * (axi[0] + *eta * bxy[0])
+				+ (4 * (y - y0) - *eta * aet[1]) * (axi[1] + *eta * bxy[1])) / dd;
+		;
+	}
+	else if (fabs(dxi) >= SMALL && fabs(deta) < SMALL) {
+		icaseno = 3;
 //    } else if (dxi != 0 && deta == 0) {
-	*xi = 4 * (bxy[1] * (x - x0) - bxy[0] * (y - y0)) / dxi;
-	dd = (aet[0] + *xi * bxy[0]) * (aet[0] + *xi * bxy[0]) + (aet[1] + *xi * bxy[1]) * (aet[1] + *xi * bxy[1]);
-	if (dd == 0) {
-	    fprintf(stderr, "Case 3 error: %lf\n", dd);
-	    return ELIO_ERR;
-	}
-	*eta = ((4 * (x - x0) - *xi * axi[0]) * (aet[0] + *xi * bxy[0]) + (4 * (y - y0) - *xi * axi[1]) * (aet[1] + *xi * bxy[1])) / dd;
-	;
-    } else {
-	icaseno = 4;
-	beta = aet[1] * axi[0] - aet[0] * axi[1] - 4 * (bxy[1] * (x - x0) - bxy[0] * (y - y0));
-	dgamma = 4 * (aet[0] * (y - y0) - aet[1] * (x - x0));
-	delta = beta * beta - 4 * dgamma * dxi;
-	if (delta == 0) {
-	    *xi = (-beta / 2.0 / dxi);
-	    *eta = (4 * (bxy[1] * (x - x0) - bxy[0] * (y - y0)) - *xi * dxi) / deta;
-	} else if (delta > 0.0) {
-	    root_xi[0] = (-beta + sqrt(delta)) / 2 / dxi;
-	    root_xi[1] = (-beta - sqrt(delta)) / 2 / dxi;
-	    icount = 0;
-	    for (i = 0; i < 2; i++) {
-		root_et[i] = (4 * (bxy[1] * (x - x0) - bxy[0] * (y - y0)) - root_xi[i] * dxi) / deta;
-		if (fabs(root_xi[i]) <= 1.1 && fabs(root_et[i]) <= 1.1) {
-		    *xi = root_xi[i];
-		    *eta = root_et[i];
-		    icount = icount + 1;
-		}
-	    }
-	    if (icount == 2 && fabs(root_xi[0] - root_xi[1]) < SMALL) {
-	    } else if (icount != 1) {
-		fprintf(stderr, "Abnormal instances %lf %lf %d\n", root_xi[0], root_et[1], icount);
-		return ELIO_ERR;
-	    }
-	} else {
-	    fprintf(stderr, "No roots %lf\n", delta);
-	    return ELIO_ERR;
+		*xi = 4 * (bxy[1] * (x - x0) - bxy[0] * (y - y0)) / dxi;
+		dd = (aet[0] + *xi * bxy[0]) * (aet[0] + *xi * bxy[0]) + (aet[1] + *xi * bxy[1]) * (aet[1] + *xi * bxy[1]);
+		if (dd == 0) {
+			fprintf(stderr, "Case 3 error: %lf\n", dd);
+			return ELIO_ERR;
+		}
+		*eta = ((4 * (x - x0) - *xi * axi[0]) * (aet[0] + *xi * bxy[0])
+				+ (4 * (y - y0) - *xi * axi[1]) * (aet[1] + *xi * bxy[1])) / dd;
+		;
+	}
+	else {
+		icaseno = 4;
+		beta = aet[1] * axi[0] - aet[0] * axi[1] - 4 * (bxy[1] * (x - x0) - bxy[0] * (y - y0));
+		dgamma = 4 * (aet[0] * (y - y0) - aet[1] * (x - x0));
+		delta = beta * beta - 4 * dgamma * dxi;
+		if (delta == 0) {
+			*xi = (-beta / 2.0 / dxi);
+			*eta = (4 * (bxy[1] * (x - x0) - bxy[0] * (y - y0)) - *xi * dxi) / deta;
+		}
+		else if (delta > 0.0) {
+			root_xi[0] = (-beta + sqrt(delta)) / 2 / dxi;
+			root_xi[1] = (-beta - sqrt(delta)) / 2 / dxi;
+			icount = 0;
+			for (i = 0; i < 2; i++) {
+				root_et[i] = (4 * (bxy[1] * (x - x0) - bxy[0] * (y - y0)) - root_xi[i] * dxi) / deta;
+				if (fabs(root_xi[i]) <= 1.1 && fabs(root_et[i]) <= 1.1) {
+					*xi = root_xi[i];
+					*eta = root_et[i];
+					icount = icount + 1;
+				}
+			}
+			if (icount == 2 && fabs(root_xi[0] - root_xi[1]) < SMALL) {
+			}
+			else if (icount != 1) {
+				fprintf(stderr, "Abnormal instances %lf %lf %d\n", root_xi[0], root_et[1], icount);
+				return ELIO_ERR;
+			}
+		}
+		else {
+			fprintf(stderr, "No roots %lf\n", delta);
+			return ELIO_ERR;
+		}
 	}
-    }
 
-    if (fabs(*xi) > 1.1 || fabs(*eta) > 1.1) {
-	fprintf(stderr, "Out of bound in ibilinear %lf %lf\n", *xi, *eta);
-	return ELIO_ERR;
-    }
+	if (fabs(*xi) > 1.1 || fabs(*eta) > 1.1) {
+		fprintf(stderr, "Out of bound in ibilinear %lf %lf\n", *xi, *eta);
+		return ELIO_ERR;
+	}
 
-    *xi = (*xi > -1.0) ? *xi : -1.0;
-    *eta = (*eta > -1.0) ? *eta : -1.0;
-    *xi = (*xi < 1.0) ? *xi : 1.0;
-    *eta = (*eta < 1.0) ? *eta : 1.0;
-    //xi=dmin1(1.0,dmax1(xi,-1.0));
-    //eta=dmin1(1.0,dmax1(eta,-1.0));
-
-    shapef[0] = (1 - *xi) * (1 - *eta) / 4;
-    shapef[1] = (1 + *xi) * (1 - *eta) / 4;
-    shapef[2] = (1 + *xi) * (1 + *eta) / 4;
-    shapef[3] = (1 - *xi) * (1 + *eta) / 4;
-    return ELIO_OK;
+	*xi = (*xi > -1.0) ? *xi : -1.0;
+	*eta = (*eta > -1.0) ? *eta : -1.0;
+	*xi = (*xi < 1.0) ? *xi : 1.0;
+	*eta = (*eta < 1.0) ? *eta : 1.0;
+	//xi=dmin1(1.0,dmax1(xi,-1.0));
+	//eta=dmin1(1.0,dmax1(eta,-1.0));
+
+	shapef[0] = (1 - *xi) * (1 - *eta) / 4;
+	shapef[1] = (1 + *xi) * (1 - *eta) / 4;
+	shapef[2] = (1 + *xi) * (1 + *eta) / 4;
+	shapef[3] = (1 - *xi) * (1 + *eta) / 4;
+	return ELIO_OK;
 }
 
 static double C(double sigma, ElcircHeader * h)
 {
-    return (1 - h->thetab) * sinh(h->thetaf * sigma) / sinh(h->thetaf) + h->thetab * (tanh(h->thetaf * (sigma + 0.5)) - tanh(h->thetaf * 0.5)) / (2.0 * tanh(h->thetaf * 0.5));
+	return (1 - h->thetab) * sinh(h->thetaf * sigma) / sinh(h->thetaf)
+			+ h->thetab * (tanh(h->thetaf * (sigma + 0.5)) - tanh(h->thetaf * 0.5)) / (2.0 * tanh(h->thetaf * 0.5));
 }
 
 /*!
@@ -2867,30 +2906,33 @@
  */
 double ElioGetSigmaDepthAtNode(int node, int level, float eta, ElcircHeader * eh)
 {
-    double z, sigma, h;z=0.0;
-    sigma = eh->zcor[level];
-    h = eh->d[node];
-    if (eh->ivcor == 1) {
-	z = (h + eta) * sigma + eta;
-    } else if (eh->ivcor == 2) {
-	if ((eta + h) > eh->h0 && h > eh->hc && eta > (-eh->hc - (h - eh->hc) * eh->thetaf / sinh(eh->thetaf))) {
-	    z = eta * (1.0 + sigma) + eh->hc * eta + (h - eh->hc) * C(sigma, eh);
-	} else {
-	    z = (h + eta) * sigma + eta;
+	double z, sigma, h;
+	z = 0.0;
+	sigma = eh->zcor[level];
+	h = eh->d[node];
+	if (eh->ivcor == 1) {
+		z = (h + eta) * sigma + eta;
+	}
+	else if (eh->ivcor == 2) {
+		if ((eta + h) > eh->h0 && h > eh->hc && eta > (-eh->hc - (h - eh->hc) * eh->thetaf / sinh(eh->thetaf))) {
+			z = eta * (1.0 + sigma) + eh->hc * eta + (h - eh->hc) * C(sigma, eh);
+		}
+		else {
+			z = (h + eta) * sigma + eta;
+		}
 	}
-    }
-    return z;
+	return z;
 }
 
 int ElioGetSigmaDepth(int node, float eta, ElcircHeader * eh, double *depths)
 {
-    //double z, sigma, h;
-    int i;
+	//double z, sigma, h;
+	int i;
 
-    for (i = 0; i < eh->nvrt; i++) {
-	depths[i] = ElioGetSigmaDepthAtNode(node, i, eta, eh);
-    }
-    return ELIO_OK;
+	for (i = 0; i < eh->nvrt; i++) {
+		depths[i] = ElioGetSigmaDepthAtNode(node, i, eta, eh);
+	}
+	return ELIO_OK;
 }
 
 /*!
@@ -2909,12 +2951,13 @@
 double ElioGetSigmaDepthAtXY(double x, double y, int level, float e, ElcircHeader * eh)
 {
 //    double H, h;// eta, sigma;
-    /* Need to interpolate elevation and depth */
-    //H = eh->d[node] + e;
-   // h = H * eh->zcor[level] + e;
-   // return h;
-    printf("error! ElioGetSigmaDepthAtXY broken %s\n",0.0);
-    return 0.0;
+	/* Need to interpolate elevation and depth */
+	//H = eh->d[node] + e;
+	// h = H * eh->zcor[level] + e;
+	// return h;
+	//FIXME type error
+	printf("error! ElioGetSigmaDepthAtXY broken %g\n", 0.0);
+	return 0.0;
 }
 
 /*!
@@ -2932,11 +2975,11 @@
  */
 double ElioGetSigmaDepthAtXYZ(double x, double y, double z, float e, ElcircHeader * eh)
 {
-  //  double h;//H,  eta, sigma;
-    //H = eh->d[node] + e;
-    //h = H * eh->zcor[level] + e;
-    printf("error! ElioGetSigmaDepthAtXYZ broken %.2f\n",0.0);
-    return 0.0;
+	//  double h;//H,  eta, sigma;
+	//H = eh->d[node] + e;
+	//h = H * eh->zcor[level] + e;
+	printf("error! ElioGetSigmaDepthAtXYZ broken %.2f\n", 0.0);
+	return 0.0;
 }
 
 /*!
@@ -2952,20 +2995,20 @@
  */
 int ElioMinMax(int n, double *ar, double *dmin, double *dmax)
 {
-    int i;
-    if (ar == (double *) NULL) {
-	return ELIO_ERR;
-    }
-    *dmax = *dmin = ar[0];
-    for (i = 1; i < n; i++) {
-	if (*dmin > ar[i]) {
-	    *dmin = ar[i];
+	int i;
+	if (ar == (double *) NULL ) {
+		return ELIO_ERR;
 	}
-	if (*dmax < ar[i]) {
-	    *dmax = ar[i];
+	*dmax = *dmin = ar[0];
+	for (i = 1; i < n; i++) {
+		if (*dmin > ar[i]) {
+			*dmin = ar[i];
+		}
+		if (*dmax < ar[i]) {
+			*dmax = ar[i];
+		}
 	}
-    }
-    return ELIO_OK;
+	return ELIO_OK;
 }
 
 /*!
@@ -2981,14 +3024,14 @@
  */
 int ElioIntMin(int n, int *iar)
 {
-    int i, im = 0;
-    im = iar[0];
-    for (i = 1; i < n; i++) {
-	if (im > iar[i]) {
-	    im = iar[i];
+	int i, im = 0;
+	im = iar[0];
+	for (i = 1; i < n; i++) {
+		if (im > iar[i]) {
+			im = iar[i];
+		}
 	}
-    }
-    return im;
+	return im;
 }
 
 /*!
@@ -3004,14 +3047,14 @@
  */
 int ElioIntMax(int n, int *iar)
 {
-    int i, im = 0;
-    im = iar[0];
-    for (i = 1; i < n; i++) {
-	if (im < iar[i]) {
-	    im = iar[i];
+	int i, im = 0;
+	im = iar[0];
+	for (i = 1; i < n; i++) {
+		if (im < iar[i]) {
+			im = iar[i];
+		}
 	}
-    }
-    return im;
+	return im;
 }
 
 /*!
@@ -3024,29 +3067,37 @@
  */
 int ElioGetFileVersion(char *fname)
 {
-    FILE *fp;
-    char magic[50];
-    fp = fopen(fname, "rb");
-    if (fp == NULL) {
-	fprintf(stderr, "ElioGetFileVersion(): Unable to open file %s\n", fname);
-	return -1;
-    }
-    if (fread(magic, sizeof(char), 48, fp) != 48)
-	return ELIO_FREAD_ERR;
-    magic[48] = 0;
-    /* DataFormat v3.0 */
-    if (strncmp(magic, "DataFormat v4.0", 15) == 0) {
-	return 4;
-    } else if (strncmp(magic, "DataFormat v5.0", 15) == 0) {
-	return 5;
-    } else if (strncmp(magic, "DataFormat v3.0", 15) == 0) {
-	return 3;
-    } else if (strncmp(magic, "DataFormat v2.0", 15) == 0) {
-	return 2;
-    } else {
-	return -1;
-    }
-    fclose(fp);
+	FILE *fp;
+	char magic[50];
+	fp = fopen(fname, "rb");
+	if (fp == NULL ) {
+		fprintf(stderr, "ElioGetFileVersion(): Unable to open file %s\n", fname);
+		return -1;
+	}
+	if (fread(magic, sizeof(char), 48, fp) != 48) {
+		fclose(fp);		// 4/10/14 jhrg
+		return ELIO_FREAD_ERR;
+	}
+	magic[48] = 0;
+	fclose(fp);			// Moved from the end of the function - where it was unreachable
+						// 4/10/14 jhrg
+
+	/* DataFormat v3.0 */
+	if (strncmp(magic, "DataFormat v4.0", 15) == 0) {
+		return 4;
+	}
+	else if (strncmp(magic, "DataFormat v5.0", 15) == 0) {
+		return 5;
+	}
+	else if (strncmp(magic, "DataFormat v3.0", 15) == 0) {
+		return 3;
+	}
+	else if (strncmp(magic, "DataFormat v2.0", 15) == 0) {
+		return 2;
+	}
+	else {
+		return -1;
+	}
 }
 
 /*!
@@ -3065,25 +3116,25 @@
  */
 int ElioFindIndex(int n, double *data, double d)
 {
-    int i;
-    if (d < data[0]) {
+	int i;
+	if (d < data[0]) {
+		return -1;
+	}
+	if (d > data[n - 1]) {
+		return n;
+	}
+	for (i = 0; i < n - 1; i++) {
+		if (d >= data[i] && d <= data[i + 1]) {
+			return i;
+		}
+	}
+	/* Not reached */
 	return -1;
-    }
-    if (d > data[n - 1]) {
-	return n;
-    }
-    for (i = 0; i < n - 1; i++) {
-	if (d >= data[i] && d <= data[i + 1]) {
-	    return i;
-	}
-    }
-/* Not reached */
-    return -1;
 }
 
 /*!
  * Given an array of depths and scalar quatities, interpolate
- * the scalar values to all the points in *zp. Clamp to values at 
+ * the scalar values to all the points in *zp. Clamp to values at
  * either end if point to find is out of range. Output to *sp.
  *
  * Input variables:
@@ -3097,38 +3148,41 @@
  */
 void ElioInterpolateArray(int n, double *z, double *s, int np, double *zp, double *sp)
 {
-    int i, j, l1=1, l2=0;
-    double tmp;
-    for (j = 0; j < np; j++) {
-/* Use minimum value */
-	if (zp[j] < z[0]) {
-	    sp[j] = s[0];
-/* Use maximum value */
-	} else if (zp[j] > z[n - 1]) {
-	    sp[j] = s[n - 1];
-/* Use interpolated value */
-	} else {
-	    for (i = 0; i < n - 1; i++) {
-		l1 = i;
-		l2 = i + 1;
-		if (zp[j] >= z[l1] && zp[j] <= z[l2]) {
-		    break;
-		}
-	    }
-	    tmp = (z[l2] - z[l1]);
-	    if (tmp != 0.0) {
-		sp[j] = (zp[j] - z[l1]) / (z[l2] - z[l1]) * (s[l2] - s[l1]) + s[l1];
-	    } else {
-		fprintf(stderr, "Elio: In ElioInterpolateArray(), z[l2] - z[l1] == 0.0\n");
-		sp[j] = -9999.0;
-	    }
+	int i, j, l1 = 1, l2 = 0;
+	double tmp;
+	for (j = 0; j < np; j++) {
+		/* Use minimum value */
+		if (zp[j] < z[0]) {
+			sp[j] = s[0];
+			/* Use maximum value */
+		}
+		else if (zp[j] > z[n - 1]) {
+			sp[j] = s[n - 1];
+			/* Use interpolated value */
+		}
+		else {
+			for (i = 0; i < n - 1; i++) {
+				l1 = i;
+				l2 = i + 1;
+				if (zp[j] >= z[l1] && zp[j] <= z[l2]) {
+					break;
+				}
+			}
+			tmp = (z[l2] - z[l1]);
+			if (tmp != 0.0) {
+				sp[j] = (zp[j] - z[l1]) / (z[l2] - z[l1]) * (s[l2] - s[l1]) + s[l1];
+			}
+			else {
+				fprintf(stderr, "Elio: In ElioInterpolateArray(), z[l2] - z[l1] == 0.0\n");
+				sp[j] = -9999.0;
+			}
+		}
 	}
-    }
 }
 
 /*!
  * Given an array of depths and scalar quantities, interpolate
- * a scalar value given the depth. Clamp to value at 
+ * a scalar value given the depth. Clamp to value at
  * either end if point to find is out of range. returns the
  * interplated value.
  *
@@ -3141,42 +3195,45 @@
  */
 double ElioInterpolate(int n, double *z, double *s, double zp)
 {
-    int i, l1=0, l2=1;
-    double sp = 0.0;
-    double tmp;
-/* Use minimum value */
-    if (zp < z[0]) {
-	sp = s[0];
-/* Use maximum value */
-    } else if (zp > z[n - 1]) {
-	sp = s[n - 1];
-/* Use interpolated value */
-    } else {
-	for (i = 0; i < n - 1; i++) {
-	    l1 = i;
-	    l2 = i + 1;
-	    if (zp >= z[l1] && zp <= z[l2]) {
-		break;
-	    }
-	}
-	tmp = (z[l2] - z[l1]);
-	if (tmp != 0.0) {
-	    sp = (zp - z[l1]) / (z[l2] - z[l1]) * (s[l2] - s[l1]) + s[l1];
-	} else {
-	    fprintf(stderr, "Elio: In ElioInterpolate(), z[l2] - z[l1] == 0.0\n");
-	    sp = -9999.0;
+	int i, l1 = 0, l2 = 1;
+	double sp = 0.0;
+	double tmp;
+	/* Use minimum value */
+	if (zp < z[0]) {
+		sp = s[0];
+		/* Use maximum value */
+	}
+	else if (zp > z[n - 1]) {
+		sp = s[n - 1];
+		/* Use interpolated value */
+	}
+	else {
+		for (i = 0; i < n - 1; i++) {
+			l1 = i;
+			l2 = i + 1;
+			if (zp >= z[l1] && zp <= z[l2]) {
+				break;
+			}
+		}
+		tmp = (z[l2] - z[l1]);
+		if (tmp != 0.0) {
+			sp = (zp - z[l1]) / (z[l2] - z[l1]) * (s[l2] - s[l1]) + s[l1];
+		}
+		else {
+			fprintf(stderr, "Elio: In ElioInterpolate(), z[l2] - z[l1] == 0.0\n");
+			sp = -9999.0;
+		}
 	}
-    }
-    return sp;
+	return sp;
 }
 
 /*!
  * Given an array of depths and scalar quantities, interpolate
- * a scalar value given the index as found from ElioFindIndex(). 
+ * a scalar value given the index as found from ElioFindIndex().
  * Clamp to value at either end if point to find is out of range.
- * 
+ *
  * Input variables:
- * 
+ *
  * \param n = Number of items in *z.
  * \param z = Depths.
  * \param s = Scalar value.
@@ -3185,37 +3242,40 @@
  */
 double ElioInterpolateAtIndex(int n, double *z, double *s, int ind, double zp)
 {
-    int l1, l2;
-    double sp = 0.0;
-    double tmp;
-/* Use minimum value */
-    if (ind < 0) {
-	sp = s[0];
-/* Use maximum value */
-    } else if (ind == n) {
-	sp = s[n - 1];
-/* Use interpolated value */
-    } else {
-	l1 = ind;
-	l2 = ind + 1;
-	tmp = (z[l2] - z[l1]);
-	if (tmp != 0.0) {
-	    sp = (zp - z[l1]) / (z[l2] - z[l1]) * (s[l2] - s[l1]) + s[l1];
-	} else {
-	    //fprintf(stderr, "Elio: In ElioInterpolateAtIndex(), z[l2] - z[l1] == 0.0\n");
-	    sp = -9999.0;
+	int l1, l2;
+	double sp = 0.0;
+	double tmp;
+	/* Use minimum value */
+	if (ind < 0) {
+		sp = s[0];
+		/* Use maximum value */
+	}
+	else if (ind == n) {
+		sp = s[n - 1];
+		/* Use interpolated value */
+	}
+	else {
+		l1 = ind;
+		l2 = ind + 1;
+		tmp = (z[l2] - z[l1]);
+		if (tmp != 0.0) {
+			sp = (zp - z[l1]) / (z[l2] - z[l1]) * (s[l2] - s[l1]) + s[l1];
+		}
+		else {
+			//fprintf(stderr, "Elio: In ElioInterpolateAtIndex(), z[l2] - z[l1] == 0.0\n");
+			sp = -9999.0;
+		}
 	}
-    }
-    return sp;
+	return sp;
 }
 
 /*!
  * Given an array of depths and scalar quantities, interpolate
- * a scalar value given the index as found from ElioFindIndex(). 
+ * a scalar value given the index as found from ElioFindIndex().
  * Clamp to value at either end if point to find is out of range.
- * 
+ *
  * Input variables:
- * 
+ *
  * \param n = Number of items in *z.
  * \param z = Depths.
  * \param s = Scalar value.
@@ -3224,20 +3284,20 @@
  */
 int ElioMakeDepthsOld(ElcircHeader * h, float *d, float *dd)
 {
-    int i, j, k;
-    for (i = 0; i < h->np * h->nvrt; i++) {
-        dd[i] = -99.0;
-    }
-    for (j = 0; j < h->np; j++) {
+	int i, j, k;
+	for (i = 0; i < h->np * h->nvrt; i++) {
+		dd[i] = -99.0;
+	}
+	for (j = 0; j < h->np; j++) {
 // Fill in missing depth values in file - only for Z levels.
-        for (k = 0; k < h->kz; k++) {
-            dd[j * h->nvrt + k] = h->zcor[k];
-        }
+		for (k = 0; k < h->kz; k++) {
+			dd[j * h->nvrt + k] = h->zcor[k];
+		}
 // Fill in depth values from zcor.
-        for (k = h->bi[j]; k < h->nvrt; k++) {
-            dd[j * h->nvrt + k] = d[h->no[j] + k - h->bi[j]];
-        }
-    }
-    return ELIO_OK;
-} 
+		for (k = h->bi[j]; k < h->nvrt; k++) {
+			dd[j * h->nvrt + k] = d[h->no[j] + k - h->bi[j]];
+		}
+	}
+	return ELIO_OK;
+}
 
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/elio.h gridfields/clib/src/elio.h
--- tag/gridfieldsclib-0.7/src/elio.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/elio.h	2014-05-16 22:57:00.786725198 +0200
@@ -1,5 +1,5 @@
 /*! @file $RCSfile: elio.h,v $
- * 
+ *
  * @version $Revision: 1.3 $
  *
  * Copyright 1990-2003 Oregon Health and Science University
@@ -8,43 +8,47 @@
  * pturner 11-2002
  *
  */
- 
+
 #ifndef ELIO_H
 #define ELIO_H
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 /*! Error codes. */
 /*! No errors */
-#define ELIO_OK 0 
+#define ELIO_OK 0
 /*! Generic error return code */
-#define ELIO_ERR 1 
+#define ELIO_ERR 1
 /*! Error return code for fopen() */
-#define ELIO_FOPEN_ERR 2 
+#define ELIO_FOPEN_ERR 2
 /*! Error return code for fseek() */
-#define ELIO_FSEEK_ERR 3 
+#define ELIO_FSEEK_ERR 3
 /*! Error return code for fread() */
-#define ELIO_FREAD_ERR 4 
+#define ELIO_FREAD_ERR 4
 /*! Error return code for fwrite() */
-#define ELIO_FWRITE_ERR 5 
+#define ELIO_FWRITE_ERR 5
 /*! Error return code for fclose() */
-#define ELIO_FCLOSE_ERR 6 
+#define ELIO_FCLOSE_ERR 6
 /*! Error return code for ftell() */
-#define ELIO_FTELL_ERR 7 
+#define ELIO_FTELL_ERR 7
 /*! Compression types, COMPRESS_NONE == no compression */
-#define COMPRESS_NONE 0 
+#define COMPRESS_NONE 0
 /*! COMPRESS_C16 == Fixed point 16 bit integer compression. */
-#define COMPRESS_C16 1 
+#define COMPRESS_C16 1
 /*! ZLEVEL == 0 */
-#define ZLEVEL 0 
+#define ZLEVEL 0
 /*! SIGMA_S0 == sigma grid scheme 0 */
-#define SIGMA_S0 1 
+#define SIGMA_S0 1
 /*! SIGMA_S1 == sigma grid scheme 1 */
-#define SIGMA_S1 2 
+#define SIGMA_S1 2
 /*! SIGMA_S2 == sigma grid scheme 2 */
-#define SIGMA_S2 3 
+#define SIGMA_S2 3
 /*! SIGMA_S3 == sigma grid scheme 3 */
-#define SIGMA_S3 4 
+#define SIGMA_S3 4
 /*! SIGMA_S4 == sigma grid scheme 4 */
-#define SIGMA_S4 5 
+#define SIGMA_S4 5
 /*! Missing data value for compressed files */
 #define MISSING_DATA -32767
 
@@ -54,114 +58,114 @@
 extern char *ElioMsg; /*! Error message */
 
 /*! ElcircHeader:
- * A struct used to hold the header information from the data file. 
- * Some elements of ElcircHeader are derived rather than actually being 
- * present in the file. An example of a derived variable is the member 
- * 'no' which provides 
+ * A struct used to hold the header information from the data file.
+ * Some elements of ElcircHeader are derived rather than actually being
+ * present in the file. An example of a derived variable is the member
+ * 'no' which provides
  * offsets into the file for a given time step to access nodes directly.
- * The elements of the 'bi' member used to hold bottom indices are one less 
+ * The elements of the 'bi' member used to hold bottom indices are one less
  * than the on disk header as a convenience for C coders.
  */
 typedef struct {
-/*! magic string */
-    char magic[49]; 
-/*! File format version ID */
-    char version[49]; 
-/*! Start time of the run DD/MM/YYYY HH:MM:SS TZ */
-    char start_time[49]; 
-/*! Variable name for data in this file */
-    char variable_nm[49]; 
-/*! Variable dimension */
-    char variable_dim[49]; 
-/*! version number == 2 or == 3 or == 4, derived from 'version' */
-    int v; 
-/*! Compression type 0 == no compression */
-    int compress; 
-/*! If 16bit fixed point compression, the slope of the line */
-    double a; 
-/*! If 16bit fixed point compression, the intercept of the line */
-    double b; 
-/*! Number of time steps in the file, NOTE: this may not be the actual number of time steps in the file */
-    int nsteps; 
-/*! Model time step */
-    float timestep; 
-/*! Number of time steps skipped */
-    int skip; 
-/*! Vector or scalar data, values are 1 = scalar or 2 = vector */
-    int ivs; 
-/*! i23d = 2 => 2d (such as elevations or wind) or i23d = 3 => 3d data (such as velocities and salinity) */
-    int i23d; 
-/*! 1.0 or 0.5 depending whether variable is defined on the level or half level */
-    float vpos; 
-/*! correction to mean sea level */
-    float zmsl; 
-/*! Version 4 sigma */
-    int ivcor;
-/*! Version 4 sigma */
-    float h0;
-/*! Version 5 sigma */
-    float hs;
-/*! Version 4 sigma */
-    float hc;
-/*! Version 4 sigma */
-    float thetab;
-/*! Version 4 sigma */
-    float thetaf;
-/*! Number of vertical levels. Note: this is set to 1 for 2d variables where the on-disk header will have the number of levels as in a 3d variable file */
-    int nvrt; 
-/*! Number of vertical levels for Z - version 5.0 */
-    int kz; 
-/*! Number of vertical levels for sigma - version 5.0 */
-    int ks; 
-/*! number of elements in a time step */
-    int nitems; 
-/*! Size of the header on disk */
-    int hsize; 
-/*! Time step size */
-    int ssize; 
-/*! Sigma grid if true */
-    int sigma; 
-/*! depth of each level or sigma coords */
-    float *zcor; 
-/*! Number of nodes in the grid */
-    int np; 
-/*! Number of elements in the grid */
-    int ne; 
-/*! X, Y for nodes, eventually doubles in some future version. */
-    float *x; 
-    float *y; 
-/*! The grid depth */
-    float *d; 
-/*! Holds the indexes of the bottom level for each node starting from 0. The on-disk header stores these indexes starting from 1. */ 
-    int *bi; 
-/*! Node offsets into time step for each node starting from 0 */
-    int *no; 
-/*! Array holding the element type for each element. Each element is assigned either a 3 (tris) or 4 (quads) */
-    int *etype; 
-/*! Pointers to table of elements for the grid. */
-    int *icon[4]; 
+	/*! magic string */
+	char magic[49];
+	/*! File format version ID */
+	char version[49];
+	/*! Start time of the run DD/MM/YYYY HH:MM:SS TZ */
+	char start_time[49];
+	/*! Variable name for data in this file */
+	char variable_nm[49];
+	/*! Variable dimension */
+	char variable_dim[49];
+	/*! version number == 2 or == 3 or == 4, derived from 'version' */
+	int v;
+	/*! Compression type 0 == no compression */
+	int compress;
+	/*! If 16bit fixed point compression, the slope of the line */
+	double a;
+	/*! If 16bit fixed point compression, the intercept of the line */
+	double b;
+	/*! Number of time steps in the file, NOTE: this may not be the actual number of time steps in the file */
+	int nsteps;
+	/*! Model time step */
+	float timestep;
+	/*! Number of time steps skipped */
+	int skip;
+	/*! Vector or scalar data, values are 1 = scalar or 2 = vector */
+	int ivs;
+	/*! i23d = 2 => 2d (such as elevations or wind) or i23d = 3 => 3d data (such as velocities and salinity) */
+	int i23d;
+	/*! 1.0 or 0.5 depending whether variable is defined on the level or half level */
+	float vpos;
+	/*! correction to mean sea level */
+	float zmsl;
+	/*! Version 4 sigma */
+	int ivcor;
+	/*! Version 4 sigma */
+	float h0;
+	/*! Version 5 sigma */
+	float hs;
+	/*! Version 4 sigma */
+	float hc;
+	/*! Version 4 sigma */
+	float thetab;
+	/*! Version 4 sigma */
+	float thetaf;
+	/*! Number of vertical levels. Note: this is set to 1 for 2d variables where the on-disk header will have the number of levels as in a 3d variable file */
+	int nvrt;
+	/*! Number of vertical levels for Z - version 5.0 */
+	int kz;
+	/*! Number of vertical levels for sigma - version 5.0 */
+	int ks;
+	/*! number of elements in a time step */
+	int nitems;
+	/*! Size of the header on disk */
+	int hsize;
+	/*! Time step size */
+	int ssize;
+	/*! Sigma grid if true */
+	int sigma;
+	/*! depth of each level or sigma coords */
+	float *zcor;
+	/*! Number of nodes in the grid */
+	int np;
+	/*! Number of elements in the grid */
+	int ne;
+	/*! X, Y for nodes, eventually doubles in some future version. */
+	float *x;
+	float *y;
+	/*! The grid depth */
+	float *d;
+	/*! Holds the indexes of the bottom level for each node starting from 0. The on-disk header stores these indexes starting from 1. */
+	int *bi;
+	/*! Node offsets into time step for each node starting from 0 */
+	int *no;
+	/*! Array holding the element type for each element. Each element is assigned either a 3 (tris) or 4 (quads) */
+	int *etype;
+	/*! Pointers to table of elements for the grid. */
+	int *icon[4];
 } ElcircHeader;
 
 typedef struct {
-/*! Model time */
-    float t; 
-/*! Model time step number */
-    int it; 
-/*! Surface indices, these are not transformed but are as read from the file so the maximum value could be nvrt (as opposed to the bottom indices where are decremented by one after being read in). */
-    int *surfind; 
-/*! In version 4, the elevation for each time step. */
-    float *e; 
-/*! Data for all nodes and levels for the time step. */
-    float *d; 
+	/*! Model time */
+	float t;
+	/*! Model time step number */
+	int it;
+	/*! Surface indices, these are not transformed but are as read from the file so the maximum value could be nvrt (as opposed to the bottom indices where are decremented by one after being read in). */
+	int *surfind;
+	/*! In version 4, the elevation for each time step. */
+	float *e;
+	/*! Data for all nodes and levels for the time step. */
+	float *d;
 } ElcircTimeStep;
 
 typedef struct {
-    float t;
-    int it;
-    int istart;
-    int istop;
-    int npts;
-    float *d;
+	float t;
+	int it;
+	int istart;
+	int istop;
+	int npts;
+	float *d;
 } ElcircTimeStepAtNode;
 
 /*! ElioGrid:
@@ -169,20 +173,20 @@
  * Structure for a stand alone grid. Useful where no header exists.
  */
 typedef struct {
-/*! Number of elements */
-    int ne;
-/*! Number of nodes */
-    int np;
-/*! X */
-    double *x;
-/*! Y */
-    double *y;
-/*! Depth */
-    double *d;
-/*! Element type (3 or 4) */
-    int *etype;
-/*! Table of elements */
-    int *icon[4];
+	/*! Number of elements */
+	int ne;
+	/*! Number of nodes */
+	int np;
+	/*! X */
+	double *x;
+	/*! Y */
+	double *y;
+	/*! Depth */
+	double *d;
+	/*! Element type (3 or 4) */
+	int *etype;
+	/*! Table of elements */
+	int *icon[4];
 } ElioGrid;
 
 int ElioReadGrid(char *fname, ElioGrid *g);
@@ -199,7 +203,7 @@
 
 /*!
  * Read the header from an ELCIRC output file. Returns ELIO_OK on success and ELIO_ error codes otherwise.
- */  
+ */
 int ElioGetHeader(char *fname, ElcircHeader *h);
 /*! Allocate memory allocated for a header */
 int ElioAllocateHeader(ElcircHeader *h);
@@ -218,9 +222,12 @@
 int ElioGetNode(FILE *fp, int step, int node, ElcircHeader *h, float *t, int *it, int *bind, int *sind, float *d);
 int ElioGetNodeOld(FILE *fp, int step, int node, ElcircHeader *h, float *t, int *it, float *d);
 int ElioExtractNode(ElcircTimeStep *t, ElcircHeader *h, int node, int bind, int sind, float *d);
-int ElioGetXYData(FILE * fp, int step, double x, double y, ElcircHeader *h, float *t, int *it, int *bind, int *sind, float *d);
-int ElioGetXYData2(FILE * fp, int step, int elem,  ElcircHeader *h, double *hh, float *t, int *it, int *bind, int *sind, float *d);
-int ElioInterpTimeStep(ElcircHeader *h, int elem, double x, double y, double *hh, ElcircTimeStep *t, int *bind, int *sind, float *d);
+int ElioGetXYData(FILE * fp, int step, double x, double y, ElcircHeader *h, float *t, int *it, int *bind, int *sind,
+		float *d);
+int ElioGetXYData2(FILE * fp, int step, int elem, ElcircHeader *h, double *hh, float *t, int *it, int *bind, int *sind,
+		float *d);
+int ElioInterpTimeStep(ElcircHeader *h, int elem, double x, double y, double *hh, ElcircTimeStep *t, int *bind,
+		int *sind, float *d);
 
 int ElioGetPoint(FILE *fp, int step, int node, int level, ElcircHeader *h, float *t, int *it, float *d);
 /*! create a scalar data set compatible with the old format */
@@ -236,14 +243,16 @@
 int ElioInPolygon(double x, double y, int n, double *xlist, double *ylist);
 int ElioFindElementXY(ElcircHeader *h, double x, double y);
 int ElioInsideElement(double x, double y, double x1, double y1, double x2, double y2, double x3, double y3);
-int ElioInsideElement4(double x, double y, double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4);
+int ElioInsideElement4(double x, double y, double x1, double y1, double x2, double y2, double x3, double y3, double x4,
+		double y4);
 
 /*! Interpolators */
 int ElioEvalFlowXY(int n, double *h, double *u, double *v, double *uret, double *vret);
-int ElioEvalScalarXY(int , double *, double *u, double *uret);
-int ElioEval(int , double *, double *u, double *uret);
+int ElioEvalScalarXY(int, double *, double *u, double *uret);
+int ElioEval(int, double *, double *u, double *uret);
 int ElioGetCoefficients(ElcircHeader *h, int elem, double xp, double yp, double *w);
-int ibilinear(double x1, double x2, double x3, double x4, double y1, double y2, double y3, double y4, double x, double y, double *xi, double *eta, double *shapef);
+int ibilinear(double x1, double x2, double x3, double x4, double y1, double y2, double y3, double y4, double x,
+		double y, double *xi, double *eta, double *shapef);
 /*! Get the depths for an interpolated point. */
 int ElioGetZPos(ElcircHeader *h, double d, double e, int *ilev1, int *ilev2, double *zpos);
 
@@ -258,7 +267,8 @@
 int ElioGetBottomStep(ElcircHeader *h1, ElcircHeader *h2, ElcircTimeStep t1, ElcircTimeStep *t2);
 /* Transect values */
 int ElioGetTransectHeader(ElcircHeader *h1, int n, double *x, double *y, ElcircHeader *h2);
-int ElioGetTransectStep(ElcircHeader *h1, ElcircHeader *h2, int step, int n, double *x, double *y, ElcircTimeStep t1, ElcircTimeStep *t2);
+int ElioGetTransectStep(ElcircHeader *h1, ElcircHeader *h2, int step, int n, double *x, double *y, ElcircTimeStep t1,
+		ElcircTimeStep *t2);
 /* A single level */
 int ElioGetLevelHeader(ElcircHeader *h1, ElcircHeader *h2);
 int ElioGetLevelStep(ElcircHeader *h1, ElcircHeader *h2, ElcircTimeStep t1, int level, ElcircTimeStep *t2);
@@ -296,4 +306,8 @@
 void ElioGetYearDay(double jd, int *y, int *yd, int *h, int *mi, double *sec);
 void ElioSetCorieTime(int b);
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif /* ELIO_H */
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/expr.cc gridfields/clib/src/expr.cc
--- tag/gridfieldsclib-0.7/src/expr.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/expr.cc	2014-05-16 22:57:00.743391866 +0200
@@ -1,248 +1,263 @@
+#include "config_gridfields.h"
+
 #include <string>
 #include <iostream>
 #include <sstream>
+#include <algorithm>
+
 #include "expr.h"
 #include "gridfield.h"
 #include "tuple.h"
 #include "type.h"
 #include "fparser.hh"
 extern "C" {
-  #include <stdarg.h>
+#include <stdarg.h>
 }
 
 using namespace std;
 
+namespace GF {
 
-TupleFunction::TupleFunction() {
-  SaveReservedWords();
-}
-  
-void TupleFunction::deleteFunctions() {
-  if (!functions.empty()) {
-    delete [] bindings;
-  }
-  map<string, FunctionParser *>::iterator p;
-  for (p=functions.begin(); p!=functions.end(); p++) {
-    delete p->second;
-  }
-}
-
-TupleFunction::~TupleFunction() {
-  deleteFunctions();
-}
-
-void TupleFunction::Parse(string unparsedExpr) {
-
-  // release memory if we've already parsed an expression.
-  deleteFunctions();
-   
-  //extracts input and output types
-  //and builds a function parser object
-  vector<string> attribute_exprs;
-  int pos;
-  while (true) {
-    pos = unparsedExpr.find("\n");
-    if (pos == (signed)string::npos) break;
-    unparsedExpr[pos] = ' ';
-  } 
-  split(unparsedExpr, ";", attribute_exprs);
-
-  int n = attribute_exprs.size();
-  if (n==0) Fatal("No attribute expressions found");
-  
-  vector<string> equation;
-  set<string> input_attributes;
-  vector<string> vars;
-  
-  
-  map<string, string> expr;
-  
-  for (int i=0; i<n; i++) {
-    string rawexp = attribute_exprs[i];
-    int pos = rawexp.find("=");
-    if (pos == -1) {
-      Fatal("Malformed attribute expression: %s", rawexp.c_str());
-    } else {
-      equation.push_back(rawexp.substr(0, pos));
-      equation.push_back(rawexp.substr(pos+1));
-    }
-
-    // parse expression for variable names
-    getVars(equation[1], vars);
-      
-    //find the unique input attributes mentioned in any expression
-    input_attributes.insert(vars.begin(), vars.end());
-    
-    string attr = remove_whitespace(equation[0]);
-    expr[attr] = equation[1];
-    vars.clear();
-    equation.clear();
-  }
-
-  // build the input type, and the string list of variables for fparser.
-  set<string>::iterator si;
-  string varstr = "";  
-  for (si=input_attributes.begin(); si!=input_attributes.end(); si++) {
-    this->inScheme.addAttribute((*si), FLOAT);
-    varstr = varstr + *si + ",";
-  }
-
-  //construct the function objects for evaluation,
-  //parse the expressions, and build the output type.
-  map<string, string>::iterator p;
-  FunctionParser *fp;
-    
-  for (p=expr.begin(); p!=expr.end(); p++) {
-    this->outScheme.addAttribute(p->first, FLOAT);
-    fp = new FunctionParser();
-    this->functions[p->first] = fp;
-    
-    if (fp->Parse(p->second, varstr) != -1)
-      Fatal("Parse error: %s: %s", equation[1].c_str(), fp->ErrorMsg());
-  }
-
-  bindings = new double[inScheme.size()];
-}
-
-void TupleFunction::Eval(Tuple &intup, Tuple &outtup) {
-  //both tuples should be of the correct type and have space reserved.
-    
-  double answer=0;
-  float *valptr;
-  
-  map<string, FunctionParser *>::iterator p;
-  BindVars(intup, bindings);
-  assert(!intup.isNull());
-  assert(!outtup.isNull());
-
-  for (p=functions.begin(); p!=functions.end(); p++) { 
-    answer = p->second->Eval(bindings);
-    //cout << answer << endl;
-    valptr = (float *) outtup.get(p->first);
-    *valptr = (float) answer;
-  }
-}
-
-void SpecializedTupleFunction::SpecializeFor(Scheme &out) {
-  for (unsigned int i=0; i<inScheme.size(); i++) {
-    string const &attr = inScheme.getAttribute(i);
-    in_position_map[i] = make_pair(out.getPosition(attr), out.getType(attr));
-  }
-                                                                                 
-  map<string,  FunctionParser *>::iterator p;
-  for (p=functions.begin(); p!=functions.end(); p++) {
-                                                                                 
-    out_position_map[outScheme.getPosition(p->first)] =
-                 make_pair(out.getPosition(p->first), p->second);
-  }
-                                                                                 
-   in_tup_size = inScheme.size();
-}
-
-
-void SpecializedTupleFunction::Eval(Tuple &intup, Tuple &outtup) {
-  //both tuples should be of the correct type and have space reserved.
-    
-  double answer=0;
-  float *valptr;
-    
-  hash_map<int, pair<int, Type> >::iterator p;
-  
-   // cout << endl;
-  for (int i=0; i<in_tup_size; i++) {
-    p = in_position_map.find(i);
-    if (p->second.second == FLOAT) {
-      //cout << "i=" << p->second.first << ", ";
-      //cout << intup.tupledata.size() << endl;
-      int id = p->second.first;
-      float foo = *(float *) intup.tupledata[id];
-      //bindings[i] = *(float *) intup.tupledata[p->second.first];
-      bindings[i] = foo;
-      //cout << bindings[i] << endl;
-    } else {
-      bindings[i] = float(*(int *) intup.tupledata[p->second.first]);
-    }
-  }
-
-  hash_map<int, pair<int, FunctionParser *> >::iterator q;
-  for (q=out_position_map.begin(); q!=out_position_map.end(); q++) { 
-    valptr = (float *) outtup.tupledata[q->second.first];
-    answer = q->second.second->Eval(bindings);
-    *valptr = (float) answer;
-  }
-}
-
-void TupleFunction::BindVars(Tuple &intup, double *bindings) {
-  string var;
-  Scheme *real_inScheme = intup.getScheme();
-  for (unsigned int i=0; i<inScheme.size(); i++) {
-    var = inScheme.getAttribute(i);
-    if (real_inScheme->getType(var) == FLOAT) {
-      bindings[i] = *(float *)intup.get(var);
-    } else {
-      bindings[i] = float(*(int *)intup.get(var));
-    }
-  }
-}
-
-
-void TupleFunction::getVars(string expr, vector<string> &retval) {
-    
-  string var("");
-  unsigned int i=0;
-
-  while (i<expr.length()) {
-    //variables begin with an alpha and are not reserved words
-    if (isalpha(expr[i])) {
-      while (isalpha(expr[i]) || expr[i] == '_' || isdigit(expr[i])) {
-        var = var + expr[i++];
-      }
-        
-      // if not a reserved word
-      if (reservedWords.find(var) == reservedWords.end())
-        // and if not already added (using a vector to maintain order)
-        if (find(retval.begin(), retval.end(), var) == retval.end()) 
-          // insert it
-          retval.push_back(var);      
-
-      var = "";
-    }
-    i++;
-  }
-}
-
-void TupleFunction::SaveReservedWords() {
-
-  set<string> &vars = reservedWords;
-  vars.insert("sqrt");
-  vars.insert("abs");
-  vars.insert("acos");
-  vars.insert("acosh");
-  vars.insert("asin");
-  vars.insert("asinh");
-  vars.insert("atan");
-  vars.insert("atan2");
-  vars.insert("atanh");
-  vars.insert("ceil");
-  vars.insert("cos");
-  vars.insert("cosh");
-  vars.insert("cot");
-  vars.insert("csc");
-  vars.insert("eval");
-  vars.insert("exp");
-  vars.insert("floor");
-  vars.insert("if");
-  vars.insert("int");
-  vars.insert("log");
-  vars.insert("log10");
-  vars.insert("max");
-  vars.insert("min");
-  vars.insert("sec");
-  vars.insert("sin");
-  vars.insert("sinh");
-  vars.insert("sqrt");
-  vars.insert("tan");
-  vars.insert("tanh");
+TupleFunction::TupleFunction()
+{
+	SaveReservedWords();
+}
+
+void TupleFunction::deleteFunctions()
+{
+	if (!functions.empty()) {
+		delete[] bindings;
+	}
+	map<string, FunctionParser *>::iterator p;
+	for (p = functions.begin(); p != functions.end(); p++) {
+		delete p->second;
+	}
+}
+
+TupleFunction::~TupleFunction()
+{
+	deleteFunctions();
+}
+
+void TupleFunction::Parse(string unparsedExpr)
+{
+
+	// release memory if we've already parsed an expression.
+	deleteFunctions();
+
+	//extracts input and output types
+	//and builds a function parser object
+	vector<string> attribute_exprs;
+	int pos;
+	while (true) {
+		pos = unparsedExpr.find("\n");
+		if (pos == (signed) string::npos) break;
+		unparsedExpr[pos] = ' ';
+	}
+	split(unparsedExpr, ";", attribute_exprs);
+
+	int n = attribute_exprs.size();
+	if (n == 0) Fatal("No attribute expressions found");
+
+	vector<string> equation;
+	set<string> input_attributes;
+	vector<string> vars;
+
+	map<string, string> expr;
+
+	for (int i = 0; i < n; i++) {
+		string rawexp = attribute_exprs[i];
+		int pos = rawexp.find("=");
+		if (pos == -1) {
+			Fatal("Malformed attribute expression: %s", rawexp.c_str());
+		}
+		else {
+			equation.push_back(rawexp.substr(0, pos));
+			equation.push_back(rawexp.substr(pos + 1));
+		}
+
+		// parse expression for variable names
+		getVars(equation[1], vars);
+
+		//find the unique input attributes mentioned in any expression
+		input_attributes.insert(vars.begin(), vars.end());
+
+		string attr = remove_whitespace(equation[0]);
+		expr[attr] = equation[1];
+		vars.clear();
+		equation.clear();
+	}
+
+	// build the input type, and the string list of variables for fparser.
+	set<string>::iterator si;
+	string varstr = "";
+	for (si = input_attributes.begin(); si != input_attributes.end(); si++) {
+		this->inScheme.addAttribute((*si), FLOAT);
+		varstr = varstr + *si + ",";
+	}
+
+	//construct the function objects for evaluation,
+	//parse the expressions, and build the output type.
+	map<string, string>::iterator p;
+	FunctionParser *fp;
+
+	for (p = expr.begin(); p != expr.end(); p++) {
+		this->outScheme.addAttribute(p->first, FLOAT);
+		fp = new FunctionParser();
+		this->functions[p->first] = fp;
+
+		if (fp->Parse(p->second, varstr) != -1) Fatal("Parse error: %s: %s", equation[1].c_str(), fp->ErrorMsg());
+	}
+
+	bindings = new double[inScheme.size()];
+}
+
+void TupleFunction::Eval(Tuple &intup, Tuple &outtup)
+{
+	//both tuples should be of the correct type and have space reserved.
+
+	double answer = 0;
+	float *valptr;
+
+	map<string, FunctionParser *>::iterator p;
+	BindVars(intup, bindings);
+	assert(!intup.isNull());
+	assert(!outtup.isNull());
+
+	for (p = functions.begin(); p != functions.end(); p++) {
+		answer = p->second->Eval(bindings);
+		//cout << answer << endl;
+		valptr = (float *) outtup.get(p->first);
+		*valptr = (float) answer;
+	}
+}
+
+void SpecializedTupleFunction::SpecializeFor(Scheme &out)
+{
+	for (unsigned int i = 0; i < inScheme.size(); i++) {
+		string const &attr = inScheme.getAttribute(i);
+		in_position_map[i] = make_pair(out.getPosition(attr), out.getType(attr));
+	}
+
+	map<string, FunctionParser *>::iterator p;
+	for (p = functions.begin(); p != functions.end(); p++) {
+
+		out_position_map[outScheme.getPosition(p->first)] = make_pair(out.getPosition(p->first), p->second);
+	}
+
+	in_tup_size = inScheme.size();
+}
+
+void SpecializedTupleFunction::Eval(Tuple &intup, Tuple &outtup)
+{
+	//both tuples should be of the correct type and have space reserved.
+
+	double answer = 0;
+	float *valptr;
+
+	HASH_MAP<int, pair<int, Type> >::iterator p;
+
+	// cout << endl;
+	for (int i = 0; i < in_tup_size; i++) {
+		p = in_position_map.find(i);
+		if (p->second.second == FLOAT) {
+			//cout << "i=" << p->second.first << ", ";
+			//cout << intup.tupledata.size() << endl;
+			int id = p->second.first;
+			float foo = *(float *) intup.tupledata[id];
+			//bindings[i] = *(float *) intup.tupledata[p->second.first];
+			bindings[i] = foo;
+			//cout << bindings[i] << endl;
+		}
+		else {
+			bindings[i] = float(*(int *) intup.tupledata[p->second.first]);
+		}
+	}
+
+	HASH_MAP<int, pair<int, FunctionParser *> >::iterator q;
+	for (q = out_position_map.begin(); q != out_position_map.end(); q++) {
+		valptr = (float *) outtup.tupledata[q->second.first];
+		answer = q->second.second->Eval(bindings);
+		*valptr = (float) answer;
+	}
+}
+
+void TupleFunction::BindVars(Tuple &intup, double *bindings)
+{
+	string var;
+	Scheme *real_inScheme = intup.getScheme();
+	for (unsigned int i = 0; i < inScheme.size(); i++) {
+		var = inScheme.getAttribute(i);
+		if (real_inScheme->getType(var) == FLOAT) {
+			bindings[i] = *(float *) intup.get(var);
+		}
+		else {
+			bindings[i] = float(*(int *) intup.get(var));
+		}
+	}
+}
+
+void TupleFunction::getVars(string expr, vector<string> &retval)
+{
+
+	string var("");
+	unsigned int i = 0;
+
+	while (i < expr.length()) {
+		//variables begin with an alpha and are not reserved words
+		if (isalpha(expr[i])) {
+			while (isalpha(expr[i]) || expr[i] == '_' || isdigit(expr[i])) {
+				var = var + expr[i++];
+			}
+
+			// if not a reserved word
+			if (reservedWords.find(var) == reservedWords.end())
+			// and if not already added (using a vector to maintain order)
+				if (find(retval.begin(), retval.end(), var) == retval.end())
+				// insert it
+					retval.push_back(var);
+
+			var = "";
+		}
+		i++;
+	}
+}
+
+void TupleFunction::SaveReservedWords()
+{
+
+	set<string> &vars = reservedWords;
+	vars.insert("sqrt");
+	vars.insert("abs");
+	vars.insert("acos");
+	vars.insert("acosh");
+	vars.insert("asin");
+	vars.insert("asinh");
+	vars.insert("atan");
+	vars.insert("atan2");
+	vars.insert("atanh");
+	vars.insert("ceil");
+	vars.insert("cos");
+	vars.insert("cosh");
+	vars.insert("cot");
+	vars.insert("csc");
+	vars.insert("eval");
+	vars.insert("exp");
+	vars.insert("floor");
+	vars.insert("if");
+	vars.insert("int");
+	vars.insert("log");
+	vars.insert("log10");
+	vars.insert("max");
+	vars.insert("min");
+	vars.insert("sec");
+	vars.insert("sin");
+	vars.insert("sinh");
+	vars.insert("sqrt");
+	vars.insert("tan");
+	vars.insert("tanh");
 
 }
 
+} // namespace GF
+
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/expr.h gridfields/clib/src/expr.h
--- tag/gridfieldsclib-0.7/src/expr.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/expr.h	2014-05-16 22:57:00.776725199 +0200
@@ -4,39 +4,66 @@
 #include "type.h"
 #include "gridfield.h"
 #include "fparser.hh"
+
+#include "gridfields_hash_map.h"
+
+#if 0
+#ifdef HAVE_UNORDERED_MAP
+#include <unordered_map>
+#define HASH_MAP std::unordered_map
+#else
 #include <ext/hash_map>
+#define HASH_MAP hash_map
+#endif
+#endif
+
+namespace GF {
+
+#if 0
+#ifndef HAVE_UNORDERED_MAP
+using namespace __gnu_cxx;  // for hash_map jhrg 4/16/12
+#endif
+#endif
 
 class TupleFunction {
-  public:
-    TupleFunction();
-    ~TupleFunction();
-    void Parse(string tupleexpr);
-    Scheme *ReturnType() { return &outScheme; };
-    Scheme *InputType() { return &inScheme; };
-    void Eval(Tuple &input, Tuple &output);
-  private:
-    void SaveReservedWords();
-    void BindVars(Tuple &intup, double *bindings);
-    void getVars(string expr, vector<string> &returnval);
-    void deleteFunctions();
-    set<string> reservedWords;
-  protected:
-    map<string, FunctionParser *> functions;
-    double *bindings;
-    Scheme inScheme;
-    Scheme outScheme;
+public:
+	TupleFunction();
+	~TupleFunction();
+	void Parse(string tupleexpr);
+	Scheme *ReturnType()
+	{
+		return &outScheme;
+	}
+	;
+	Scheme *InputType()
+	{
+		return &inScheme;
+	}
+	;
+	void Eval(Tuple &input, Tuple &output);
+private:
+	void SaveReservedWords();
+	void BindVars(Tuple &intup, double *bindings);
+	void getVars(string expr, vector<string> &returnval);
+	void deleteFunctions();
+	set<string> reservedWords;
+protected:
+	map<string, FunctionParser *> functions;
+	double *bindings;
+	Scheme inScheme;
+	Scheme outScheme;
 };
 
-class SpecializedTupleFunction : public TupleFunction {
-  public:
-    void SpecializeFor(Scheme &out);
-    void Eval(Tuple &in, Tuple &out);
-  private:
-    int in_tup_size;
-    hash_map<int, pair<int, Type> > in_position_map;
-    hash_map<int, pair<int, FunctionParser *> > out_position_map;
+class SpecializedTupleFunction: public TupleFunction {
+public:
+	void SpecializeFor(Scheme &out);
+	void Eval(Tuple &in, Tuple &out);
+private:
+	int in_tup_size;HASH_MAP<int, pair<int, Type> > in_position_map;
+	HASH_MAP<int, pair<int, FunctionParser *> > out_position_map;
 };
 
+} // namespace GF
+
 #endif /* _EXPR_H */
-    
 
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/fparser.cc gridfields/clib/src/fparser.cc
--- tag/gridfieldsclib-0.7/src/fparser.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/fparser.cc	2014-05-16 22:57:00.730058533 +0200
@@ -2,6 +2,8 @@
 // Function parser v2.8 by Warp
 //==============================
 
+#include "config_gridfields.h"
+
 #include "fparser.hh"
 #include "fpconfig.hh"
 #include "fptypes.hh"
@@ -15,377 +17,334 @@
 
 using namespace std;
 
+namespace GF {
+
 #ifndef M_PI
 #define M_PI 3.1415926535897932384626433832795
 #endif
 
-namespace
-{
-    const unsigned FUNC_AMOUNT = sizeof(Functions)/sizeof(Functions[0]);
-
+namespace {
+const unsigned FUNC_AMOUNT = sizeof(Functions) / sizeof(Functions[0]);
 
-    // BCB4 does not implement the standard lower_bound function.
-    // This is used instead:
-    const FuncDefinition* fp_lower_bound(const FuncDefinition* first,
-                                         const FuncDefinition* last,
-                                         const FuncDefinition& value)
-    {
-        while(first < last)
-        {
-            const FuncDefinition* middle = first+(last-first)/2;
-            if(*middle < value) first = middle+1;
-            else last = middle;
-        }
-        return last;
-    }
-
-
-    // Returns a pointer to the FuncDefinition instance which 'name' is
-    // the same as the one given by 'F'. If no such function name exists,
-    // returns 0.
-    inline const FuncDefinition* FindFunction(const char* F)
-    {
-        FuncDefinition func = { F, 0, 0, 0 };
-        while(isalnum(F[func.nameLength])) ++func.nameLength;
-        if(func.nameLength)
-        {
-            const FuncDefinition* found =
-                fp_lower_bound(Functions, Functions+FUNC_AMOUNT, func);
-            if(found == Functions+FUNC_AMOUNT || func < *found)
-                return 0;
-            return found;
-        }
-        return 0;
-    }
+// BCB4 does not implement the standard lower_bound function.
+// This is used instead:
+const FuncDefinition* fp_lower_bound(const FuncDefinition* first, const FuncDefinition* last,
+		const FuncDefinition& value)
+{
+	while (first < last) {
+		const FuncDefinition* middle = first + (last - first) / 2;
+		if (*middle < value)
+			first = middle + 1;
+		else
+			last = middle;
+	}
+	return last;
+}
+
+// Returns a pointer to the FuncDefinition instance which 'name' is
+// the same as the one given by 'F'. If no such function name exists,
+// returns 0.
+inline const FuncDefinition* FindFunction(const char* F)
+{
+	FuncDefinition func = { F, 0, 0, 0 };
+	while (isalnum(F[func.nameLength]))
+		++func.nameLength;
+	if (func.nameLength) {
+		const FuncDefinition* found = fp_lower_bound(Functions, Functions + FUNC_AMOUNT, func);
+		if (found == Functions + FUNC_AMOUNT || func < *found) return 0;
+		return found;
+	}
+	return 0;
+}
 }
-
 
 //---------------------------------------------------------------------------
 // Copy-on-write method
 //---------------------------------------------------------------------------
 void FunctionParser::copyOnWrite()
 {
-    if(data->referenceCounter > 1)
-    {
-        Data* oldData = data;
-        data = new Data(*oldData);
-        --(oldData->referenceCounter);
-        data->referenceCounter = 1;
-    }
+	if (data->referenceCounter > 1) {
+		Data* oldData = data;
+		data = new Data(*oldData);
+		--(oldData->referenceCounter);
+		data->referenceCounter = 1;
+	}
 }
 
-
 //---------------------------------------------------------------------------
 // Constructors and destructors
 //---------------------------------------------------------------------------
 //===========================================================================
-FunctionParser::FunctionParser():
-    parseErrorType(FP_NO_ERROR), evalErrorType(0),
-    data(new Data),
-    evalRecursionLevel(0)
+FunctionParser::FunctionParser() :
+		parseErrorType(FP_NO_ERROR), evalErrorType(0), data(new Data), evalRecursionLevel(0)
 {
-    data->referenceCounter = 1;
+	data->referenceCounter = 1;
 }
 
 FunctionParser::~FunctionParser()
 {
-    if(--(data->referenceCounter) == 0)
-    {
-        delete data;
-    }
+	if (--(data->referenceCounter) == 0) {
+		delete data;
+	}
 }
 
-FunctionParser::FunctionParser(const FunctionParser& cpy):
-    parseErrorType(cpy.parseErrorType),
-    evalErrorType(cpy.evalErrorType),
-    data(cpy.data),
-    evalRecursionLevel(0)
+FunctionParser::FunctionParser(const FunctionParser& cpy) :
+		parseErrorType(cpy.parseErrorType), evalErrorType(cpy.evalErrorType), data(cpy.data), evalRecursionLevel(0)
 {
-    ++(data->referenceCounter);
+	++(data->referenceCounter);
 }
 
 FunctionParser& FunctionParser::operator=(const FunctionParser& cpy)
 {
-    if(data != cpy.data)
-    {
-        if(--(data->referenceCounter) == 0) delete data;
+	if (data != cpy.data) {
+		if (--(data->referenceCounter) == 0) delete data;
 
-        parseErrorType = cpy.parseErrorType;
-        evalErrorType = cpy.evalErrorType;
-        data = cpy.data;
-        evalRecursionLevel = cpy.evalRecursionLevel;
+		parseErrorType = cpy.parseErrorType;
+		evalErrorType = cpy.evalErrorType;
+		data = cpy.data;
+		evalRecursionLevel = cpy.evalRecursionLevel;
 
-        ++(data->referenceCounter);
-    }
+		++(data->referenceCounter);
+	}
 
-    return *this;
+	return *this;
 }
 
-
-FunctionParser::Data::Data():
-    useDegreeConversion(false),
-    ByteCode(0), ByteCodeSize(0),
-    Immed(0), ImmedSize(0),
-    Stack(0), StackSize(0)
-{}
+FunctionParser::Data::Data() :
+		useDegreeConversion(false), ByteCode(0), ByteCodeSize(0), Immed(0), ImmedSize(0), Stack(0), StackSize(0)
+{
+}
 
 FunctionParser::Data::~Data()
 {
-    if(ByteCode) { delete[] ByteCode; ByteCode=0; }
-    if(Immed) { delete[] Immed; Immed=0; }
-    if(Stack) { delete[] Stack; Stack=0; }
+	if (ByteCode) {
+		delete[] ByteCode;
+		ByteCode = 0;
+	}
+	if (Immed) {
+		delete[] Immed;
+		Immed = 0;
+	}
+	if (Stack) {
+		delete[] Stack;
+		Stack = 0;
+	}
 }
 
 // Makes a deep-copy of Data:
-FunctionParser::Data::Data(const Data& cpy):
-    varAmount(cpy.varAmount), useDegreeConversion(cpy.useDegreeConversion),
-    Variables(cpy.Variables), Constants(cpy.Constants),
-    FuncPtrNames(cpy.FuncPtrNames), FuncPtrs(cpy.FuncPtrs),
-    FuncParserNames(cpy.FuncParserNames), FuncParsers(cpy.FuncParsers),
-    ByteCode(0), ByteCodeSize(cpy.ByteCodeSize),
-    Immed(0), ImmedSize(cpy.ImmedSize),
-    Stack(0), StackSize(cpy.StackSize)
-{
-    if(ByteCodeSize) ByteCode = new unsigned[ByteCodeSize];
-    if(ImmedSize) Immed = new double[ImmedSize];
-    if(StackSize) Stack = new double[StackSize];
-
-    for(unsigned i=0; i<ByteCodeSize; ++i) ByteCode[i] = cpy.ByteCode[i];
-    for(unsigned i=0; i<ImmedSize; ++i) Immed[i] = cpy.Immed[i];
+FunctionParser::Data::Data(const Data& cpy) :
+		varAmount(cpy.varAmount), useDegreeConversion(cpy.useDegreeConversion), Variables(cpy.Variables), Constants(
+				cpy.Constants), FuncPtrNames(cpy.FuncPtrNames), FuncPtrs(cpy.FuncPtrs), FuncParserNames(
+				cpy.FuncParserNames), FuncParsers(cpy.FuncParsers), ByteCode(0), ByteCodeSize(cpy.ByteCodeSize), Immed(
+				0), ImmedSize(cpy.ImmedSize), Stack(0), StackSize(cpy.StackSize)
+{
+	if (ByteCodeSize) ByteCode = new unsigned[ByteCodeSize];
+	if (ImmedSize) Immed = new double[ImmedSize];
+	if (StackSize) Stack = new double[StackSize];
+
+	for (unsigned i = 0; i < ByteCodeSize; ++i)
+		ByteCode[i] = cpy.ByteCode[i];
+	for (unsigned i = 0; i < ImmedSize; ++i)
+		Immed[i] = cpy.Immed[i];
 
-    // No need to copy the stack contents because it's obsolete outside Eval()
+	// No need to copy the stack contents because it's obsolete outside Eval()
 }
 
-
 //---------------------------------------------------------------------------
 // Function parsing
 //---------------------------------------------------------------------------
 //===========================================================================
-namespace
-{
-    // Error messages returned by ErrorMsg():
-    const char* ParseErrorMessage[]=
-    {
-        "Syntax error",                             // 0
-        "Mismatched parenthesis",                   // 1
-        "Missing ')'",                              // 2
-        "Empty parentheses",                        // 3
-        "Syntax error: Operator expected",          // 4
-        "Not enough memory",                        // 5
-        "An unexpected error occurred. Please make a full bug report "
-        "to the author",                            // 6
-        "Syntax error in parameter 'Vars' given to "
-        "FunctionParser::Parse()",                  // 7
-        "Illegal number of parameters to function", // 8
-        "Syntax error: Premature end of string",    // 9
-        "Syntax error: Expecting ( after function", // 10
-        ""
-    };
-
-
-    // Parse variables
-    bool ParseVars(const string& Vars, map<string, unsigned>& dest)
-    {
-        unsigned varNumber = VarBegin;
-        unsigned ind1 = 0, ind2;
-
-        while(ind1 < Vars.size())
-        {
-            if(!isalpha(Vars[ind1]) && Vars[ind1]!='_') return false;
-            for(ind2=ind1+1; ind2<Vars.size() && Vars[ind2]!=','; ++ind2)
-                if(!isalnum(Vars[ind2]) && Vars[ind2]!='_') return false;
-            const string varName = Vars.substr(ind1, ind2-ind1);
-
-            if(dest.insert(make_pair(varName, varNumber++)).second == false)
-                return false;
-
-            ind1 = ind2+1;
-        }
-        return true;
-    }
+namespace {
+// Error messages returned by ErrorMsg():
+const char* ParseErrorMessage[] = { "Syntax error",                             // 0
+		"Mismatched parenthesis",                   // 1
+		"Missing ')'",                              // 2
+		"Empty parentheses",                        // 3
+		"Syntax error: Operator expected",          // 4
+		"Not enough memory",                        // 5
+		"An unexpected error occurred. Please make a full bug report "
+				"to the author",                            // 6
+		"Syntax error in parameter 'Vars' given to "
+				"FunctionParser::Parse()",                  // 7
+		"Illegal number of parameters to function", // 8
+		"Syntax error: Premature end of string",    // 9
+		"Syntax error: Expecting ( after function", // 10
+		"" };
+
+// Parse variables
+bool ParseVars(const string& Vars, map<string, unsigned>& dest)
+{
+	unsigned varNumber = VarBegin;
+	unsigned ind1 = 0, ind2;
+
+	while (ind1 < Vars.size()) {
+		if (!isalpha(Vars[ind1]) && Vars[ind1] != '_') return false;
+		for (ind2 = ind1 + 1; ind2 < Vars.size() && Vars[ind2] != ','; ++ind2)
+			if (!isalnum(Vars[ind2]) && Vars[ind2] != '_') return false;
+		const string varName = Vars.substr(ind1, ind2 - ind1);
+
+		if (dest.insert(make_pair(varName, varNumber++)).second == false) return false;
+
+		ind1 = ind2 + 1;
+	}
+	return true;
+}
 }
 
 bool FunctionParser::isValidName(const std::string& name) const
 {
-    if(name.empty() || (!isalpha(name[0]) && name[0] != '_')) return false;
-    for(unsigned i=0; i<name.size(); ++i)
-        if(!isalnum(name[i]) && name[i] != '_') return false;
+	if (name.empty() || (!isalpha(name[0]) && name[0] != '_')) return false;
+	for (unsigned i = 0; i < name.size(); ++i)
+		if (!isalnum(name[i]) && name[i] != '_') return false;
 
-    if(FindFunction(name.c_str())) return false;
+	if (FindFunction(name.c_str())) return false;
 
-    return true;
+	return true;
 }
 
-
 // Constants:
 bool FunctionParser::AddConstant(const string& name, double value)
 {
-    if(isValidName(name))
-    {
-        const char* n = name.c_str();
-        if(FindVariable(n, data->FuncParserNames) !=
-           data->FuncParserNames.end() ||
-           FindVariable(n, data->FuncPtrNames) !=
-           data->FuncPtrNames.end())
-            return false;
-
-        copyOnWrite();
-
-        data->Constants[name] = value;
-        return true;
-    }
-    return false;
+	if (isValidName(name)) {
+		const char* n = name.c_str();
+		if (FindVariable(n, data->FuncParserNames) != data->FuncParserNames.end()
+				|| FindVariable(n, data->FuncPtrNames) != data->FuncPtrNames.end()) return false;
+
+		copyOnWrite();
+
+		data->Constants[name] = value;
+		return true;
+	}
+	return false;
 }
 
 // Function pointers
-bool FunctionParser::AddFunction(const std::string& name,
-                                 FunctionPtr func, unsigned paramsAmount)
+bool FunctionParser::AddFunction(const std::string& name, FunctionPtr func, unsigned paramsAmount)
 {
-    if(isValidName(name))
-    {
-        const char* n = name.c_str();
-        if(FindVariable(n, data->FuncParserNames) !=
-           data->FuncParserNames.end() ||
-           FindConstant(n) != data->Constants.end())
-            return false;
-
-        copyOnWrite();
-
-        data->FuncPtrNames[name] = data->FuncPtrs.size();
-        data->FuncPtrs.push_back(Data::FuncPtrData(func, paramsAmount));
-        return true;
-    }
-    return false;
+	if (isValidName(name)) {
+		const char* n = name.c_str();
+		if (FindVariable(n, data->FuncParserNames) != data->FuncParserNames.end()
+				|| FindConstant(n) != data->Constants.end()) return false;
+
+		copyOnWrite();
+
+		data->FuncPtrNames[name] = data->FuncPtrs.size();
+		data->FuncPtrs.push_back(Data::FuncPtrData(func, paramsAmount));
+		return true;
+	}
+	return false;
 }
 
 bool FunctionParser::checkRecursiveLinking(const FunctionParser* fp) const
 {
-    if(fp == this) return true;
-    for(unsigned i=0; i<fp->data->FuncParsers.size(); ++i)
-        if(checkRecursiveLinking(fp->data->FuncParsers[i])) return true;
-    return false;
-}
-
-bool FunctionParser::AddFunction(const std::string& name,
-                                 FunctionParser& parser)
-{
-    if(isValidName(name))
-    {
-        const char* n = name.c_str();
-        if(FindVariable(n, data->FuncPtrNames) != data->FuncPtrNames.end() ||
-           FindConstant(n) != data->Constants.end())
-            return false;
-
-        if(checkRecursiveLinking(&parser)) return false;
-
-        copyOnWrite();
-
-        data->FuncParserNames[name] = data->FuncParsers.size();
-        data->FuncParsers.push_back(&parser);
-        return true;
-    }
-    return false;
+	if (fp == this) return true;
+	for (unsigned i = 0; i < fp->data->FuncParsers.size(); ++i)
+		if (checkRecursiveLinking(fp->data->FuncParsers[i])) return true;
+	return false;
 }
 
+bool FunctionParser::AddFunction(const std::string& name, FunctionParser& parser)
+{
+	if (isValidName(name)) {
+		const char* n = name.c_str();
+		if (FindVariable(n, data->FuncPtrNames) != data->FuncPtrNames.end() || FindConstant(n) != data->Constants.end())
+			return false;
+
+		if (checkRecursiveLinking(&parser)) return false;
 
+		copyOnWrite();
+
+		data->FuncParserNames[name] = data->FuncParsers.size();
+		data->FuncParsers.push_back(&parser);
+		return true;
+	}
+	return false;
+}
 
 // Main parsing function
 // ---------------------
-int FunctionParser::Parse(const std::string& Function,
-                          const std::string& Vars,
-                          bool useDegrees)
+int FunctionParser::Parse(const std::string& Function, const std::string& Vars, bool useDegrees)
 {
-    copyOnWrite();
+	copyOnWrite();
 
-    data->Variables.clear();
+	data->Variables.clear();
 
-    if(!ParseVars(Vars, data->Variables))
-    {
-        parseErrorType = INVALID_VARS;
-        return Function.size();
-    }
-    data->varAmount = data->Variables.size(); // this is for Eval()
+	if (!ParseVars(Vars, data->Variables)) {
+		parseErrorType = INVALID_VARS;
+		return Function.size();
+	}
+	data->varAmount = data->Variables.size(); // this is for Eval()
 
-    const char* Func = Function.c_str();
+	const char* Func = Function.c_str();
 
-    parseErrorType = FP_NO_ERROR;
+	parseErrorType = FP_NO_ERROR;
 
-    int Result = CheckSyntax(Func);
-    if(Result>=0) return Result;
+	int Result = CheckSyntax(Func);
+	if (Result >= 0) return Result;
 
-    data->useDegreeConversion = useDegrees;
-    if(!Compile(Func)) return Function.size();
+	data->useDegreeConversion = useDegrees;
+	if (!Compile(Func)) return Function.size();
 
-    data->Variables.clear();
+	data->Variables.clear();
 
-    parseErrorType = FP_NO_ERROR;
-    return -1;
+	parseErrorType = FP_NO_ERROR;
+	return -1;
 }
 
-namespace
+namespace {
+const char* const fpOperators[] = { "+", "-", "*", "/", "%", "^", "=", "!=", "<=", "<", ">=", ">", "&", "|", 0 };
+
+// Is given char an operator?
+// (Returns 0 if not, else the size of the operator)
+inline int IsOperator(const char* F)
 {
-    const char* const fpOperators[] =
-    {
-        "+", "-", "*", "/", "%", "^",
-        "=", "!=", "<=", "<", ">=", ">", "&", "|",
-        0
-    };
-
-    // Is given char an operator?
-    // (Returns 0 if not, else the size of the operator)
-    inline int IsOperator(const char* F)
-    {
-        for(unsigned opInd = 0; fpOperators[opInd]; ++opInd)
-        {
-            const char* op = fpOperators[opInd];
-            for(unsigned n = 0; F[n] == *op; ++n)
-            {
-                ++op;
-                if(*op == 0) return op-fpOperators[opInd];
-            }
-        }
-        return 0;
-    }
-
-    // skip whitespace
-    inline void sws(const char* F, int& Ind)
-    {
-        while(F[Ind] && isspace(F[Ind])) ++Ind;
-    }
+	for (unsigned opInd = 0; fpOperators[opInd]; ++opInd) {
+		const char* op = fpOperators[opInd];
+		for (unsigned n = 0; F[n] == *op; ++n) {
+			++op;
+			if (*op == 0) return op - fpOperators[opInd];
+		}
+	}
+	return 0;
+}
+
+// skip whitespace
+inline void sws(const char* F, int& Ind)
+{
+	while (F[Ind] && isspace(F[Ind]))
+		++Ind;
+}
 }
 
 // Returns an iterator to the variable with the same name as 'F', or to
 // Variables.end() if no such variable exists:
-inline FunctionParser::Data::VarMap_t::const_iterator
-FunctionParser::FindVariable(const char* F, const Data::VarMap_t& vars) const
+inline FunctionParser::Data::VarMap_t::const_iterator FunctionParser::FindVariable(const char* F,
+		const Data::VarMap_t& vars) const
 {
-    if(vars.size())
-    {
-        unsigned ind = 0;
-        while(isalnum(F[ind]) || F[ind] == '_') ++ind;
-        if(ind)
-        {
-            string name(F, ind);
-            return vars.find(name);
-        }
-    }
-    return vars.end();
-}
-
-inline FunctionParser::Data::ConstMap_t::const_iterator
-FunctionParser::FindConstant(const char* F) const
-{
-    if(data->Constants.size())
-    {
-        unsigned ind = 0;
-        while(isalnum(F[ind]) || F[ind] == '_') ++ind;
-        if(ind)
-        {
-            string name(F, ind);
-            return data->Constants.find(name);
-        }
-    }
-    return data->Constants.end();
+	if (vars.size()) {
+		unsigned ind = 0;
+		while (isalnum(F[ind]) || F[ind] == '_')
+			++ind;
+		if (ind) {
+			string name(F, ind);
+			return vars.find(name);
+		}
+	}
+	return vars.end();
+}
+
+inline FunctionParser::Data::ConstMap_t::const_iterator FunctionParser::FindConstant(const char* F) const
+{
+	if (data->Constants.size()) {
+		unsigned ind = 0;
+		while (isalnum(F[ind]) || F[ind] == '_')
+			++ind;
+		if (ind) {
+			string name(F, ind);
+			return data->Constants.find(name);
+		}
+	}
+	return data->Constants.end();
 }
 
 //---------------------------------------------------------------------------
@@ -393,966 +352,1064 @@
 // ----------------------------
 int FunctionParser::CheckSyntax(const char* Function)
 {
-    const Data::VarMap_t& Variables = data->Variables;
-    const Data::ConstMap_t& Constants = data->Constants;
-    const Data::VarMap_t& FuncPtrNames = data->FuncPtrNames;
-    const Data::VarMap_t& FuncParserNames = data->FuncParserNames;
-
-    vector<int> functionParenthDepth;
-
-    int Ind=0, ParenthCnt=0, c;
-    char* Ptr;
-
-    while(true)
-    {
-        sws(Function, Ind);
-        c=Function[Ind];
+	const Data::VarMap_t& Variables = data->Variables;
+	const Data::ConstMap_t& Constants = data->Constants;
+	const Data::VarMap_t& FuncPtrNames = data->FuncPtrNames;
+	const Data::VarMap_t& FuncParserNames = data->FuncParserNames;
+
+	vector<int> functionParenthDepth;
+
+	int Ind = 0, ParenthCnt = 0, c;
+	char* Ptr;
+
+	while (true) {
+		sws(Function, Ind);
+		c = Function[Ind];
 
 // Check for valid operand (must appear)
 
-        // Check for leading - or !
-        if(c=='-' || c=='!') { sws(Function, ++Ind); c=Function[Ind]; }
-        if(c==0) { parseErrorType=PREMATURE_EOS; return Ind; }
-
-        // Check for math function
-        bool foundFunc = false;
-        const FuncDefinition* fptr = FindFunction(&Function[Ind]);
-        if(fptr)
-        {
-            Ind += fptr->nameLength;
-            foundFunc = true;
-        }
-        else
-        {
-            // Check for user-defined function
-            Data::VarMap_t::const_iterator fIter =
-                FindVariable(&Function[Ind], FuncPtrNames);
-            if(fIter != FuncPtrNames.end())
-            {
-                Ind += fIter->first.size();
-                foundFunc = true;
-            }
-            else
-            {
-                Data::VarMap_t::const_iterator pIter =
-                    FindVariable(&Function[Ind], FuncParserNames);
-                if(pIter != FuncParserNames.end())
-                {
-                    Ind += pIter->first.size();
-                    foundFunc = true;
-                }
-            }
-        }
-
-        if(foundFunc)
-        {
-            sws(Function, Ind);
-            c = Function[Ind];
-            if(c!='(') { parseErrorType=EXPECT_PARENTH_FUNC; return Ind; }
-
-            int Ind2 = Ind+1;
-            sws(Function, Ind2);
-            if(Function[Ind2] == ')')
-            {
-                Ind = Ind2+1;
-                sws(Function, Ind);
-                c = Function[Ind];
-                // Ugly, but other methods would just be uglier...
-                goto CheckOperator;
-            }
-
-            functionParenthDepth.push_back(ParenthCnt+1);
-        }
-
-        // Check for opening parenthesis
-        if(c=='(')
-        {
-            ++ParenthCnt;
-            sws(Function, ++Ind);
-            if(Function[Ind]==')') { parseErrorType=EMPTY_PARENTH; return Ind;}
-            continue;
-        }
-
-        // Check for number
-        if(isdigit(c) || (c=='.' && isdigit(Function[Ind+1])))
-        {
-         double creturn=   strtod(&Function[Ind], &Ptr);(void)creturn;
-            Ind += int(Ptr-&Function[Ind]);
-            sws(Function, Ind);
-            c = Function[Ind];
-        }
-        else
-        { // Check for variable
-            Data::VarMap_t::const_iterator vIter =
-                FindVariable(&Function[Ind], Variables);
-            if(vIter != Variables.end())
-                Ind += vIter->first.size();
-            else
-            {
-                // Check for constant
-                Data::ConstMap_t::const_iterator cIter =
-                    FindConstant(&Function[Ind]);
-                if(cIter != Constants.end())
-                    Ind += cIter->first.size();
-                else
-                { parseErrorType=SYNTAX_ERROR; return Ind; }
-            }
-            sws(Function, Ind);
-            c = Function[Ind];
-        }
-
-        // Check for closing parenthesis
-        while(c==')')
-        {
-            if(functionParenthDepth.size() &&
-               functionParenthDepth.back() == ParenthCnt)
-                functionParenthDepth.pop_back();
-            if((--ParenthCnt)<0) { parseErrorType=MISM_PARENTH; return Ind; }
-            sws(Function, ++Ind);
-            c=Function[Ind];
-        }
+		// Check for leading - or !
+		if (c == '-' || c == '!') {
+			sws(Function, ++Ind);
+			c = Function[Ind];
+		}
+		if (c == 0) {
+			parseErrorType = PREMATURE_EOS;
+			return Ind;
+		}
+
+		// Check for math function
+		bool foundFunc = false;
+		const FuncDefinition* fptr = FindFunction(&Function[Ind]);
+		if (fptr) {
+			Ind += fptr->nameLength;
+			foundFunc = true;
+		}
+		else {
+			// Check for user-defined function
+			Data::VarMap_t::const_iterator fIter = FindVariable(&Function[Ind], FuncPtrNames);
+			if (fIter != FuncPtrNames.end()) {
+				Ind += fIter->first.size();
+				foundFunc = true;
+			}
+			else {
+				Data::VarMap_t::const_iterator pIter = FindVariable(&Function[Ind], FuncParserNames);
+				if (pIter != FuncParserNames.end()) {
+					Ind += pIter->first.size();
+					foundFunc = true;
+				}
+			}
+		}
+
+		if (foundFunc) {
+			sws(Function, Ind);
+			c = Function[Ind];
+			if (c != '(') {
+				parseErrorType = EXPECT_PARENTH_FUNC;
+				return Ind;
+			}
+
+			int Ind2 = Ind + 1;
+			sws(Function, Ind2);
+			if (Function[Ind2] == ')') {
+				Ind = Ind2 + 1;
+				sws(Function, Ind);
+				c = Function[Ind];
+				// Ugly, but other methods would just be uglier...
+				goto CheckOperator;
+			}
+
+			functionParenthDepth.push_back(ParenthCnt + 1);
+		}
+
+		// Check for opening parenthesis
+		if (c == '(') {
+			++ParenthCnt;
+			sws(Function, ++Ind);
+			if (Function[Ind] == ')') {
+				parseErrorType = EMPTY_PARENTH;
+				return Ind;
+			}
+			continue;
+		}
+
+		// Check for number
+		if (isdigit(c) || (c == '.' && isdigit(Function[Ind + 1]))) {
+			double creturn = strtod(&Function[Ind], &Ptr);
+			(void) creturn;
+			Ind += int(Ptr - &Function[Ind]);
+			sws(Function, Ind);
+			c = Function[Ind];
+		}
+		else { // Check for variable
+			Data::VarMap_t::const_iterator vIter = FindVariable(&Function[Ind], Variables);
+			if (vIter != Variables.end())
+				Ind += vIter->first.size();
+			else {
+				// Check for constant
+				Data::ConstMap_t::const_iterator cIter = FindConstant(&Function[Ind]);
+				if (cIter != Constants.end())
+					Ind += cIter->first.size();
+				else {
+					parseErrorType = SYNTAX_ERROR;
+					return Ind;
+				}
+			}
+			sws(Function, Ind);
+			c = Function[Ind];
+		}
+
+		// Check for closing parenthesis
+		while (c == ')') {
+			if (functionParenthDepth.size() && functionParenthDepth.back() == ParenthCnt)
+				functionParenthDepth.pop_back();
+			if ((--ParenthCnt) < 0) {
+				parseErrorType = MISM_PARENTH;
+				return Ind;
+			}
+			sws(Function, ++Ind);
+			c = Function[Ind];
+		}
 
 // If we get here, we have a legal operand and now a legal operator or
 // end of string must follow
 
-    CheckOperator:
-        // Check for EOS
-        if(c==0) break; // The only way to end the checking loop without error
-
-        // Check for operator
-        int opSize = 0;
-        if(c == ',' && !functionParenthDepth.empty() &&
-           functionParenthDepth.back() == ParenthCnt)
-            opSize = 1;
-        else
-            opSize = IsOperator(Function+Ind);
-        if(opSize == 0)
-        { parseErrorType=EXPECT_OPERATOR; return Ind; }
+		CheckOperator:
+		// Check for EOS
+		if (c == 0) break; // The only way to end the checking loop without error
+
+		// Check for operator
+		int opSize = 0;
+		if (c == ',' && !functionParenthDepth.empty() && functionParenthDepth.back() == ParenthCnt)
+			opSize = 1;
+		else
+			opSize = IsOperator(Function + Ind);
+		if (opSize == 0) {
+			parseErrorType = EXPECT_OPERATOR;
+			return Ind;
+		}
 
 // If we get here, we have an operand and an operator; the next loop will
 // check for another operand (must appear)
-        Ind += opSize;
-    } // while
+		Ind += opSize;
+	} // while
 
-    // Check that all opened parentheses are also closed
-    if(ParenthCnt>0) { parseErrorType=MISSING_PARENTH; return Ind; }
+	// Check that all opened parentheses are also closed
+	if (ParenthCnt > 0) {
+		parseErrorType = MISSING_PARENTH;
+		return Ind;
+	}
 
 // The string is ok
-    parseErrorType=FP_NO_ERROR;
-    return -1;
+	parseErrorType = FP_NO_ERROR;
+	return -1;
 }
 
-
 // Compile function string to bytecode
 // -----------------------------------
 bool FunctionParser::Compile(const char* Function)
 {
-    if(data->ByteCode) { delete[] data->ByteCode; data->ByteCode=0; }
-    if(data->Immed) { delete[] data->Immed; data->Immed=0; }
-    if(data->Stack) { delete[] data->Stack; data->Stack=0; }
-
-    vector<unsigned> byteCode; byteCode.reserve(1024);
-    tempByteCode = &byteCode;
-
-    vector<double> immed; immed.reserve(1024);
-    tempImmed = &immed;
-
-    data->StackSize = StackPtr = 0;
-
-    CompileExpression(Function, 0);
-    if(parseErrorType != FP_NO_ERROR) return false;
-
-    data->ByteCodeSize = byteCode.size();
-    data->ImmedSize = immed.size();
-
-    if(data->ByteCodeSize)
-    {
-        data->ByteCode = new unsigned[data->ByteCodeSize];
-        memcpy(data->ByteCode, &byteCode[0],
-               sizeof(unsigned)*data->ByteCodeSize);
-    }
-    if(data->ImmedSize)
-    {
-        data->Immed = new double[data->ImmedSize];
-        memcpy(data->Immed, &immed[0],
-               sizeof(double)*data->ImmedSize);
-    }
-    if(data->StackSize)
-        data->Stack = new double[data->StackSize];
+	if (data->ByteCode) {
+		delete[] data->ByteCode;
+		data->ByteCode = 0;
+	}
+	if (data->Immed) {
+		delete[] data->Immed;
+		data->Immed = 0;
+	}
+	if (data->Stack) {
+		delete[] data->Stack;
+		data->Stack = 0;
+	}
+
+	vector<unsigned> byteCode;
+	byteCode.reserve(1024);
+	tempByteCode = &byteCode;
+
+	vector<double> immed;
+	immed.reserve(1024);
+	tempImmed = &immed;
+
+	data->StackSize = StackPtr = 0;
+
+	CompileExpression(Function, 0);
+	if (parseErrorType != FP_NO_ERROR) return false;
+
+	data->ByteCodeSize = byteCode.size();
+	data->ImmedSize = immed.size();
+
+	if (data->ByteCodeSize) {
+		data->ByteCode = new unsigned[data->ByteCodeSize];
+		memcpy(data->ByteCode, &byteCode[0], sizeof(unsigned) * data->ByteCodeSize);
+	}
+	if (data->ImmedSize) {
+		data->Immed = new double[data->ImmedSize];
+		memcpy(data->Immed, &immed[0], sizeof(double) * data->ImmedSize);
+	}
+	if (data->StackSize) data->Stack = new double[data->StackSize];
 
-    return true;
+	return true;
 }
 
-
 inline void FunctionParser::AddCompiledByte(unsigned c)
 {
-    tempByteCode->push_back(c);
+	tempByteCode->push_back(c);
 }
 
 inline void FunctionParser::AddImmediate(double i)
 {
-    tempImmed->push_back(i);
+	tempImmed->push_back(i);
 }
 
 inline void FunctionParser::AddFunctionOpcode(unsigned opcode)
 {
-    if(data->useDegreeConversion)
-        switch(opcode)
-        {
-          case cCos:
-          case cCosh:
-          case cCot:
-          case cCsc:
-          case cSec:
-          case cSin:
-          case cSinh:
-          case cTan:
-          case cTanh:
-              AddCompiledByte(cRad);
-        }
-
-    AddCompiledByte(opcode);
-
-    if(data->useDegreeConversion)
-        switch(opcode)
-        {
-          case cAcos:
+	if (data->useDegreeConversion) switch (opcode) {
+	case cCos:
+	case cCosh:
+	case cCot:
+	case cCsc:
+	case cSec:
+	case cSin:
+	case cSinh:
+	case cTan:
+	case cTanh:
+		AddCompiledByte(cRad);
+	}
+
+	AddCompiledByte(opcode);
+
+	if (data->useDegreeConversion) switch (opcode) {
+	case cAcos:
 #ifndef NO_ASINH
-          case cAcosh:
-          case cAsinh:
-          case cAtanh:
+		case cAcosh:
+		case cAsinh:
+		case cAtanh:
 #endif
-          case cAsin:
-          case cAtan:
-          case cAtan2:
-              AddCompiledByte(cDeg);
-        }
+	case cAsin:
+	case cAtan:
+	case cAtan2:
+		AddCompiledByte(cDeg);
+	}
 }
 
 inline void FunctionParser::incStackPtr()
 {
-    if(++StackPtr > data->StackSize) ++(data->StackSize);
+	if (++StackPtr > data->StackSize) ++(data->StackSize);
 }
 
-
 // Compile if()
 int FunctionParser::CompileIf(const char* F, int ind)
 {
-    int ind2 = CompileExpression(F, ind, true); // condition
-    sws(F, ind2);
-    if(F[ind2] != ',') { parseErrorType=ILL_PARAMS_AMOUNT; return ind2; }
-    AddCompiledByte(cIf);
-    unsigned curByteCodeSize = tempByteCode->size();
-    AddCompiledByte(0); // Jump index; to be set later
-    AddCompiledByte(0); // Immed jump index; to be set later
-
-    --StackPtr;
-
-    ind2 = CompileExpression(F, ind2+1, true); // then
-    sws(F, ind2);
-    if(F[ind2] != ',') { parseErrorType=ILL_PARAMS_AMOUNT; return ind2; }
-    AddCompiledByte(cJump);
-    unsigned curByteCodeSize2 = tempByteCode->size();
-    unsigned curImmedSize2 = tempImmed->size();
-    AddCompiledByte(0); // Jump index; to be set later
-    AddCompiledByte(0); // Immed jump index; to be set later
-
-    --StackPtr;
-
-    ind2 = CompileExpression(F, ind2+1, true); // else
-    sws(F, ind2);
-    if(F[ind2] != ')') { parseErrorType=ILL_PARAMS_AMOUNT; return ind2; }
-
-    // Set jump indices
-    (*tempByteCode)[curByteCodeSize] = curByteCodeSize2+1;
-    (*tempByteCode)[curByteCodeSize+1] = curImmedSize2;
-    (*tempByteCode)[curByteCodeSize2] = tempByteCode->size()-1;
-    (*tempByteCode)[curByteCodeSize2+1] = tempImmed->size();
-
-    return ind2+1;
-}
-
-int FunctionParser::CompileFunctionParams(const char* F, int ind,
-                                          unsigned requiredParams)
-{
-    int ind2 = ind;
-    if(requiredParams > 0)
-    {
-        unsigned curStackPtr = StackPtr;
-        ind2 = CompileExpression(F, ind);
-
-        if(StackPtr != curStackPtr+requiredParams)
-        { parseErrorType=ILL_PARAMS_AMOUNT; return ind; }
-
-        StackPtr -= requiredParams - 1;
-    }
-    else
-    {
-        incStackPtr();
-    }
+	int ind2 = CompileExpression(F, ind, true); // condition
+	sws(F, ind2);
+	if (F[ind2] != ',') {
+		parseErrorType = ILL_PARAMS_AMOUNT;
+		return ind2;
+	}
+	AddCompiledByte(cIf);
+	unsigned curByteCodeSize = tempByteCode->size();
+	AddCompiledByte(0); // Jump index; to be set later
+	AddCompiledByte(0); // Immed jump index; to be set later
+
+	--StackPtr;
+
+	ind2 = CompileExpression(F, ind2 + 1, true); // then
+	sws(F, ind2);
+	if (F[ind2] != ',') {
+		parseErrorType = ILL_PARAMS_AMOUNT;
+		return ind2;
+	}
+	AddCompiledByte(cJump);
+	unsigned curByteCodeSize2 = tempByteCode->size();
+	unsigned curImmedSize2 = tempImmed->size();
+	AddCompiledByte(0); // Jump index; to be set later
+	AddCompiledByte(0); // Immed jump index; to be set later
+
+	--StackPtr;
+
+	ind2 = CompileExpression(F, ind2 + 1, true); // else
+	sws(F, ind2);
+	if (F[ind2] != ')') {
+		parseErrorType = ILL_PARAMS_AMOUNT;
+		return ind2;
+	}
+
+	// Set jump indices
+	(*tempByteCode)[curByteCodeSize] = curByteCodeSize2 + 1;
+	(*tempByteCode)[curByteCodeSize + 1] = curImmedSize2;
+	(*tempByteCode)[curByteCodeSize2] = tempByteCode->size() - 1;
+	(*tempByteCode)[curByteCodeSize2 + 1] = tempImmed->size();
+
+	return ind2 + 1;
+}
+
+int FunctionParser::CompileFunctionParams(const char* F, int ind, unsigned requiredParams)
+{
+	int ind2 = ind;
+	if (requiredParams > 0) {
+		unsigned curStackPtr = StackPtr;
+		ind2 = CompileExpression(F, ind);
+
+		if (StackPtr != curStackPtr + requiredParams) {
+			parseErrorType = ILL_PARAMS_AMOUNT;
+			return ind;
+		}
+
+		StackPtr -= requiredParams - 1;
+	}
+	else {
+		incStackPtr();
+	}
 
-    sws(F, ind2);
-    return ind2+1; // F[ind2] is ')'
+	sws(F, ind2);
+	return ind2 + 1; // F[ind2] is ')'
 }
 
 // Compiles element
 int FunctionParser::CompileElement(const char* F, int ind)
 {
-    sws(F, ind);
-    char c = F[ind];
+	sws(F, ind);
+	char c = F[ind];
 
-    if(c == '(')
-    {
-        ind = CompileExpression(F, ind+1);
-        sws(F, ind);
-        return ind+1; // F[ind] is ')'
-    }
-
-    if(isdigit(c) || c=='.' /*|| c=='-'*/) // Number
-    {
-        const char* startPtr = &F[ind];
-        char* endPtr;
-        double val = strtod(startPtr, &endPtr);
-        AddImmediate(val);
-        AddCompiledByte(cImmed);
-        incStackPtr();
-        return ind+(endPtr-startPtr);
-    }
-
-    if(isalpha(c) || c == '_') // Function, variable or constant
-    {
-        const FuncDefinition* func = FindFunction(F+ind);
-        if(func) // is function
-        {
-            int ind2 = ind + func->nameLength;
-            sws(F, ind2); // F[ind2] is '('
-            if(strcmp(func->name, "if") == 0) // "if" is a special case
-            {
-                return CompileIf(F, ind2+1);
-            }
+	if (c == '(') {
+		ind = CompileExpression(F, ind + 1);
+		sws(F, ind);
+		return ind + 1; // F[ind] is ')'
+	}
+
+	if (isdigit(c) || c == '.' /*|| c=='-'*/) // Number
+			{
+		const char* startPtr = &F[ind];
+		char* endPtr;
+		double val = strtod(startPtr, &endPtr);
+		AddImmediate(val);
+		AddCompiledByte(cImmed);
+		incStackPtr();
+		return ind + (endPtr - startPtr);
+	}
+
+	if (isalpha(c) || c == '_') // Function, variable or constant
+			{
+		const FuncDefinition* func = FindFunction(F + ind);
+		if (func) // is function
+		{
+			int ind2 = ind + func->nameLength;
+			sws(F, ind2); // F[ind2] is '('
+			if (strcmp(func->name, "if") == 0) // "if" is a special case
+					{
+				return CompileIf(F, ind2 + 1);
+			}
 
 #ifndef DISABLE_EVAL
-            unsigned requiredParams =
-                strcmp(func->name, "eval") == 0 ?
-                data->Variables.size() : func->params;
+			unsigned requiredParams = strcmp(func->name, "eval") == 0 ? data->Variables.size() : func->params;
 #else
-            unsigned requiredParams = func->params;
+			unsigned requiredParams = func->params;
 #endif
-            ind2 = CompileFunctionParams(F, ind2+1, requiredParams);
-            AddFunctionOpcode(func->opcode);
-            return ind2; // F[ind2-1] is ')'
-        }
-
-        Data::VarMap_t::const_iterator vIter =
-            FindVariable(F+ind, data->Variables);
-        if(vIter != data->Variables.end()) // is variable
-        {
-            AddCompiledByte(vIter->second);
-            incStackPtr();
-            return ind + vIter->first.size();
-        }
-
-        Data::ConstMap_t::const_iterator cIter = FindConstant(F+ind);
-        if(cIter != data->Constants.end()) // is constant
-        {
-            AddImmediate(cIter->second);
-            AddCompiledByte(cImmed);
-            incStackPtr();
-            return ind + cIter->first.size();
-        }
-
-        Data::VarMap_t::const_iterator fIter =
-            FindVariable(F+ind, data->FuncPtrNames);
-        if(fIter != data->FuncPtrNames.end()) // is user-defined func pointer
-        {
-            unsigned index = fIter->second;
-
-            int ind2 = ind + fIter->first.length();
-            sws(F, ind2); // F[ind2] is '('
-
-            ind2 = CompileFunctionParams(F, ind2+1,
-                                         data->FuncPtrs[index].params);
-
-            AddCompiledByte(cFCall);
-            AddCompiledByte(index);
-            return ind2;
-        }
-
-        Data::VarMap_t::const_iterator pIter =
-            FindVariable(F+ind, data->FuncParserNames);
-        if(pIter != data->FuncParserNames.end()) // is user-defined func parser
-        {
-            unsigned index = pIter->second;
-
-            int ind2 = ind + pIter->first.length();
-            sws(F, ind2); // F[ind2] is '('
-
-            ind2 = CompileFunctionParams
-                (F, ind2+1, data->FuncParsers[index]->data->varAmount);
-
-            AddCompiledByte(cPCall);
-            AddCompiledByte(index);
-            return ind2;
-        }
-    }
+			ind2 = CompileFunctionParams(F, ind2 + 1, requiredParams);
+			AddFunctionOpcode(func->opcode);
+			return ind2; // F[ind2-1] is ')'
+		}
+
+		Data::VarMap_t::const_iterator vIter = FindVariable(F + ind, data->Variables);
+		if (vIter != data->Variables.end()) // is variable
+				{
+			AddCompiledByte(vIter->second);
+			incStackPtr();
+			return ind + vIter->first.size();
+		}
+
+		Data::ConstMap_t::const_iterator cIter = FindConstant(F + ind);
+		if (cIter != data->Constants.end()) // is constant
+				{
+			AddImmediate(cIter->second);
+			AddCompiledByte(cImmed);
+			incStackPtr();
+			return ind + cIter->first.size();
+		}
+
+		Data::VarMap_t::const_iterator fIter = FindVariable(F + ind, data->FuncPtrNames);
+		if (fIter != data->FuncPtrNames.end()) // is user-defined func pointer
+				{
+			unsigned index = fIter->second;
+
+			int ind2 = ind + fIter->first.length();
+			sws(F, ind2); // F[ind2] is '('
+
+			ind2 = CompileFunctionParams(F, ind2 + 1, data->FuncPtrs[index].params);
+
+			AddCompiledByte(cFCall);
+			AddCompiledByte(index);
+			return ind2;
+		}
+
+		Data::VarMap_t::const_iterator pIter = FindVariable(F + ind, data->FuncParserNames);
+		if (pIter != data->FuncParserNames.end()) // is user-defined func parser
+				{
+			unsigned index = pIter->second;
+
+			int ind2 = ind + pIter->first.length();
+			sws(F, ind2); // F[ind2] is '('
+
+			ind2 = CompileFunctionParams(F, ind2 + 1, data->FuncParsers[index]->data->varAmount);
+
+			AddCompiledByte(cPCall);
+			AddCompiledByte(index);
+			return ind2;
+		}
+	}
 
-    parseErrorType = UNEXPECTED_ERROR;
-    return ind;
+	parseErrorType = UNEXPECTED_ERROR;
+	return ind;
 }
 
 // Compiles '^'
 int FunctionParser::CompilePow(const char* F, int ind)
 {
-    int ind2 = CompileElement(F, ind);
-    sws(F, ind2);
+	int ind2 = CompileElement(F, ind);
+	sws(F, ind2);
 
-    while(F[ind2] == '^')
-    {
-        ind2 = CompileUnaryMinus(F, ind2+1);
-        sws(F, ind2);
-        AddCompiledByte(cPow);
-        --StackPtr;
-    }
+	while (F[ind2] == '^') {
+		ind2 = CompileUnaryMinus(F, ind2 + 1);
+		sws(F, ind2);
+		AddCompiledByte(cPow);
+		--StackPtr;
+	}
 
-    return ind2;
+	return ind2;
 }
 
 // Compiles unary '-'
 int FunctionParser::CompileUnaryMinus(const char* F, int ind)
 {
-    sws(F, ind);
-    if(F[ind] == '-' || F[ind] == '!')
-    {
-        int ind2 = ind+1;
-        sws(F, ind2);
-        ind2 = CompilePow(F, ind2);
-        sws(F, ind2);
-
-        // if we are negating a constant, negate the constant itself:
-        if(F[ind] == '-' && tempByteCode->back() == cImmed)
-            tempImmed->back() = -tempImmed->back();
-
-        // if we are negating a negation, we can remove both:
-        else if((F[ind] == '-' && tempByteCode->back() == cNeg))
-            tempByteCode->pop_back();
-
-        else
-            AddCompiledByte(F[ind] == '-' ? cNeg : cNot);
-
-        return ind2;
-    }
-
-    int ind2 = CompilePow(F, ind);
-    sws(F, ind2);
-    return ind2;
+	sws(F, ind);
+	if (F[ind] == '-' || F[ind] == '!') {
+		int ind2 = ind + 1;
+		sws(F, ind2);
+		ind2 = CompilePow(F, ind2);
+		sws(F, ind2);
+
+		// if we are negating a constant, negate the constant itself:
+		if (F[ind] == '-' && tempByteCode->back() == cImmed)
+			tempImmed->back() = -tempImmed->back();
+
+		// if we are negating a negation, we can remove both:
+		else if ((F[ind] == '-' && tempByteCode->back() == cNeg))
+			tempByteCode->pop_back();
+
+		else
+			AddCompiledByte(F[ind] == '-' ? cNeg : cNot);
+
+		return ind2;
+	}
+
+	int ind2 = CompilePow(F, ind);
+	sws(F, ind2);
+	return ind2;
 }
 
 // Compiles '*', '/' and '%'
 int FunctionParser::CompileMult(const char* F, int ind)
 {
-    int ind2 = CompileUnaryMinus(F, ind);
-    sws(F, ind2);
-    char op;
-
-    while((op = F[ind2]) == '*' || op == '/' || op == '%')
-    {
-        ind2 = CompileUnaryMinus(F, ind2+1);
-        sws(F, ind2);
-        switch(op)
-        {
-          case '*': AddCompiledByte(cMul); break;
-          case '/': AddCompiledByte(cDiv); break;
-          case '%': AddCompiledByte(cMod); break;
-        }
-        --StackPtr;
-    }
+	int ind2 = CompileUnaryMinus(F, ind);
+	sws(F, ind2);
+	char op;
+
+	while ((op = F[ind2]) == '*' || op == '/' || op == '%') {
+		ind2 = CompileUnaryMinus(F, ind2 + 1);
+		sws(F, ind2);
+		switch (op) {
+		case '*':
+			AddCompiledByte(cMul);
+			break;
+		case '/':
+			AddCompiledByte(cDiv);
+			break;
+		case '%':
+			AddCompiledByte(cMod);
+			break;
+		}
+		--StackPtr;
+	}
 
-    return ind2;
+	return ind2;
 }
 
 // Compiles '+' and '-'
 int FunctionParser::CompileAddition(const char* F, int ind)
 {
-    int ind2 = CompileMult(F, ind);
-    sws(F, ind2);
-    char op;
-
-    while((op = F[ind2]) == '+' || op == '-')
-    {
-        ind2 = CompileMult(F, ind2+1);
-        sws(F, ind2);
-        AddCompiledByte(op=='+' ? cAdd : cSub);
-        --StackPtr;
-    }
+	int ind2 = CompileMult(F, ind);
+	sws(F, ind2);
+	char op;
+
+	while ((op = F[ind2]) == '+' || op == '-') {
+		ind2 = CompileMult(F, ind2 + 1);
+		sws(F, ind2);
+		AddCompiledByte(op == '+' ? cAdd : cSub);
+		--StackPtr;
+	}
 
-    return ind2;
+	return ind2;
 }
 
 // Compiles '=', '<' and '>'
 int FunctionParser::CompileComparison(const char* F, int ind)
 {
-    int ind2 = CompileAddition(F, ind);
-    sws(F, ind2);
-    char op;
-
-    while((op = F[ind2]) == '=' || op == '<' || op == '>' || op == '!')
-    {
-        int opSize = (F[ind2+1] == '=' ? 2 : 1);
-        ind2 = CompileAddition(F, ind2+opSize);
-        sws(F, ind2);
-        switch(op)
-        {
-          case '=':
-              AddCompiledByte(cEqual); break;
-          case '<':
-              AddCompiledByte(opSize == 1 ? cLess : cLessOrEq); break;
-          case '>':
-              AddCompiledByte(opSize == 1 ? cGreater : cGreaterOrEq); break;
-          case '!':
-              AddCompiledByte(cNEqual); break;
-        }
-        --StackPtr;
-    }
+	int ind2 = CompileAddition(F, ind);
+	sws(F, ind2);
+	char op;
+
+	while ((op = F[ind2]) == '=' || op == '<' || op == '>' || op == '!') {
+		int opSize = (F[ind2 + 1] == '=' ? 2 : 1);
+		ind2 = CompileAddition(F, ind2 + opSize);
+		sws(F, ind2);
+		switch (op) {
+		case '=':
+			AddCompiledByte(cEqual);
+			break;
+		case '<':
+			AddCompiledByte(opSize == 1 ? cLess : cLessOrEq);
+			break;
+		case '>':
+			AddCompiledByte(opSize == 1 ? cGreater : cGreaterOrEq);
+			break;
+		case '!':
+			AddCompiledByte(cNEqual);
+			break;
+		}
+		--StackPtr;
+	}
 
-    return ind2;
+	return ind2;
 }
 
 // Compiles '&'
 int FunctionParser::CompileAnd(const char* F, int ind)
 {
-    int ind2 = CompileComparison(F, ind);
-    sws(F, ind2);
+	int ind2 = CompileComparison(F, ind);
+	sws(F, ind2);
 
-    while(F[ind2] == '&')
-    {
-        ind2 = CompileComparison(F, ind2+1);
-        sws(F, ind2);
-        AddCompiledByte(cAnd);
-        --StackPtr;
-    }
+	while (F[ind2] == '&') {
+		ind2 = CompileComparison(F, ind2 + 1);
+		sws(F, ind2);
+		AddCompiledByte(cAnd);
+		--StackPtr;
+	}
 
-    return ind2;
+	return ind2;
 }
 
 // Compiles '|'
 int FunctionParser::CompileOr(const char* F, int ind)
 {
-    int ind2 = CompileAnd(F, ind);
-    sws(F, ind2);
+	int ind2 = CompileAnd(F, ind);
+	sws(F, ind2);
 
-    while(F[ind2] == '|')
-    {
-        ind2 = CompileAnd(F, ind2+1);
-        sws(F, ind2);
-        AddCompiledByte(cOr);
-        --StackPtr;
-    }
+	while (F[ind2] == '|') {
+		ind2 = CompileAnd(F, ind2 + 1);
+		sws(F, ind2);
+		AddCompiledByte(cOr);
+		--StackPtr;
+	}
 
-    return ind2;
+	return ind2;
 }
 
 // Compiles ','
 int FunctionParser::CompileExpression(const char* F, int ind, bool stopAtComma)
 {
-    int ind2 = CompileOr(F, ind);
-    sws(F, ind2);
+	int ind2 = CompileOr(F, ind);
+	sws(F, ind2);
 
-    if(stopAtComma) return ind2;
+	if (stopAtComma) return ind2;
 
-    while(F[ind2] == ',')
-    {
-        ind2 = CompileOr(F, ind2+1);
-        sws(F, ind2);
-    }
+	while (F[ind2] == ',') {
+		ind2 = CompileOr(F, ind2 + 1);
+		sws(F, ind2);
+	}
 
-    return ind2;
+	return ind2;
 }
 
-
 // Return parse error message
 // --------------------------
 const char* FunctionParser::ErrorMsg() const
 {
-    if(parseErrorType != FP_NO_ERROR) return ParseErrorMessage[parseErrorType];
-    return 0;
+	if (parseErrorType != FP_NO_ERROR) return ParseErrorMessage[parseErrorType];
+	return 0;
 }
 
 //---------------------------------------------------------------------------
 // Function evaluation
 //---------------------------------------------------------------------------
 //===========================================================================
-namespace
+namespace {
+inline int doubleToInt(double d)
+{
+	return d < 0 ? -int((-d) + .5) : int(d + .5);
+}
+
+inline double Min(double d1, double d2)
+{
+	return d1 < d2 ? d1 : d2;
+}
+inline double Max(double d1, double d2)
+{
+	return d1 > d2 ? d1 : d2;
+}
+
+inline double DegreesToRadians(double degrees)
+{
+	return degrees * (M_PI / 180.0);
+}
+inline double RadiansToDegrees(double radians)
 {
-    inline int doubleToInt(double d)
-    {
-        return d<0 ? -int((-d)+.5) : int(d+.5);
-    }
-
-    inline double Min(double d1, double d2)
-    {
-        return d1<d2 ? d1 : d2;
-    }
-    inline double Max(double d1, double d2)
-    {
-        return d1>d2 ? d1 : d2;
-    }
-
-
-    inline double DegreesToRadians(double degrees)
-    {
-        return degrees*(M_PI/180.0);
-    }
-    inline double RadiansToDegrees(double radians)
-    {
-        return radians*(180.0/M_PI);
-    }
+	return radians * (180.0 / M_PI);
+}
 }
 
 double FunctionParser::Eval(const double* Vars)
 {
-    const unsigned* const ByteCode = data->ByteCode;
-    const double* const Immed = data->Immed;
-    double* const Stack = data->Stack;
-    const unsigned ByteCodeSize = data->ByteCodeSize;
-    unsigned IP, DP=0;
-    int SP=-1;
-
-    for(IP=0; IP<ByteCodeSize; ++IP)
-    {
-        switch(ByteCode[IP])
-        {
+	const unsigned* const ByteCode = data->ByteCode;
+	const double* const Immed = data->Immed;
+	double* const Stack = data->Stack;
+	const unsigned ByteCodeSize = data->ByteCodeSize;
+	unsigned IP, DP = 0;
+	int SP = -1;
+
+	for (IP = 0; IP < ByteCodeSize; ++IP) {
+		switch (ByteCode[IP]) {
 // Functions:
-          case   cAbs: Stack[SP] = fabs(Stack[SP]); break;
-          case  cAcos: if(Stack[SP] < -1 || Stack[SP] > 1)
-                       { evalErrorType=4; return 0; }
-                       Stack[SP] = acos(Stack[SP]); break;
+		case cAbs:
+			Stack[SP] = fabs(Stack[SP]);
+			break;
+		case cAcos:
+			if (Stack[SP] < -1 || Stack[SP] > 1) {
+				evalErrorType = 4;
+				return 0;
+			}
+			Stack[SP] = acos(Stack[SP]);
+			break;
 #ifndef NO_ASINH
-          case cAcosh: Stack[SP] = acosh(Stack[SP]); break;
+			case cAcosh: Stack[SP] = acosh(Stack[SP]); break;
 #endif
-          case  cAsin: if(Stack[SP] < -1 || Stack[SP] > 1)
-                       { evalErrorType=4; return 0; }
-                       Stack[SP] = asin(Stack[SP]); break;
+		case cAsin:
+			if (Stack[SP] < -1 || Stack[SP] > 1) {
+				evalErrorType = 4;
+				return 0;
+			}
+			Stack[SP] = asin(Stack[SP]);
+			break;
 #ifndef NO_ASINH
-          case cAsinh: Stack[SP] = asinh(Stack[SP]); break;
+			case cAsinh: Stack[SP] = asinh(Stack[SP]); break;
 #endif
-          case  cAtan: Stack[SP] = atan(Stack[SP]); break;
-          case cAtan2: Stack[SP-1] = atan2(Stack[SP-1], Stack[SP]);
-                       --SP; break;
+		case cAtan:
+			Stack[SP] = atan(Stack[SP]);
+			break;
+		case cAtan2:
+			Stack[SP - 1] = atan2(Stack[SP - 1], Stack[SP]);
+			--SP;
+			break;
 #ifndef NO_ASINH
-          case cAtanh: Stack[SP] = atanh(Stack[SP]); break;
+			case cAtanh: Stack[SP] = atanh(Stack[SP]); break;
 #endif
-          case  cCeil: Stack[SP] = ceil(Stack[SP]); break;
-          case   cCos: Stack[SP] = cos(Stack[SP]); break;
-          case  cCosh: Stack[SP] = cosh(Stack[SP]); break;
-
-          case   cCot:
-              {
-                  double t = tan(Stack[SP]);
-                  if(t == 0) { evalErrorType=1; return 0; }
-                  Stack[SP] = 1/t; break;
-              }
-          case   cCsc:
-              {
-                  double s = sin(Stack[SP]);
-                  if(s == 0) { evalErrorType=1; return 0; }
-                  Stack[SP] = 1/s; break;
-              }
-
+		case cCeil:
+			Stack[SP] = ceil(Stack[SP]);
+			break;
+		case cCos:
+			Stack[SP] = cos(Stack[SP]);
+			break;
+		case cCosh:
+			Stack[SP] = cosh(Stack[SP]);
+			break;
+
+		case cCot: {
+			double t = tan(Stack[SP]);
+			if (t == 0) {
+				evalErrorType = 1;
+				return 0;
+			}
+			Stack[SP] = 1 / t;
+			break;
+		}
+		case cCsc: {
+			double s = sin(Stack[SP]);
+			if (s == 0) {
+				evalErrorType = 1;
+				return 0;
+			}
+			Stack[SP] = 1 / s;
+			break;
+		}
 
 #ifndef DISABLE_EVAL
-          case  cEval:
-              {
-                  double retVal = 0;
-                  if(evalRecursionLevel == EVAL_MAX_REC_LEVEL)
-                  {
-                      evalErrorType = 5;
-                  }
-                  else
-                  {
-                      data->Stack = new double[data->StackSize];
-                      ++evalRecursionLevel;
-                      retVal = Eval(&Stack[SP-data->varAmount+1]);
-                      --evalRecursionLevel;
-                      delete[] data->Stack;
-                      data->Stack = Stack;
-                  }
-                  SP -= data->varAmount-1;
-                  Stack[SP] = retVal;
-                  break;
-              }
+		case cEval: {
+			double retVal = 0;
+			if (evalRecursionLevel == EVAL_MAX_REC_LEVEL) {
+				evalErrorType = 5;
+			}
+			else {
+				data->Stack = new double[data->StackSize];
+				++evalRecursionLevel;
+				retVal = Eval(&Stack[SP - data->varAmount + 1]);
+				--evalRecursionLevel;
+				delete[] data->Stack;
+				data->Stack = Stack;
+			}
+			SP -= data->varAmount - 1;
+			Stack[SP] = retVal;
+			break;
+		}
 #endif
 
-          case   cExp: Stack[SP] = exp(Stack[SP]); break;
-          case cFloor: Stack[SP] = floor(Stack[SP]); break;
-
-          case    cIf:
-              {
-                  unsigned jumpAddr = ByteCode[++IP];
-                  unsigned immedAddr = ByteCode[++IP];
-                  if(doubleToInt(Stack[SP]) == 0)
-                  {
-                      IP = jumpAddr;
-                      DP = immedAddr;
-                  }
-                  --SP; break;
-              }
-
-          case   cInt: Stack[SP] = floor(Stack[SP]+.5); break;
-          case   cLog: if(Stack[SP] <= 0) { evalErrorType=3; return 0; }
-                       Stack[SP] = log(Stack[SP]); break;
-          case cLog10: if(Stack[SP] <= 0) { evalErrorType=3; return 0; }
-                       Stack[SP] = log10(Stack[SP]); break;
-          case   cMax: Stack[SP-1] = Max(Stack[SP-1], Stack[SP]);
-                       --SP; break;
-          case   cMin: Stack[SP-1] = Min(Stack[SP-1], Stack[SP]);
-                       --SP; break;
-          case   cSec:
-              {
-                  double c = cos(Stack[SP]);
-                  if(c == 0) { evalErrorType=1; return 0; }
-                  Stack[SP] = 1/c; break;
-              }
-          case   cSin: Stack[SP] = sin(Stack[SP]); break;
-          case  cSinh: Stack[SP] = sinh(Stack[SP]); break;
-          case  cSqrt: if(Stack[SP] < 0) { evalErrorType=2; return 0; }
-                       Stack[SP] = sqrt(Stack[SP]); break;
-          case   cTan: Stack[SP] = tan(Stack[SP]); break;
-          case  cTanh: Stack[SP] = tanh(Stack[SP]); break;
-
+		case cExp:
+			Stack[SP] = exp(Stack[SP]);
+			break;
+		case cFloor:
+			Stack[SP] = floor(Stack[SP]);
+			break;
+
+		case cIf: {
+			unsigned jumpAddr = ByteCode[++IP];
+			unsigned immedAddr = ByteCode[++IP];
+			if (doubleToInt(Stack[SP]) == 0) {
+				IP = jumpAddr;
+				DP = immedAddr;
+			}
+			--SP;
+			break;
+		}
+
+		case cInt:
+			Stack[SP] = floor(Stack[SP] + .5);
+			break;
+		case cLog:
+			if (Stack[SP] <= 0) {
+				evalErrorType = 3;
+				return 0;
+			}
+			Stack[SP] = log(Stack[SP]);
+			break;
+		case cLog10:
+			if (Stack[SP] <= 0) {
+				evalErrorType = 3;
+				return 0;
+			}
+			Stack[SP] = log10(Stack[SP]);
+			break;
+		case cMax:
+			Stack[SP - 1] = Max(Stack[SP - 1], Stack[SP]);
+			--SP;
+			break;
+		case cMin:
+			Stack[SP - 1] = Min(Stack[SP - 1], Stack[SP]);
+			--SP;
+			break;
+		case cSec: {
+			double c = cos(Stack[SP]);
+			if (c == 0) {
+				evalErrorType = 1;
+				return 0;
+			}
+			Stack[SP] = 1 / c;
+			break;
+		}
+		case cSin:
+			Stack[SP] = sin(Stack[SP]);
+			break;
+		case cSinh:
+			Stack[SP] = sinh(Stack[SP]);
+			break;
+		case cSqrt:
+			if (Stack[SP] < 0) {
+				evalErrorType = 2;
+				return 0;
+			}
+			Stack[SP] = sqrt(Stack[SP]);
+			break;
+		case cTan:
+			Stack[SP] = tan(Stack[SP]);
+			break;
+		case cTanh:
+			Stack[SP] = tanh(Stack[SP]);
+			break;
 
 // Misc:
-          case cImmed: Stack[++SP] = Immed[DP++]; break;
-          case  cJump: DP = ByteCode[IP+2];
-                       IP = ByteCode[IP+1];
-                       break;
+		case cImmed:
+			Stack[++SP] = Immed[DP++];
+			break;
+		case cJump:
+			DP = ByteCode[IP + 2];
+			IP = ByteCode[IP + 1];
+			break;
 
 // Operators:
-          case   cNeg: Stack[SP] = -Stack[SP]; break;
-          case   cAdd: Stack[SP-1] += Stack[SP]; --SP; break;
-          case   cSub: Stack[SP-1] -= Stack[SP]; --SP; break;
-          case   cMul: Stack[SP-1] *= Stack[SP]; --SP; break;
-          case   cDiv: if(Stack[SP] == 0) { evalErrorType=1; return 0; }
-                       Stack[SP-1] /= Stack[SP]; --SP; break;
-          case   cMod: if(Stack[SP] == 0) { evalErrorType=1; return 0; }
-                       Stack[SP-1] = fmod(Stack[SP-1], Stack[SP]);
-                       --SP; break;
-          case   cPow: Stack[SP-1] = pow(Stack[SP-1], Stack[SP]);
-                       --SP; break;
+		case cNeg:
+			Stack[SP] = -Stack[SP];
+			break;
+		case cAdd:
+			Stack[SP - 1] += Stack[SP];
+			--SP;
+			break;
+		case cSub:
+			Stack[SP - 1] -= Stack[SP];
+			--SP;
+			break;
+		case cMul:
+			Stack[SP - 1] *= Stack[SP];
+			--SP;
+			break;
+		case cDiv:
+			if (Stack[SP] == 0) {
+				evalErrorType = 1;
+				return 0;
+			}
+			Stack[SP - 1] /= Stack[SP];
+			--SP;
+			break;
+		case cMod:
+			if (Stack[SP] == 0) {
+				evalErrorType = 1;
+				return 0;
+			}
+			Stack[SP - 1] = fmod(Stack[SP - 1], Stack[SP]);
+			--SP;
+			break;
+		case cPow:
+			Stack[SP - 1] = pow(Stack[SP - 1], Stack[SP]);
+			--SP;
+			break;
 
 #ifdef FP_EPSILON
-          case cEqual: Stack[SP-1] =
-                           (fabs(Stack[SP-1]-Stack[SP]) <= FP_EPSILON);
-                       --SP; break;
-          case cNEqual: Stack[SP-1] =
-                            (fabs(Stack[SP-1] - Stack[SP]) >= FP_EPSILON);
-                       --SP; break;
-          case  cLess: Stack[SP-1] = (Stack[SP-1] < Stack[SP]-FP_EPSILON);
-                       --SP; break;
-          case  cLessOrEq: Stack[SP-1] = (Stack[SP-1] <= Stack[SP]+FP_EPSILON);
-                       --SP; break;
-          case cGreater: Stack[SP-1] = (Stack[SP-1]-FP_EPSILON > Stack[SP]);
-                         --SP; break;
-          case cGreaterOrEq: Stack[SP-1] =
-                                 (Stack[SP-1]+FP_EPSILON >= Stack[SP]);
-                         --SP; break;
+		case cEqual:
+			Stack[SP - 1] = (fabs(Stack[SP - 1] - Stack[SP]) <= FP_EPSILON);
+			--SP;
+			break;
+		case cNEqual:
+			Stack[SP - 1] = (fabs(Stack[SP - 1] - Stack[SP]) >= FP_EPSILON);
+			--SP;
+			break;
+		case cLess:
+			Stack[SP - 1] = (Stack[SP - 1] < Stack[SP] - FP_EPSILON);
+			--SP;
+			break;
+		case cLessOrEq:
+			Stack[SP - 1] = (Stack[SP - 1] <= Stack[SP] + FP_EPSILON);
+			--SP;
+			break;
+		case cGreater:
+			Stack[SP - 1] = (Stack[SP - 1] - FP_EPSILON > Stack[SP]);
+			--SP;
+			break;
+		case cGreaterOrEq:
+			Stack[SP - 1] = (Stack[SP - 1] + FP_EPSILON >= Stack[SP]);
+			--SP;
+			break;
 #else
-          case cEqual: Stack[SP-1] = (Stack[SP-1] == Stack[SP]);
-                       --SP; break;
-          case cNEqual: Stack[SP-1] = (Stack[SP-1] != Stack[SP]);
-                       --SP; break;
-          case  cLess: Stack[SP-1] = (Stack[SP-1] < Stack[SP]);
-                       --SP; break;
-          case  cLessOrEq: Stack[SP-1] = (Stack[SP-1] <= Stack[SP]);
-                       --SP; break;
-          case cGreater: Stack[SP-1] = (Stack[SP-1] > Stack[SP]);
-                         --SP; break;
-          case cGreaterOrEq: Stack[SP-1] = (Stack[SP-1] >= Stack[SP]);
-                         --SP; break;
+			case cEqual: Stack[SP-1] = (Stack[SP-1] == Stack[SP]);
+			--SP; break;
+			case cNEqual: Stack[SP-1] = (Stack[SP-1] != Stack[SP]);
+			--SP; break;
+			case cLess: Stack[SP-1] = (Stack[SP-1] < Stack[SP]);
+			--SP; break;
+			case cLessOrEq: Stack[SP-1] = (Stack[SP-1] <= Stack[SP]);
+			--SP; break;
+			case cGreater: Stack[SP-1] = (Stack[SP-1] > Stack[SP]);
+			--SP; break;
+			case cGreaterOrEq: Stack[SP-1] = (Stack[SP-1] >= Stack[SP]);
+			--SP; break;
 #endif
 
-          case   cAnd: Stack[SP-1] =
-                           (doubleToInt(Stack[SP-1]) &&
-                            doubleToInt(Stack[SP]));
-                       --SP; break;
-          case    cOr: Stack[SP-1] =
-                           (doubleToInt(Stack[SP-1]) ||
-                            doubleToInt(Stack[SP]));
-                       --SP; break;
-          case   cNot: Stack[SP] = !doubleToInt(Stack[SP]); break;
+		case cAnd:
+			Stack[SP - 1] = (doubleToInt(Stack[SP - 1]) && doubleToInt(Stack[SP]));
+			--SP;
+			break;
+		case cOr:
+			Stack[SP - 1] = (doubleToInt(Stack[SP - 1]) || doubleToInt(Stack[SP]));
+			--SP;
+			break;
+		case cNot:
+			Stack[SP] = !doubleToInt(Stack[SP]);
+			break;
 
 // Degrees-radians conversion:
-          case   cDeg: Stack[SP] = RadiansToDegrees(Stack[SP]); break;
-          case   cRad: Stack[SP] = DegreesToRadians(Stack[SP]); break;
+		case cDeg:
+			Stack[SP] = RadiansToDegrees(Stack[SP]);
+			break;
+		case cRad:
+			Stack[SP] = DegreesToRadians(Stack[SP]);
+			break;
 
 // User-defined function calls:
-          case cFCall:
-              {
-                  unsigned index = ByteCode[++IP];
-                  unsigned params = data->FuncPtrs[index].params;
-                  double retVal =
-                      data->FuncPtrs[index].ptr(&Stack[SP-params+1]);
-                  SP -= int(params)-1;
-                  Stack[SP] = retVal;
-                  break;
-              }
-
-          case cPCall:
-              {
-                  unsigned index = ByteCode[++IP];
-                  unsigned params = data->FuncParsers[index]->data->varAmount;
-                  double retVal =
-                      data->FuncParsers[index]->Eval(&Stack[SP-params+1]);
-                  SP -= int(params)-1;
-                  Stack[SP] = retVal;
-                  break;
-              }
-
+		case cFCall: {
+			unsigned index = ByteCode[++IP];
+			unsigned params = data->FuncPtrs[index].params;
+			double retVal = data->FuncPtrs[index].ptr(&Stack[SP - params + 1]);
+			SP -= int(params) - 1;
+			Stack[SP] = retVal;
+			break;
+		}
+
+		case cPCall: {
+			unsigned index = ByteCode[++IP];
+			unsigned params = data->FuncParsers[index]->data->varAmount;
+			double retVal = data->FuncParsers[index]->Eval(&Stack[SP - params + 1]);
+			SP -= int(params) - 1;
+			Stack[SP] = retVal;
+			break;
+		}
 
 #ifdef SUPPORT_OPTIMIZER
-          case   cVar: break; // Paranoia. These should never exist
-          case   cDup: Stack[SP+1] = Stack[SP]; ++SP; break;
-          case   cInv:
-              if(Stack[SP] == 0.0) { evalErrorType=1; return 0; }
-              Stack[SP] = 1.0/Stack[SP];
-              break;
+		case cVar:
+			break; // Paranoia. These should never exist
+		case cDup:
+			Stack[SP + 1] = Stack[SP];
+			++SP;
+			break;
+		case cInv:
+			if (Stack[SP] == 0.0) {
+				evalErrorType = 1;
+				return 0;
+			}
+			Stack[SP] = 1.0 / Stack[SP];
+			break;
 #endif
 
 // Variables:
-          default:
-              Stack[++SP] = Vars[ByteCode[IP]-VarBegin];
-        }
-    }
+		default:
+			Stack[++SP] = Vars[ByteCode[IP] - VarBegin];
+		}
+	}
 
-    evalErrorType=0;
-    return Stack[SP];
+	evalErrorType = 0;
+	return Stack[SP];
 }
 
-
 #ifdef FUNCTIONPARSER_SUPPORT_DEBUG_OUTPUT
 namespace
 {
-    inline void printHex(std::ostream& dest, unsigned n)
-    {
-        dest.width(8); dest.fill('0'); hex(dest); //uppercase(dest);
-        dest << n;
-    }
+	inline void printHex(std::ostream& dest, unsigned n)
+	{
+		dest.width(8); dest.fill('0'); hex(dest); //uppercase(dest);
+		dest << n;
+	}
 }
 
 void FunctionParser::PrintByteCode(std::ostream& dest) const
 {
-    const unsigned* const ByteCode = data->ByteCode;
-    const double* const Immed = data->Immed;
+	const unsigned* const ByteCode = data->ByteCode;
+	const double* const Immed = data->Immed;
 
-    for(unsigned IP=0, DP=0; IP<data->ByteCodeSize; ++IP)
-    {
-        printHex(dest, IP);
-        dest << ": ";
-
-        unsigned opcode = ByteCode[IP];
-
-        switch(opcode)
-        {
-          case cIf:
-              dest << "jz\t";
-              printHex(dest, ByteCode[IP+1]+1);
-              dest << endl;
-              IP += 2;
-              break;
-
-          case cJump:
-              dest << "jump\t";
-              printHex(dest, ByteCode[IP+1]+1);
-              dest << endl;
-              IP += 2;
-              break;
-          case cImmed:
-              dest.precision(10);
-              dest << "push\t" << Immed[DP++] << endl;
-              break;
-
-          case cFCall:
-              {
-                  unsigned index = ByteCode[++IP];
-                  Data::VarMap_t::const_iterator iter =
-                      data->FuncPtrNames.begin();
-                  while(iter->second != index) ++iter;
-                  dest << "fcall\t" << iter->first
-                       << " (" << data->FuncPtrs[index].params << ")" << endl;
-                  break;
-              }
-
-          case cPCall:
-              {
-                  unsigned index = ByteCode[++IP];
-                  Data::VarMap_t::const_iterator iter =
-                      data->FuncParserNames.begin();
-                  while(iter->second != index) ++iter;
-                  dest << "pcall\t" << iter->first
-                       << " (" << data->FuncParsers[index]->data->varAmount
-                       << ")" << endl;
-                  break;
-              }
-
-          default:
-              if(opcode < VarBegin)
-              {
-                  string n;
-                  unsigned params = 1;
-                  switch(opcode)
-                  {
-                    case cNeg: n = "neg"; break;
-                    case cAdd: n = "add"; break;
-                    case cSub: n = "sub"; break;
-                    case cMul: n = "mul"; break;
-                    case cDiv: n = "div"; break;
-                    case cMod: n = "mod"; break;
-                    case cPow: n = "pow"; break;
-                    case cEqual: n = "eq"; break;
-                    case cNEqual: n = "neq"; break;
-                    case cLess: n = "lt"; break;
-                    case cLessOrEq: n = "le"; break;
-                    case cGreater: n = "gt"; break;
-                    case cGreaterOrEq: n = "ge"; break;
-                    case cAnd: n = "and"; break;
-                    case cOr: n = "or"; break;
-                    case cNot: n = "not"; break;
-                    case cDeg: n = "deg"; break;
-                    case cRad: n = "rad"; break;
+	for(unsigned IP=0, DP=0; IP<data->ByteCodeSize; ++IP)
+	{
+		printHex(dest, IP);
+		dest << ": ";
+
+		unsigned opcode = ByteCode[IP];
+
+		switch(opcode)
+		{
+			case cIf:
+			dest << "jz\t";
+			printHex(dest, ByteCode[IP+1]+1);
+			dest << endl;
+			IP += 2;
+			break;
+
+			case cJump:
+			dest << "jump\t";
+			printHex(dest, ByteCode[IP+1]+1);
+			dest << endl;
+			IP += 2;
+			break;
+			case cImmed:
+			dest.precision(10);
+			dest << "push\t" << Immed[DP++] << endl;
+			break;
+
+			case cFCall:
+			{
+				unsigned index = ByteCode[++IP];
+				Data::VarMap_t::const_iterator iter =
+				data->FuncPtrNames.begin();
+				while(iter->second != index) ++iter;
+				dest << "fcall\t" << iter->first
+				<< " (" << data->FuncPtrs[index].params << ")" << endl;
+				break;
+			}
+
+			case cPCall:
+			{
+				unsigned index = ByteCode[++IP];
+				Data::VarMap_t::const_iterator iter =
+				data->FuncParserNames.begin();
+				while(iter->second != index) ++iter;
+				dest << "pcall\t" << iter->first
+				<< " (" << data->FuncParsers[index]->data->varAmount
+				<< ")" << endl;
+				break;
+			}
+
+			default:
+			if(opcode < VarBegin)
+			{
+				string n;
+				unsigned params = 1;
+				switch(opcode)
+				{
+					case cNeg: n = "neg"; break;
+					case cAdd: n = "add"; break;
+					case cSub: n = "sub"; break;
+					case cMul: n = "mul"; break;
+					case cDiv: n = "div"; break;
+					case cMod: n = "mod"; break;
+					case cPow: n = "pow"; break;
+					case cEqual: n = "eq"; break;
+					case cNEqual: n = "neq"; break;
+					case cLess: n = "lt"; break;
+					case cLessOrEq: n = "le"; break;
+					case cGreater: n = "gt"; break;
+					case cGreaterOrEq: n = "ge"; break;
+					case cAnd: n = "and"; break;
+					case cOr: n = "or"; break;
+					case cNot: n = "not"; break;
+					case cDeg: n = "deg"; break;
+					case cRad: n = "rad"; break;
 
 #ifndef DISABLE_EVAL
-                    case cEval: n = "call\t0"; break;
+					case cEval: n = "call\t0"; break;
 #endif
 
 #ifdef SUPPORT_OPTIMIZER
-                    case cVar: n = "(var)"; break;
-                    case cDup: n = "dup"; break;
-                    case cInv: n = "inv"; break;
+					case cVar: n = "(var)"; break;
+					case cDup: n = "dup"; break;
+					case cInv: n = "inv"; break;
 #endif
 
-                    default:
-                        n = Functions[opcode-cAbs].name;
-                        params = Functions[opcode-cAbs].params;
-                  }
-                  dest << n;
-                  if(params != 1) dest << " (" << params << ")";
-                  dest << endl;
-              }
-              else
-              {
-                  dest << "push\tVar" << opcode-VarBegin << endl;
-              }
-        }
-    }
+					default:
+					n = Functions[opcode-cAbs].name;
+					params = Functions[opcode-cAbs].params;
+				}
+				dest << n;
+				if(params != 1) dest << " (" << params << ")";
+				dest << endl;
+			}
+			else
+			{
+				dest << "push\tVar" << opcode-VarBegin << endl;
+			}
+		}
+	}
 }
 #endif
 
-
-
-
 #ifndef SUPPORT_OPTIMIZER
 void FunctionParser::MakeTree(void *) const {}
 void FunctionParser::Optimize()
 {
-    // Do nothing if no optimizations are supported.
+	// Do nothing if no optimizations are supported.
 }
 #endif
+
+}
+ // namespace GF
+
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/fparser.hh gridfields/clib/src/fparser.hh
--- tag/gridfieldsclib-0.7/src/fparser.hh	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/fparser.hh	2014-05-16 22:57:00.773391865 +0200
@@ -1,10 +1,10 @@
 /***************************************************************************\
 |* Function parser v2.8 by Warp                                            *|
-|* ----------------------------                                            *|
-|* Parses and evaluates the given function with the given variable values. *|
-|* See fparser.txt for details.                                            *|
-|*                                                                         *|
-\***************************************************************************/
+ |* ----------------------------                                            *|
+ |* Parses and evaluates the given function with the given variable values. *|
+ |* See fparser.txt for details.                                            *|
+ |*                                                                         *|
+ \***************************************************************************/
 
 #ifndef ONCE_FPARSER_H_
 #define ONCE_FPARSER_H_
@@ -17,141 +17,148 @@
 #include <iostream>
 #endif
 
-class FunctionParser
-{
-public:
-    enum ParseErrorType
-    {
-        SYNTAX_ERROR=0, MISM_PARENTH, MISSING_PARENTH, EMPTY_PARENTH,
-        EXPECT_OPERATOR, OUT_OF_MEMORY, UNEXPECTED_ERROR, INVALID_VARS,
-        ILL_PARAMS_AMOUNT, PREMATURE_EOS, EXPECT_PARENTH_FUNC,
-        FP_NO_ERROR
-    };
-
-
-    int Parse(const std::string& Function, const std::string& Vars,
-              bool useDegrees = false);
-    const char* ErrorMsg() const;
-    inline ParseErrorType GetParseErrorType() const { return parseErrorType; }
-
-    double Eval(const double* Vars);
-    inline int EvalError() const { return evalErrorType; }
-
-    bool AddConstant(const std::string& name, double value);
-
-    typedef double (*FunctionPtr)(const double*);
-
-    bool AddFunction(const std::string& name,
-                     FunctionPtr, unsigned paramsAmount);
-    bool AddFunction(const std::string& name, FunctionParser&);
-
-    void Optimize();
-
-
-    FunctionParser();
-    ~FunctionParser();
-
-    // Copy constructor and assignment operator (implemented using the
-    // copy-on-write technique for efficiency):
-    FunctionParser(const FunctionParser&);
-    FunctionParser& operator=(const FunctionParser&);
+namespace GF {
 
+class FunctionParser {
+public:
+	enum ParseErrorType {
+		SYNTAX_ERROR = 0,
+		MISM_PARENTH,
+		MISSING_PARENTH,
+		EMPTY_PARENTH,
+		EXPECT_OPERATOR,
+		OUT_OF_MEMORY,
+		UNEXPECTED_ERROR,
+		INVALID_VARS,
+		ILL_PARAMS_AMOUNT,
+		PREMATURE_EOS,
+		EXPECT_PARENTH_FUNC,
+		FP_NO_ERROR
+	};
+
+	int Parse(const std::string& Function, const std::string& Vars, bool useDegrees = false);
+	const char* ErrorMsg() const;
+	inline ParseErrorType GetParseErrorType() const
+	{
+		return parseErrorType;
+	}
+
+	double Eval(const double* Vars);
+	inline int EvalError() const
+	{
+		return evalErrorType;
+	}
+
+	bool AddConstant(const std::string& name, double value);
+
+	typedef double (*FunctionPtr)(const double*);
+
+	bool AddFunction(const std::string& name, FunctionPtr, unsigned paramsAmount);
+	bool AddFunction(const std::string& name, FunctionParser&);
+
+	void Optimize();
+
+	FunctionParser();
+	~FunctionParser();
+
+	// Copy constructor and assignment operator (implemented using the
+	// copy-on-write technique for efficiency):
+	FunctionParser(const FunctionParser&);
+	FunctionParser& operator=(const FunctionParser&);
 
 #ifdef FUNCTIONPARSER_SUPPORT_DEBUG_OUTPUT
-    // For debugging purposes only:
-    void PrintByteCode(std::ostream& dest) const;
+	// For debugging purposes only:
+	void PrintByteCode(std::ostream& dest) const;
 #endif
 
-
-
 //========================================================================
 private:
 //========================================================================
 
 // Private data:
 // ------------
-    ParseErrorType parseErrorType;
-    int evalErrorType;
+	ParseErrorType parseErrorType;
+	int evalErrorType;
 
-    struct Data
-    {
-        unsigned referenceCounter;
-
-        int varAmount;
-        bool useDegreeConversion;
-
-        typedef std::map<std::string, unsigned> VarMap_t;
-        VarMap_t Variables;
-
-        typedef std::map<std::string, double> ConstMap_t;
-        ConstMap_t Constants;
-
-        VarMap_t FuncPtrNames;
-        struct FuncPtrData
-        {
-            FunctionPtr ptr; unsigned params;
-            FuncPtrData(FunctionPtr p, unsigned par): ptr(p), params(par) {}
-        };
-        std::vector<FuncPtrData> FuncPtrs;
-
-        VarMap_t FuncParserNames;
-        std::vector<FunctionParser*> FuncParsers;
-
-        unsigned* ByteCode;
-        unsigned ByteCodeSize;
-        double* Immed;
-        unsigned ImmedSize;
-        double* Stack;
-        unsigned StackSize;
-
-        Data();
-        ~Data();
-        Data(const Data&);
-
-        Data& operator=(const Data&); // not implemented on purpose
-    };
-
-    Data* data;
-    unsigned evalRecursionLevel;
-
-    // Temp data needed in Compile():
-    unsigned StackPtr;
-    std::vector<unsigned>* tempByteCode;
-    std::vector<double>* tempImmed;
+	struct Data {
+		unsigned referenceCounter;
 
+		int varAmount;
+		bool useDegreeConversion;
+
+		typedef std::map<std::string, unsigned> VarMap_t;
+		VarMap_t Variables;
+
+		typedef std::map<std::string, double> ConstMap_t;
+		ConstMap_t Constants;
+
+		VarMap_t FuncPtrNames;
+		struct FuncPtrData {
+			FunctionPtr ptr;
+			unsigned params;
+			FuncPtrData(FunctionPtr p, unsigned par) :
+					ptr(p), params(par)
+			{
+			}
+		};
+		std::vector<FuncPtrData> FuncPtrs;
+
+		VarMap_t FuncParserNames;
+		std::vector<FunctionParser*> FuncParsers;
+
+		unsigned* ByteCode;
+		unsigned ByteCodeSize;
+		double* Immed;
+		unsigned ImmedSize;
+		double* Stack;
+		unsigned StackSize;
+
+		Data();
+		~Data();
+		Data(const Data&);
+
+		Data& operator=(const Data&); // not implemented on purpose
+	};
+
+	Data* data;
+	unsigned evalRecursionLevel;
+
+	// Temp data needed in Compile():
+	unsigned StackPtr;
+	std::vector<unsigned>* tempByteCode;
+	std::vector<double>* tempImmed;
 
 // Private methods:
 // ---------------
-    void copyOnWrite();
-
+	void copyOnWrite();
 
-    bool checkRecursiveLinking(const FunctionParser*) const;
+	bool checkRecursiveLinking(const FunctionParser*) const;
 
-    bool isValidName(const std::string&) const;
-    Data::VarMap_t::const_iterator FindVariable(const char*,
-                                                const Data::VarMap_t&) const;
-    Data::ConstMap_t::const_iterator FindConstant(const char*) const;
-    int CheckSyntax(const char*);
-    bool Compile(const char*);
-    bool IsVariable(int);
-    void AddCompiledByte(unsigned);
-    void AddImmediate(double);
-    void AddFunctionOpcode(unsigned);
-    inline void incStackPtr();
-    int CompileIf(const char*, int);
-    int CompileFunctionParams(const char*, int, unsigned);
-    int CompileElement(const char*, int);
-    int CompilePow(const char*, int);
-    int CompileUnaryMinus(const char*, int);
-    int CompileMult(const char*, int);
-    int CompileAddition(const char*, int);
-    int CompileComparison(const char*, int);
-    int CompileAnd(const char*, int);
-    int CompileOr(const char*, int);
-    int CompileExpression(const char*, int, bool=false);
+	bool isValidName(const std::string&) const;
+	Data::VarMap_t::const_iterator FindVariable(const char*, const Data::VarMap_t&) const;
+	Data::ConstMap_t::const_iterator FindConstant(const char*) const;
+	int CheckSyntax(const char*);
+	bool Compile(const char*);
+	bool IsVariable(int);
+	void AddCompiledByte(unsigned);
+	void AddImmediate(double);
+	void AddFunctionOpcode(unsigned);
+	inline void incStackPtr();
+	int CompileIf(const char*, int);
+	int CompileFunctionParams(const char*, int, unsigned);
+	int CompileElement(const char*, int);
+	int CompilePow(const char*, int);
+	int CompileUnaryMinus(const char*, int);
+	int CompileMult(const char*, int);
+	int CompileAddition(const char*, int);
+	int CompileComparison(const char*, int);
+	int CompileAnd(const char*, int);
+	int CompileOr(const char*, int);
+	int CompileExpression(const char*, int, bool = false);
 
-
-    void MakeTree(void*) const;
+	void MakeTree(void*) const;
 };
 
+} // namespace GF
+
 #endif
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/fpconfig.hh gridfields/clib/src/fpconfig.hh
--- tag/gridfieldsclib-0.7/src/fpconfig.hh	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/fpconfig.hh	2014-05-16 22:57:00.793391865 +0200
@@ -14,10 +14,9 @@
  Comment out the following line if your compiler supports the (non-standard)
  asinh, acosh and atanh functions and you want them to be supported. If
  you are not sure, just leave it (those function will then not be supported).
-*/
+ */
 #define NO_ASINH
 
-
 /*
  Uncomment the following line to disable the eval() function if it could
  be too dangerous in the target application.
@@ -25,32 +24,29 @@
  it is still possible to write functions using it which take enormous
  amounts of time to evaluate even though the maximum recursion is never
  reached. This may be undesirable in some applications.
-*/
+ */
 //#define DISABLE_EVAL
 
-
 /*
  Maximum recursion level for eval() calls:
-*/
+ */
 #define EVAL_MAX_REC_LEVEL 1000
 
-
 /*
  Comment out the following lines out if you are not going to use the
  optimizer and want a slightly smaller library. The Optimize() method
  can still be called, but it will not do anything.
  If you are unsure, just leave it. It won't slow down the other parts of
  the library.
-*/
+ */
 #ifndef NO_SUPPORT_OPTIMIZER
 #define SUPPORT_OPTIMIZER
 #endif
 
-
 /*
  Epsilon value used with the comparison operators (must be non-negative):
  (Comment it out if you don't want to use epsilon in comparisons. Might
  lead to marginally faster evaluation of the comparison operators, but
  can introduce inaccuracies in comparisons.)
-*/
+ */
 #define FP_EPSILON 1e-14
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/fptypes.hh gridfields/clib/src/fptypes.hh
--- tag/gridfieldsclib-0.7/src/fptypes.hh	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/fptypes.hh	2014-05-16 22:57:00.763391866 +0200
@@ -7,111 +7,100 @@
 // You don't need to include this file in your code. Include "fparser.hh"
 // only.
 
-
-
-namespace FUNCTIONPARSERTYPES
-{
+namespace FUNCTIONPARSERTYPES {
 // The functions must be in alphabetical order:
-    enum OPCODE
-    {
-        cAbs, cAcos,
+enum OPCODE {
+	cAbs, cAcos,
 #ifndef NO_ASINH
-        cAcosh,
+	cAcosh,
 #endif
-        cAsin,
+	cAsin,
 #ifndef NO_ASINH
-        cAsinh,
+	cAsinh,
 #endif
-        cAtan,
-        cAtan2,
+	cAtan, cAtan2,
 #ifndef NO_ASINH
-        cAtanh,
+	cAtanh,
 #endif
-        cCeil, cCos, cCosh, cCot, cCsc,
+	cCeil, cCos, cCosh, cCot, cCsc,
 #ifndef DISABLE_EVAL
-        cEval,
+	cEval,
 #endif
-        cExp, cFloor, cIf, cInt, cLog, cLog10, cMax, cMin,
-        cSec, cSin, cSinh, cSqrt, cTan, cTanh,
+	cExp, cFloor, cIf, cInt, cLog, cLog10, cMax, cMin, cSec, cSin, cSinh, cSqrt, cTan, cTanh,
 
 // These do not need any ordering:
-        cImmed, cJump,
-        cNeg, cAdd, cSub, cMul, cDiv, cMod, cPow,
-        cEqual, cNEqual, cLess, cLessOrEq, cGreater, cGreaterOrEq,
-        cNot, cAnd, cOr,
+	cImmed,
+	cJump,
+	cNeg,
+	cAdd,
+	cSub,
+	cMul,
+	cDiv,
+	cMod,
+	cPow,
+	cEqual,
+	cNEqual,
+	cLess,
+	cLessOrEq,
+	cGreater,
+	cGreaterOrEq,
+	cNot,
+	cAnd,
+	cOr,
 
-        cDeg, cRad,
+	cDeg,
+	cRad,
 
-        cFCall, cPCall,
+	cFCall,
+	cPCall,
 
 #ifdef SUPPORT_OPTIMIZER
-        cVar, cDup, cInv,
+	cVar, cDup, cInv,
 #endif
 
-        VarBegin
-    };
-
-    struct FuncDefinition
-    {
-        const char* name;
-        unsigned nameLength;
-        unsigned opcode;
-        unsigned params;
-
-        // This is basically strcmp(), but taking 'nameLength' as string
-        // length (not ending '\0'):
-        bool operator<(const FuncDefinition& rhs) const
-        {
-            for(unsigned i = 0; i < nameLength; ++i)
-            {
-                if(i == rhs.nameLength) return false;
-                const char c1 = name[i], c2 = rhs.name[i];
-                if(c1 < c2) return true;
-                if(c2 < c1) return false;
-            }
-            return nameLength < rhs.nameLength;
-        }
-    };
+	VarBegin
+};
 
+struct FuncDefinition {
+	const char* name;
+	unsigned nameLength;
+	unsigned opcode;
+	unsigned params;
+
+	// This is basically strcmp(), but taking 'nameLength' as string
+	// length (not ending '\0'):
+	bool operator<(const FuncDefinition& rhs) const
+	{
+		for (unsigned i = 0; i < nameLength; ++i) {
+			if (i == rhs.nameLength) return false;
+			const char c1 = name[i], c2 = rhs.name[i];
+			if (c1 < c2) return true;
+			if (c2 < c1) return false;
+		}
+		return nameLength < rhs.nameLength;
+	}
+};
 
 // This list must be in alphabetical order:
-    const FuncDefinition Functions[]=
-    {
-        { "abs", 3, cAbs, 1 },
-        { "acos", 4, cAcos, 1 },
+const FuncDefinition Functions[] = { { "abs", 3, cAbs, 1 }, { "acos", 4, cAcos, 1 },
 #ifndef NO_ASINH
-        { "acosh", 5, cAcosh, 1 },
+		{ "acosh", 5, cAcosh, 1 },
 #endif
-        { "asin", 4, cAsin, 1 },
+		{ "asin", 4, cAsin, 1 },
 #ifndef NO_ASINH
-        { "asinh", 5, cAsinh, 1 },
+		{ "asinh", 5, cAsinh, 1 },
 #endif
-        { "atan", 4, cAtan, 1 },
-        { "atan2", 5, cAtan2, 2 },
+		{ "atan", 4, cAtan, 1 }, { "atan2", 5, cAtan2, 2 },
 #ifndef NO_ASINH
-        { "atanh", 5, cAtanh, 1 },
+		{ "atanh", 5, cAtanh, 1 },
 #endif
-        { "ceil", 4, cCeil, 1 },
-        { "cos", 3, cCos, 1 },
-        { "cosh", 4, cCosh, 1 },
-        { "cot", 3, cCot, 1 },
-        { "csc", 3, cCsc, 1 },
+		{ "ceil", 4, cCeil, 1 }, { "cos", 3, cCos, 1 }, { "cosh", 4, cCosh, 1 }, { "cot", 3, cCot, 1 }, { "csc", 3,
+				cCsc, 1 },
 #ifndef DISABLE_EVAL
-        { "eval", 4, cEval, 0 },
+		{ "eval", 4, cEval, 0 },
 #endif
-        { "exp", 3, cExp, 1 },
-        { "floor", 5, cFloor, 1 },
-        { "if", 2, cIf, 0 },
-        { "int", 3, cInt, 1 },
-        { "log", 3, cLog, 1 },
-        { "log10", 5, cLog10, 1 },
-        { "max", 3, cMax, 2 },
-        { "min", 3, cMin, 2 },
-        { "sec", 3, cSec, 1 },
-        { "sin", 3, cSin, 1 },
-        { "sinh", 4, cSinh, 1 },
-        { "sqrt", 4, cSqrt, 1 },
-        { "tan", 3, cTan, 1 },
-        { "tanh", 4, cTanh, 1 }
-    };
+		{ "exp", 3, cExp, 1 }, { "floor", 5, cFloor, 1 }, { "if", 2, cIf, 0 }, { "int", 3, cInt, 1 }, { "log", 3, cLog,
+				1 }, { "log10", 5, cLog10, 1 }, { "max", 3, cMax, 2 }, { "min", 3, cMin, 2 }, { "sec", 3, cSec, 1 }, {
+				"sin", 3, cSin, 1 }, { "sinh", 4, cSinh, 1 }, { "sqrt", 4, cSqrt, 1 }, { "tan", 3, cTan, 1 }, { "tanh",
+				4, cTanh, 1 } };
 }
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/grid.cc gridfields/clib/src/grid.cc
--- tag/gridfieldsclib-0.7/src/grid.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/grid.cc	2014-05-16 22:57:00.833391864 +0200
@@ -1,5 +1,8 @@
+#include "config_gridfields.h"
+
 #include <iostream>
 #include <assert.h>
+
 #include "grid.h"
 #include "unarynodemap.h"
 #include "crossnodemap.h"
@@ -10,410 +13,449 @@
 #include "implicit0cells.h"
 #include "util.h"
 
-
 #include <string>
 
-string testString(const string &s)  { return s; }
-Grid::Grid(string nm, Dim_t d) {
-  init(nm, d, new IdOrdMap(this));
+namespace GF {
+
+string testString(const string &s)
+{
+	return s;
+}
+Grid::Grid(string nm, Dim_t d)
+{
+	init(nm, d, new IdOrdMap(this));
 }
 
-Grid::Grid(string nm) {
-  init(nm, -1, new IdOrdMap(this));
+Grid::Grid(string nm)
+{
+	init(nm, -1, new IdOrdMap(this));
 }
 
-Grid::Grid(string nm, Dim_t d, OrdMap *om) {
-  init(nm, d, om);
+Grid::Grid(string nm, Dim_t d, OrdMap *om)
+{
+	init(nm, d, om);
 }
 
-int g_instances=0;
+int g_instances = 0;
 
-void Grid::init(string nm, Dim_t d, OrdMap *om) {
+void Grid::init(string nm, Dim_t d, OrdMap *om)
+{
 // cout << g_instances++ << endl;
-   
-  //dim = d;
-  name = nm;
-
-  ordmap = om;
-
-  for (int i=0; i<=d; i++) {
-    cellsets.push_back(new CellArray());
-  }
-
-  //increment refcount
-  this->ref();
-}
-Dim_t Grid::getdim() {
-  int i;
-  for (i=cellsets.size()-1; i>=0; i--) {
-    if (cellsets[i]->getsize() > 0) break;
-  }
-  return i;
-}
-
-bool Grid::empty() {
-  for (int i=0; i<=this->getdim(); i++) {
-    if (cellsets[i]->getsize() > 0) {
-      return false;
-    }
-  }
-  return true;
-}
-
-unsigned int Grid::countKCells(Dim_t k) {
-  if (k>getdim()) return 0;
-  return cellsets[k]->getsize();
-}
-
-AbstractCellArray *Grid::getKCells(Dim_t k) {
-  if (k >= (Dim_t) cellsets.size()) {
-    for (int i=cellsets.size(); i<=k; i++) {
-      cellsets.push_back(new CellArray());
-    }
-  }
-  return cellsets[k];
-}
-
-void Grid::setKCells(AbstractCellArray *cells, Dim_t d) {
-
-  int s = cellsets.size();
-  if (d >= s) {
-    cellsets.resize(d+1);
-    for (int i=s; i<d; i++) {
-      cellsets[i] = new CellArray(); 
-    }
-  } else {
-    cellsets[d]->unref();
-  }
-  //cout << cellsets.size() << endl;
-  cellsets[d] = cells; 
-}
-
-Grid *Grid::Intersection(Grid *Other){
-  string outname = "(" + name + "-i-" + Other->name + ")";
-  
-  Grid *Out = new Grid(outname);
-  AbstractCellArray *caOut, *ca1, *ca2;
-  Dim_t d = MIN(Other->getdim(), getdim());
-
-  for (int i=d; i>=0; i--){
-    ca1 = this->getKCells(i);
-    ca2 = Other->getKCells(i);
-    caOut = ca2->Intersection(ca1);
-
-    if (caOut->getsize() != 0)
-      Out->setKCells(caOut, i);
-  }
-  return Out;
-}
-
-Grid *Grid::Cross(Grid *Other) {
-  string outname = "(" + name + "-c-" + Other->name + ")";
-  //string outname = "cross";
-  Grid *Out = new Grid(outname);
-  AbstractCellArray *ca1, *ca2;
-  float tpost;
-
-  Dim_t d = getdim() + Other->getdim();
-
-  AbstractCellArray *myNodes = this->getKCells(0);
-  AbstractCellArray *yourNodes = Other->getKCells(0);
-  CrossNodeMap h = myNodes->makeCrossNodeMap(yourNodes);
-
-  tpost = gettime();
-  AbstractCellArray *newnodes;
-  ca1 = this->getKCells(0);
-  ca2 = Other->getKCells(0);
-
-  Dim_t SIFTDIM = d;
-  
-  //cout << "crossing 0-cells" << endl;
-  newnodes = ca1->Cross(ca2, h); 
-  //    cout << gettime() - tpost << " ( Cross(0-cells) ) " << endl;
 
-  //tpost = gettime();
-  //    cout << gettime() - tpost << " ( Append(0-cells) ) " << endl;
+//dim = d;
+	name = nm;
+
+	ordmap = om;
+
+	for (int i = 0; i <= d; i++) {
+		cellsets.push_back(new CellArray());
+	}
+
+	//increment refcount
+	this->ref();
+}
+Dim_t Grid::getdim()
+{
+	int i;
+	for (i = cellsets.size() - 1; i >= 0; i--) {
+		if (cellsets[i]->getsize() > 0) break;
+	}
+	return i;
+}
+
+bool Grid::empty()
+{
+	for (int i = 0; i <= this->getdim(); i++) {
+		if (cellsets[i]->getsize() > 0) {
+			return false;
+		}
+	}
+	return true;
+}
+
+unsigned int Grid::countKCells(Dim_t k)
+{
+	if (k > getdim()) return 0;
+	return cellsets[k]->getsize();
+}
+
+AbstractCellArray *Grid::getKCells(Dim_t k)
+{
+	if (k >= (Dim_t) cellsets.size()) {
+		for (int i = cellsets.size(); i <= k; i++) {
+			cellsets.push_back(new CellArray());
+		}
+	}
+	return cellsets[k];
+}
+
+void Grid::setKCells(AbstractCellArray *cells, Dim_t d)
+{
+
+	int s = cellsets.size();
+	if (d >= s) {
+		cellsets.resize(d + 1);
+		for (int i = s; i < d; i++) {
+			cellsets[i] = new CellArray();
+		}
+	}
+	else {
+		cellsets[d]->unref();
+	}
+	//cout << cellsets.size() << endl;
+	cellsets[d] = cells;
+}
+
+Grid *Grid::Intersection(Grid *Other)
+{
+	string outname = "(" + name + "-i-" + Other->name + ")";
+
+	Grid *Out = new Grid(outname);
+	AbstractCellArray *caOut, *ca1, *ca2;
+	Dim_t d = MIN(Other->getdim(), getdim());
+
+	for (int i = d; i >= 0; i--) {
+		ca1 = this->getKCells(i);
+		ca2 = Other->getKCells(i);
+		caOut = ca2->Intersection(ca1);
+
+		if (caOut->getsize() != 0) Out->setKCells(caOut, i);
+	}
+	return Out;
+}
+
+Grid *Grid::Cross(Grid *Other)
+{
+	string outname = "(" + name + "-c-" + Other->name + ")";
+	//string outname = "cross";
+	Grid *Out = new Grid(outname);
+	AbstractCellArray *ca1, *ca2;
+	float tpost;
+
+	Dim_t d = getdim() + Other->getdim();
+
+	AbstractCellArray *myNodes = this->getKCells(0);
+	AbstractCellArray *yourNodes = Other->getKCells(0);
+	CrossNodeMap h = myNodes->makeCrossNodeMap(yourNodes);
+
+	tpost = gettime();
+	AbstractCellArray *newnodes;
+	ca1 = this->getKCells(0);
+	ca2 = Other->getKCells(0);
+
+	Dim_t SIFTDIM = d;
+
+	//cout << "crossing 0-cells" << endl;
+	newnodes = ca1->Cross(ca2, h);
+	//    cout << gettime() - tpost << " ( Cross(0-cells) ) " << endl;
+
+	//tpost = gettime();
+	//    cout << gettime() - tpost << " ( Append(0-cells) ) " << endl;
 
 //    tpost = gettime();
 //    caOut->buildInvertedIndex();
 //    cout << gettime() - tpost << " ( BuildIndex(0-cells) ) " << endl;
 
-  Out->setKCells( newnodes, 0 );
+	Out->setKCells(newnodes, 0);
+
+	//CellArray *kcellsout = new CellArray();
 
-  //CellArray *kcellsout = new CellArray();
+	//tpost = gettime();
+	//ca1 = this->getKCells(getdim());
+	//ca2 = Other->getKCells(Other->getdim());
+	//cout << "crossing d-cells" << endl;
+	//c = ca1->Cross( ca2, h );
+	//cout << this->name << ": " << this->getdim() << ", " << Other->name << ", " << Other->getdim() << endl;
+	//if (Other->getdim() == 0) {
+	//Other->print();
+	//}
+
+	//    cout << gettime() - tpost << " ( Cross(d-cells) ) " << endl;
+
+	tpost = gettime();
+	//kcellsout->Append( c );
+	//    cout << gettime() - tpost << " ( Append(d-cells) ) " << endl;
 
-  //tpost = gettime();
-  //ca1 = this->getKCells(getdim());
-  //ca2 = Other->getKCells(Other->getdim());
-  //cout << "crossing d-cells" << endl;
-  //c = ca1->Cross( ca2, h ); 
-  //cout << this->name << ": " << this->getdim() << ", " << Other->name << ", " << Other->getdim() << endl;
-  //if (Other->getdim() == 0) {
-    //Other->print();
-  //}
-    
-    //    cout << gettime() - tpost << " ( Cross(d-cells) ) " << endl;
-    
-  tpost = gettime();
-  //kcellsout->Append( c );     
-    //    cout << gettime() - tpost << " ( Append(d-cells) ) " << endl;
-  
-  //tpost = gettime();
-    //kcellsout->buildInvertedIndex();
+	//tpost = gettime();
+	//kcellsout->buildInvertedIndex();
 //   cout << gettime() - tpost << " ( BuildIndex(d-cells) ) " << endl;
-  
 
-   //Out->setKCells( kcellsout, d );
-   //Out->setKCells( c, d );
- 
-   
-  AbstractCellArray *foo;
-  CellArray *caOut;
-  for ( int k=1; k<=d; k++ ) {
-    caOut = new CellArray();
-    //cout << "k: " << k << endl;
-    if (k!=SIFTDIM) continue;
-    for ( int j=0; j<=k; j++ ) {
-    //cout << "j: " << j << endl;
-      //cout << j << " cross " << k-j << endl;
-      ca1 = this->getKCells( j );
-      ca2 = Other->getKCells( k - j );
-      //      cout << "ca1:" << j << "\n";
-      //      ca1->print(10);
-      //      cout << "ca2: " << k-j << "\n";
-      //      ca2->print(11);
+	//Out->setKCells( kcellsout, d );
+	//Out->setKCells( c, d );
+
+	AbstractCellArray *foo;
+	CellArray *caOut;
+	for (int k = 1; k <= d; k++) {
+		caOut = new CellArray();
+		//cout << "k: " << k << endl;
+		if (k != SIFTDIM) continue;
+		for (int j = 0; j <= k; j++) {
+			//cout << "j: " << j << endl;
+			//cout << j << " cross " << k-j << endl;
+			ca1 = this->getKCells(j);
+			ca2 = Other->getKCells(k - j);
+			//      cout << "ca1:" << j << "\n";
+			//      ca1->print(10);
+			//      cout << "ca2: " << k-j << "\n";
+			//      ca2->print(11);
 //      cout << "Cross..." << flush;
-      tpost = gettime();
-      foo = ca1->Cross( ca2, h ); 
-      
-      //cout << (gettime() - tpost) << "\n";
-      //cout << "Append..." << flush;
-      tpost = gettime();
-      caOut->Append( foo );
-      foo->unref();
-      //cout << (gettime() - tpost) << "\n"; 
-    }  
-    
+			tpost = gettime();
+			foo = ca1->Cross(ca2, h);
+
+			//cout << (gettime() - tpost) << "\n";
+			//cout << "Append..." << flush;
+			tpost = gettime();
+			caOut->Append(foo);
+			foo->unref();
+			//cout << (gettime() - tpost) << "\n";
+		}
+
 //    cout << "buildInvertedIndex...." << flush;
 
 //    tpost = gettime();
 //    caOut->buildInvertedIndex();
-//    cout << (gettime() - tpost) << "\n"; 
-    Out->setKCells( caOut, k );
-  }
-   
-  return Out;
-}
-
-void Grid::setImplicit0Cells(int count) {
-  Implicit0Cells *cells = new Implicit0Cells(count);
-  assert(count > 0);
-  Grid *G = this;
-  /*
-  CellArray *cells = new CellArray();
-  
-  for (int i=0; i<count; i++)
-    cells->addCellNodes(&i, 1);
-  */
-  G->setKCells(cells, 0);
-}
-
-void Grid::shareCells(Grid *Out, Dim_t d) {
-  Grid *In = this;
-  
-  In->cellsets[d]->ref();
-  Out->setKCells(In->cellsets[d], d);
-}
-
-void Grid::copyCells(Grid *Out, bool *filter, Dim_t i) {
-  Grid *In = this;
-  //filter must be the correct size!
-
-  AbstractCellArray *kcells;
-  CellArray *newkcells = new CellArray();
-  unsigned int j=0;
-  
-  kcells = In->cellsets[i];
-  for (j=0; j<kcells->getsize(); j++) {
-    if (filter[j]) {
-      Cell c(kcells->getCellCopy(j));
-      newkcells->addCell(&c);
-    }
-  } //cell loop#include "crossnodemap.h"
-  Out->setKCells(newkcells, i);
-}
-
-void Grid::IncidentTo(CellId cid, Dim_t i, vector<CellId> &out, Dim_t j) {
-    AbstractCellArray *ci = this->getKCells(i);
-    AbstractCellArray *cj = this->getKCells(j);
-    Cell *c = ci->getCell(cid);
-
-    set<CellId> incis;
-    cj->getIncidentCells(*c, incis);
-
-    COPY(vector<CellId>, incis, out, ii)
-}
-
-
-void Grid::nodeFilter(Grid *Out, bool *filter) {
-  Grid *In = this;
-  
-  AbstractCellArray *kcells;
-  AbstractCellArray *zerocells;
-  CellArray *newkcells;
-  Node *nodes;
-
-  unsigned int i,j,k;
-  Dim_t d = In->getdim();
-  bool copy = true;
-
-  if (In->empty()) {
-    Warning("The grid to filter is empty.");
-    return;
-  }
-
-  zerocells = In->cellsets[0];
-  hash_map<int, int> nodemap(zerocells->getsize());
-  for (unsigned int n=0; n<zerocells->getsize(); n++) {
-    Cell c(zerocells->getCellCopy(n));
-    Node x = c.getnodes()[0];
-    nodemap[x] = n;
-  }
- 
-  for (k=0; k<=d; k++) {
-    newkcells = (CellArray *) Out->getKCells(k);
-    kcells = In->cellsets[k];
-    
-    for (j=0; j<kcells->getsize(); j++) {
-      Cell c(kcells->getCellCopy(j));
-      nodes = c.getnodes();
-      i=0;
-      while (i<c.getsize() && copy) {
-	if (!filter[nodemap[nodes[i++]]]) {
-	  copy = false;
-	  break;
-	}
-      }
- 
-      if (copy) { newkcells->addCell(&c); }
-      copy = true;
-    } //cells
-  }//dim
+//    cout << (gettime() - tpost) << "\n";
+		Out->setKCells(caOut, k);
+	}
+
+	return Out;
+}
+
+void Grid::setImplicit0Cells(int count)
+{
+	Implicit0Cells *cells = new Implicit0Cells(count);
+	assert(count > 0);
+	Grid *G = this;
+	/*
+	 CellArray *cells = new CellArray();
+
+	 for (int i=0; i<count; i++)
+	 cells->addCellNodes(&i, 1);
+	 */
+	G->setKCells(cells, 0);
 }
 
-int Grid::cellCount(int d) {
-  return cellsets[d]->getsize();
+void Grid::shareCells(Grid *Out, Dim_t d)
+{
+	Grid *In = this;
+
+	In->cellsets[d]->ref();
+	Out->setKCells(In->cellsets[d], d);
+}
+
+void Grid::copyCells(Grid *Out, bool *filter, Dim_t i)
+{
+	Grid *In = this;
+	//filter must be the correct size!
+
+	AbstractCellArray *kcells;
+	CellArray *newkcells = new CellArray();
+	unsigned int j = 0;
+
+	kcells = In->cellsets[i];
+	for (j = 0; j < kcells->getsize(); j++) {
+		if (filter[j]) {
+			Cell c(kcells->getCellCopy(j));
+			newkcells->addCell(&c);
+		}
+	} //cell loop#include "crossnodemap.h"
+	Out->setKCells(newkcells, i);
+}
+
+void Grid::IncidentTo(CellId cid, Dim_t i, vector<CellId> &out, Dim_t j)
+{
+	AbstractCellArray *ci = this->getKCells(i);
+	AbstractCellArray *cj = this->getKCells(j);
+	Cell *c = ci->getCell(cid);
+
+	set<CellId> incis;
+	cj->getIncidentCells(*c, incis);
+
+	COPY(vector<CellId>, incis, out, ii)
+}
+
+void Grid::nodeFilter(Grid *Out, bool *filter)
+{
+	Grid *In = this;
+
+	AbstractCellArray *kcells;
+	AbstractCellArray *zerocells;
+	CellArray *newkcells;
+	Node *nodes;
+
+	// Moved below. jhrg 4/8/14  unsigned int i,j,k;
+	Dim_t d = In->getdim();
+	bool copy = true;
+
+	if (In->empty()) {
+		Warning("The grid to filter is empty.");
+		return;
+	}
+
+	zerocells = In->cellsets[0];
+	HASH_MAP<int, int> nodemap(zerocells->getsize());
+	for (unsigned int n = 0; n < zerocells->getsize(); n++) {
+		Cell c(zerocells->getCellCopy(n));
+		Node x = c.getnodes()[0];
+		nodemap[x] = n;
+	}
+
+	for (int k = 0; k <= d; k++) {
+		newkcells = (CellArray *) Out->getKCells(k);
+		kcells = In->cellsets[k];
+
+		for (unsigned int j = 0; j < kcells->getsize(); j++) {
+			Cell c(kcells->getCellCopy(j));
+			nodes = c.getnodes();
+			unsigned int i = 0;
+			while (i < c.getsize() && copy) {
+				if (!filter[nodemap[nodes[i++]]]) {
+					copy = false;
+					break;
+				}
+			}
+
+			if (copy) {
+				newkcells->addCell(&c);
+			}
+			copy = true;
+		} //cells
+	} //dim
+}
+
+int Grid::cellCount(int d)
+{
+	return cellsets[d]->getsize();
 }
 /*
-unsigned int Grid::Size(Dim_t k) { 
-  //cout << "Size: " << k << ", " << cellsets.size() << endl;
-  assert(k<cellsets.size()); 
-  return cellsets[k]->getsize();
-};
-*/
-
-void Grid::normalize() {
-  AbstractCellArray *ca = this->getKCells(0);
-  NormNodeMap h(ca);
-  //cout << " normalizing nodes..." << endl;
-  for (int i=0; i<=getdim(); i++) {
-    getKCells(i)->mapNodes(h);
-  }
-  //this->setKCells(new Implicit0Cells(ca->getsize()), 0);
-  //ca->unref();
-}
-
-void Grid::mapNodes(UnaryNodeMap &h) {
-  for (int i=0; i<=getdim(); i++) {
-    getKCells(i)->mapNodes(h);
-  }
-}
-
-void Grid::setReferent(OrdMap *om) {
-  this->ordmap = om;
-}
-
-bool Grid::checkWellFormed() {
-  Grid *G = this;
-  int i, d,s; 
-  set<Node> A;
-  set<Node> B;
-  set<Node>::iterator iter;
-  bool x=true;
-  AbstractCellArray *ca;
-
-  d = G->getdim();
-  G->cellsets[0]->toNodeSet(A);
-
-  for (i=1; i<=d; i++) {
-    ca = G->cellsets[i];
-    if (ca->getsize() == 0) continue;
-    ca->toNodeSet(B);
-    iter = B.begin();
-
-    //check subset relationship
-    for (; iter!=B.end(); iter++) {
-      s = A.size();
-      A.insert(*iter);
-      x = ((signed)A.size() == s);
-      if (!x) break;
-    }
-  }
-  return x;
-}
-
-void Grid::print() { print(0); }
-
-void Grid::print(int indent) {
-  Grid *G = this;
-  int i,j;
-  for (i=0; i<indent; i++) cout << " ";
-  cout << "<GRID> " << "\n";
-  for (i=0; i<indent; i++) cout << " ";
-  cout << "name: " << G->name << "\n";
-  for (i=0; i<indent; i++) cout << " ";
-  cout << "dim: " << G->getdim() << "\n";
-  for (j=0; j<=G->getdim(); j++) {
-    for (i=0; i<indent; i++) printf(" ");
-    cout << j << "-cells: " << G->cellsets[j] << "\n";
-    if (G->cellsets[j] == NULL) {
-      for (i=0; i<indent; i++) cout << " ";
-      cout << "--none--\n";
-    } else {
-      G->cellsets[j]->print(indent+2);
-    }
-  }
-}
-
-void Grid::ref() {
-  int old = refcount;
-  Object::ref(); 
-  DEBUG << "grid " << this << ", " << this->name << ", ref: " << old << " -> " << this->refcount << endl;
-}
-
-void Grid::unref() {
-  int old = refcount;
-  Object::unref();
-  DEBUG << "grid " << this << ", " << this->name << ", unref: " << old << " -> " << this->refcount << endl;
-  if (this->norefs()) {
-
-    DEBUG << "deleting " << this->name << "..." << endl;
-    delete this;
-  }
-}
-
-Grid::~Grid() {
-  DEBUG << "~grid: " << this << endl;
-  g_instances--;
-
-  int i;
-  for (i=0; i<(signed)cellsets.size(); i++) {
-    AbstractCellArray *ca = this->cellsets[i];
-    DEBUG << " unreffing cellarray " << i << flush; 
-    ca->unref();
-    DEBUG << "...done" << endl; 
-  }
+ unsigned int Grid::Size(Dim_t k) {
+ //cout << "Size: " << k << ", " << cellsets.size() << endl;
+ assert(k<cellsets.size());
+ return cellsets[k]->getsize();
+ };
+ */
+
+void Grid::normalize()
+{
+	AbstractCellArray *ca = this->getKCells(0);
+	NormNodeMap h(ca);
+	//cout << " normalizing nodes..." << endl;
+	for (int i = 0; i <= getdim(); i++) {
+		getKCells(i)->mapNodes(h);
+	}
+	//this->setKCells(new Implicit0Cells(ca->getsize()), 0);
+	//ca->unref();
+}
+
+void Grid::mapNodes(UnaryNodeMap &h)
+{
+	for (int i = 0; i <= getdim(); i++) {
+		getKCells(i)->mapNodes(h);
+	}
+}
+
+void Grid::setReferent(OrdMap *om)
+{
+	this->ordmap = om;
+}
+
+bool Grid::checkWellFormed()
+{
+	Grid *G = this;
+	int i, d, s;
+	set<Node> A;
+	set<Node> B;
+	set<Node>::iterator iter;
+	bool x = true;
+	AbstractCellArray *ca;
+
+	d = G->getdim();
+	G->cellsets[0]->toNodeSet(A);
+
+	for (i = 1; i <= d; i++) {
+		ca = G->cellsets[i];
+		if (ca->getsize() == 0) continue;
+		ca->toNodeSet(B);
+		iter = B.begin();
+
+		//check subset relationship
+		for (; iter != B.end(); iter++) {
+			s = A.size();
+			A.insert(*iter);
+			x = ((signed) A.size() == s);
+			if (!x) break;
+		}
+	}
+	return x;
+}
 
+void Grid::print()
+{
+	print(0);
+}
+
+void Grid::print(int indent)
+{
+	Grid *G = this;
+	int i, j;
+	for (i = 0; i < indent; i++)
+		cout << " ";
+	cout << "<GRID> " << "\n";
+	for (i = 0; i < indent; i++)
+		cout << " ";
+	cout << "name: " << G->name << "\n";
+	for (i = 0; i < indent; i++)
+		cout << " ";
+	cout << "dim: " << G->getdim() << "\n";
+	for (j = 0; j <= G->getdim(); j++) {
+		for (i = 0; i < indent; i++)
+			printf(" ");
+		cout << j << "-cells: " << G->cellsets[j] << "\n";
+		if (G->cellsets[j] == NULL) {
+			for (i = 0; i < indent; i++)
+				cout << " ";
+			cout << "--none--\n";
+		}
+		else {
+			G->cellsets[j]->print(indent + 2);
+		}
+	}
+}
+
+void Grid::ref()
+{
+	int old = refcount;
+	Object::ref();
+	DEBUG << "grid " << this << ", " << this->name << ", ref: " << old << " -> " << this->refcount << endl;
+}
+
+void Grid::unref()
+{
+	int old = refcount;
+	Object::unref();
+	DEBUG << "grid " << this << ", " << this->name << ", unref: " << old << " -> " << this->refcount << endl;
+	if (this->norefs()) {
+
+		DEBUG << "deleting " << this->name << "..." << endl;
+		delete this;
+	}
+}
+
+Grid::~Grid()
+{
+	DEBUG << "~grid: " << this << endl;
+	g_instances--;
+
+	int i;
+	for (i = 0; i < (signed) cellsets.size(); i++) {
+		AbstractCellArray *ca = this->cellsets[i];
+		DEBUG << " unreffing cellarray " << i << flush;
+		ca->unref();
+		DEBUG << "...done" << endl;
+	}
 
-  delete ordmap;
+	delete ordmap;
 }
+
+} // namespace GF
+
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/gridfield.cc gridfields/clib/src/gridfield.cc
--- tag/gridfieldsclib-0.7/src/gridfield.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/gridfield.cc	2014-05-16 22:57:00.813391865 +0200
@@ -1,299 +1,336 @@
+#include "config_gridfields.h"
+
 #include "gridfield.h"
 #include "array.h"
 #include "util.h"
 #include "grid.h"
 #include <string>
 
-GridField::GridField(Grid *G) : grid(G) {
-  this->init(G);
-}
-
+namespace GF {
 
-GridField::GridField(Grid *G, Dim_t k, Array *arr) {
-  this->init(G);
-  this->Bind(k, arr);
+GridField::GridField(Grid *G) :
+		grid(G)
+{
+	this->init(G);
 }
 
-
-GridField::GridField(GridField *GF) {
-  this->init(GF->grid);
-  for(Dim_t k=0; k<=GF->Dim(); k++) {
-    this->Zip(k, GF->GetDataset(k));
-  }
+GridField::GridField(Grid *G, Dim_t k, Array *arr)
+{
+	this->init(G);
+	this->Bind(k, arr);
 }
 
+GridField::GridField(GridField *GF)
+{
+	this->init(GF->grid);
+	for (Dim_t k = 0; k <= GF->Dim(); k++) {
+		this->Zip(k, GF->GetDataset(k));
+	}
+}
 
-void GridField::PrepareForExecution() { };
-bool GridField::Updated(float ) { return false; }
-void GridField::Execute() { this->Result = this; };
+void GridField::PrepareForExecution()
+{
+}
+;
+bool GridField::Updated(float)
+{
+	return false;
+}
+void GridField::Execute()
+{
+	this->Result = this;
+}
+;
 
+void GridField::init(Grid *G)
+{
 
-void GridField::init(Grid *G) {
+	//cleanup tells the base class to delete a gridfield;
+	//we'll take care of this ourselves, though
+	Dim_t d = G->getdim();
+	Shape s(d + 1, 0);
+	for (int i = 0; i < d + 1; i++) {
+		s[i] = G->Size(i);
+	}
+	this->SetShape(s);
+	//this->cleanup = false;
 
-  //cleanup tells the base class to delete a gridfield;
-  //we'll take care of this ourselves, though
-  Dim_t d = G->getdim();
-  Shape s(d+1,0);
-  for (int i=0; i<d+1; i++) {
-    s[i] = G->Size(i);
-  }
-  this->SetShape(s);
-  //this->cleanup = false;
-  
-  this->updated = false;
+	this->updated = false;
 
-  this->Result = this;
+	this->Result = this;
 
-  this->grid = G;
-  this->grid->ref();
+	this->grid = G;
+	this->grid->ref();
 }
 
-void GridField::setGrid(Grid *G) {
-  Grid *tmp = this->grid;  
-  G->ref(); 
-  this->grid = G; 
-  tmp->unref();
+void GridField::setGrid(Grid *G)
+{
+	Grid *tmp = this->grid;
+	G->ref();
+	this->grid = G;
+	tmp->unref();
 }
 
-
 /*
-void GridField::flattenAttr(string attr) {
-  Array *a = this->getAttribute(attr.c_str());
-  Array *b;
-  if (a->type == OBJ) {
-    Scheme *sch = a->getScheme();
-    for (int i=0; i<sch->size(); i++) {
-      b = new Array(a, sch->getAttribute(i));
-      this->Bind(b);
-    }
-    this->unBind(attr);
-  }
-}
-*/
-
-void GridField::RangeRestrict(Dim_t k, const GridField &G) {
-  const Dataset &ds = G.GetDataset(k);
-  Scheme s = ds.GetScheme();
-
-  unsigned int ncells = this->Card(k);
-  unsigned int ntups = ds.Size();
-  (void)ntups;
-  // make sure there are attributes to restrict
-  if (s.size() == 0) return;
+ void GridField::flattenAttr(string attr) {
+ Array *a = this->getAttribute(attr.c_str());
+ Array *b;
+ if (a->type == OBJ) {
+ Scheme *sch = a->getScheme();
+ for (int i=0; i<sch->size(); i++) {
+ b = new Array(a, sch->getAttribute(i));
+ this->Bind(b);
+ }
+ this->unBind(attr);
+ }
+ }
+ */
+
+void GridField::RangeRestrict(Dim_t k, const GridField &G)
+{
+	const Dataset &ds = G.GetDataset(k);
+	Scheme s = ds.GetScheme();
+
+	unsigned int ncells = this->Card(k);
+	unsigned int ntups = ds.Size();
+	(void) ntups;
+	// make sure there are attributes to restrict
+	if (s.size() == 0) return;
 
 //  this->AddAttribute(
-  this->CoerceScheme(k, &s, ncells);
-  const Dataset &newds = this->GetDataset(k);
+	this->CoerceScheme(k, &s, ncells);
+	const Dataset &newds = this->GetDataset(k);
 
-  Tuple from(&s);
-  Tuple to(&s);
+	Tuple from(&s);
+	Tuple to(&s);
 
-  AbstractCellArray *kcells = grid->getKCells(k);
-  AbstractCellArray *otherkcells = G.grid->getKCells(k);
-  for (unsigned int i=0; i<ncells; i++) {
-    Cell *c = kcells->getCell(i);
-    int j = otherkcells->getOrd(*c);
-    if (i>= ds.Size()) cout << "error? " << i << ", " << ds.Size() << endl;
-    newds.FastBindTuple(i, to);
-    ds.FastBindTuple(j, from);
-    to.copy(from);
-  }
-  //this->Zip(k, newds);
-}
-
-void GridField::RestrictAll(const GridField &Base) {
-  // (this) is a subgrid of Base
-  // find data values of Base ssociated with the cells of (this)
-  // create and bind the values as attributes
-  for (Dim_t k=0; k<=Dim(); k++) {
-    //Base.GetScheme(k).PrintTo(cout, 5);
-    this->RangeRestrict(k, Base);
-  }
+	AbstractCellArray *kcells = grid->getKCells(k);
+	AbstractCellArray *otherkcells = G.grid->getKCells(k);
+	for (unsigned int i = 0; i < ncells; i++) {
+		Cell *c = kcells->getCell(i);
+		int j = otherkcells->getOrd(*c);
+		if (i >= ds.Size()) cout << "error? " << i << ", " << ds.Size() << endl;
+		newds.FastBindTuple(i, to);
+		ds.FastBindTuple(j, from);
+		to.copy(from);
+	}
+	//this->Zip(k, newds);
+}
+
+void GridField::RestrictAll(const GridField &Base)
+{
+	// (this) is a subgrid of Base
+	// find data values of Base ssociated with the cells of (this)
+	// create and bind the values as attributes
+	for (Dim_t k = 0; k <= Dim(); k++) {
+		//Base.GetScheme(k).PrintTo(cout, 5);
+		this->RangeRestrict(k, Base);
+	}
 }
 
 /*
-void GridField::subGridData(Grid *subgrid, vector<Array *> &outvec) {
-  //provides dataset corresponding to the kcells in the subgrid
-  Array *arr;
-  Cell *c;
-  int o;
-
-  bool *filter = new bool[this->card()];
-  for (int i=0; i<this->card(); i++) {
-    filter[i] = false;
-  }
-
-  AbstractCellArray *kcells = grid->getKCells(k);
-  AbstractCellArray *subkcells = subgrid->getKCells(k);
-  int size = subkcells->getsize();
-
-  for (int i=0; i<size; i++) {
-    c = subkcells->getCell(i);
-    o = kcells->getOrd((const Cell) *c);
-    if (o == -1) {
-      Fatal("Grid %s passed to subgGridData not a subgrid of %s", 
-	    subgrid->name.c_str(), this->grid->name.c_str());
-    }
-    filter[o] = true;
-  }
-   
-
-  for (int j=0; j<attributes.size(); j++) {
-    arr = attributes[j]->copyAndFilter(filter);
-//    arr->print();
-    outvec.push_back(arr);
-  }
-}
-*/
+ void GridField::subGridData(Grid *subgrid, vector<Array *> &outvec) {
+ //provides dataset corresponding to the kcells in the subgrid
+ Array *arr;
+ Cell *c;
+ int o;
+
+ bool *filter = new bool[this->card()];
+ for (int i=0; i<this->card(); i++) {
+ filter[i] = false;
+ }
+
+ AbstractCellArray *kcells = grid->getKCells(k);
+ AbstractCellArray *subkcells = subgrid->getKCells(k);
+ int size = subkcells->getsize();
+
+ for (int i=0; i<size; i++) {
+ c = subkcells->getCell(i);
+ o = kcells->getOrd((const Cell) *c);
+ if (o == -1) {
+ Fatal("Grid %s passed to subgGridData not a subgrid of %s",
+ subgrid->name.c_str(), this->grid->name.c_str());
+ }
+ filter[o] = true;
+ }
+
+
+ for (int j=0; j<attributes.size(); j++) {
+ arr = attributes[j]->copyAndFilter(filter);
+ //    arr->print();
+ outvec.push_back(arr);
+ }
+ }
+ */
 /*
-void GridField::NextTuple(Tuple &t) {
-  for (int i=0; i<t.size(); i++) {
-    attr = t.getAttribute(i);
-    t.set(attr, this->getAttributeVal(attr.c_str(), idx));
-  }
-}
-*/
+ void GridField::NextTuple(Tuple &t) {
+ for (int i=0; i<t.size(); i++) {
+ attr = t.getAttribute(i);
+ t.set(attr, this->getAttributeVal(attr.c_str(), idx));
+ }
+ }
+ */
 /* Coerces a gridfield to a new scheme, allocating
  * new arays as necessary
  */
 
-int GridField::notValid() {
-  GridField *GF = this;
-  int i, size;(void)i;(void)size;
-  Grid *G;
-  G = GF->grid;
-
-  for (Dim_t k=0; k<this->Dim(); k++) {
-    // |k-cells| == |data values|
-    if (G->cellsets[k]->getsize() != this->GetDataset(k).Size()) {
-      return 6;
-    }
-  }
-
-  return 0;
+int GridField::notValid()
+{
+	GridField *GF = this;
+	int i, size;
+	(void) i;
+	(void) size;
+	Grid *G;
+	G = GF->grid;
+
+	for (Dim_t k = 0; k < this->Dim(); k++) {
+		// |k-cells| == |data values|
+		if (G->cellsets[k]->getsize() != this->GetDataset(k).Size()) {
+			return 6;
+		}
+	}
+
+	return 0;
 
 }
 
-
-void GridField::lookupInt(string attr, Dim_t k, int p, vector<CellId> &out) {
-  Array *arr = this->GetAttribute(k, attr);
-  assert(arr->type == INT);
-  int *data;
-
-  arr->getData(data);
-  
-  size_t n = Size(k);
-  for (unsigned int i=0; i<n; i++) {
-    if (data[i] == p) { 
-      out.push_back(i);
-    }
-  }
+void GridField::lookupInt(string attr, Dim_t k, int p, vector<CellId> &out)
+{
+	Array *arr = this->GetAttribute(k, attr);
+	assert(arr->type == INT);
+	int *data;
+
+	arr->getData(data);
+
+	size_t n = Size(k);
+	for (unsigned int i = 0; i < n; i++) {
+		if (data[i] == p) {
+			out.push_back(i);
+		}
+	}
 }
 
 template<class T>
-void nearestfunc(Array *arr, string, Dim_t, UnTypedPtr p, vector<CellId> &out) {
-  typedef T valtype;
-  valtype near, v;
-  valtype pf = *(valtype *)p;
-  near = *(valtype *)arr->getValPtr(0);
-  int nearest=0;
-  
-  for (int i=1; i<arr->size(); i++) {
-    v = *(valtype *)arr->getValPtr(i);
-    if (abs(pf-v) <= abs(pf-near)) {
-      nearest = i;
-      near = v;
-    }
-  }
-  out.push_back(nearest);
-}
-
-void GridField::nearest(const string &attr, Dim_t k, UnTypedPtr p, vector<CellId> &out) {
-  Array *arr = this->GetAttribute(k, attr);
-  switch (arr->type) {
-    case INT:
-      nearestfunc<int>(arr, attr, k, p, out);
-      break;
-    case FLOAT:
-      nearestfunc<float>(arr, attr, k, p, out);
-      break;
-    default:
-      Fatal("nearest not defined on object types");
-      break;
-  }
-}
-
-void GridField::lookupFloat(string attr, Dim_t k, float p, vector<CellId> &out) {
-  Array *arr = this->GetAttribute(k, attr);
-  assert(arr->type == FLOAT);
-  float *data;
-
-  arr->getData(data);
-  
-  size_t n = Size(k);
-  for (unsigned int i=0; i<n; i++) {
-    if (data[i] == p) { 
-      out.push_back(i);
-    }
-  }
-}
-
-void GridField::print(int a) {
-  this->PrintTo(cout, a);
-}
-void GridField::print() {
-  this->PrintTo(cout, 0);
-}
-
-void GridField::PrintTo(ostream &os, int indent) const {
-  os << "GridField:" <<endl;
-  grid->print(indent+2);
-
-  for (int i=0; i<=Dim(); i++) {
-    GetDataset(i).PrintTo(os, indent+4);
-  }
-}
-
-void GridField::unref() {
-  int old = refcount;
-  Object::unref();
-  DEBUG << "gridfield.unref " << this << ", " << this->grid->name << ", unref: " << old << " -> " << this->refcount << endl;
-  if (this->norefs()) {
-
-    DEBUG << "deleting gridfield" << this->grid->name << "..." << endl;
-    this->Result = NULL;
-    delete this;
-  }
-
-} 
-
-GridField::~GridField() {
-  DEBUG << "ref count at destruction: " << this->refcount << endl;
-  DEBUG << "gridfield deleted: " << this->grid->name << ", " << this->grid->refcount << endl;
-  if (grid != NULL) this->grid->unref();
-}
-
-UnitGridField::UnitGridField() : GridField(new UnitGrid()){
-}
-
-void UnitGridField::Bind(const string &name, int val) {
-  Array *arr = new Array(name, INT, 1);
-  int *aval;
-  arr->getData(aval);
-  *aval = val;
-  GridField::Bind(0, arr);
-}
-void UnitGridField::Bind(const string &name, float val) {
-  Array *arr = new Array(name, INT, 1);
-  float *aval;
-  arr->getData(aval);
-  *aval = val;
-  GridField::Bind(0, arr);
-}
-void UnitGridField::Bind(const string &name, UnTypedPtr val) {
-  Array *arr = new Array(name, INT, 1);
-  UnTypedPtr *aval;
-  arr->getData(aval);
-  *aval = val;
-  GridField::Bind(0, arr);
+void nearestfunc(Array *arr, string, Dim_t, UnTypedPtr p, vector<CellId> &out)
+{
+	typedef T valtype;
+	valtype near, v;
+	valtype pf = *(valtype *) p;
+	near = *(valtype *) arr->getValPtr(0);
+	int nearest = 0;
+
+	for (int i = 1; i < arr->size(); i++) {
+		v = *(valtype *) arr->getValPtr(i);
+		if (abs(pf - v) <= abs(pf - near)) {
+			nearest = i;
+			near = v;
+		}
+	}
+	out.push_back(nearest);
+}
+
+void GridField::nearest(const string &attr, Dim_t k, UnTypedPtr p, vector<CellId> &out)
+{
+	Array *arr = this->GetAttribute(k, attr);
+	switch (arr->type) {
+	case INT:
+		nearestfunc<int>(arr, attr, k, p, out);
+		break;
+	case FLOAT:
+		nearestfunc<float>(arr, attr, k, p, out);
+		break;
+	default:
+		Fatal("nearest not defined on object types");
+		break;
+	}
+}
+
+void GridField::lookupFloat(string attr, Dim_t k, float p, vector<CellId> &out)
+{
+	Array *arr = this->GetAttribute(k, attr);
+	assert(arr->type == FLOAT);
+	float *data;
+
+	arr->getData(data);
+
+	size_t n = Size(k);
+	for (unsigned int i = 0; i < n; i++) {
+		if (data[i] == p) {
+			out.push_back(i);
+		}
+	}
+}
+
+void GridField::print(int a)
+{
+	this->PrintTo(cout, a);
+}
+void GridField::print()
+{
+	this->PrintTo(cout, 0);
+}
+
+void GridField::PrintTo(ostream &os, int indent) const
+{
+	os << "GridField:" << endl;
+	grid->print(indent + 2);
+
+	for (int i = 0; i <= Dim(); i++) {
+		GetDataset(i).PrintTo(os, indent + 4);
+	}
+}
+
+void GridField::unref()
+{
+	int old = refcount;
+	Object::unref();
+	DEBUG << "gridfield.unref " << this << ", " << this->grid->name << ", unref: " << old << " -> " << this->refcount
+			<< endl;
+	if (this->norefs()) {
+
+		DEBUG << "deleting gridfield" << this->grid->name << "..." << endl;
+		this->Result = NULL;
+		delete this;
+	}
+
+}
+
+GridField::~GridField()
+{
+	DEBUG << "ref count at destruction: " << this->refcount << endl;
+	DEBUG << "gridfield deleted: " << this->grid->name << ", " << this->grid->refcount << endl;
+	if (grid != NULL) this->grid->unref();
+}
+
+UnitGridField::UnitGridField() :
+		GridField(new UnitGrid())
+{
+}
+
+void UnitGridField::Bind(const string &name, int val)
+{
+	Array *arr = new Array(name, INT, 1);
+	int *aval;
+	arr->getData(aval);
+	*aval = val;
+	GridField::Bind(0, arr);
+}
+void UnitGridField::Bind(const string &name, float val)
+{
+	Array *arr = new Array(name, INT, 1);
+	float *aval;
+	arr->getData(aval);
+	*aval = val;
+	GridField::Bind(0, arr);
+}
+void UnitGridField::Bind(const string &name, UnTypedPtr val)
+{
+	Array *arr = new Array(name, INT, 1);
+	UnTypedPtr *aval;
+	arr->getData(aval);
+	*aval = val;
+	GridField::Bind(0, arr);
 }
+
+} // namespace GF
+
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/gridfield.h gridfields/clib/src/gridfield.h
--- tag/gridfieldsclib-0.7/src/gridfield.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/gridfield.h	2014-05-16 22:57:00.756725199 +0200
@@ -9,69 +9,91 @@
 #include "rankeddataset.h"
 #include "tuple.h"
 
+namespace GF {
+
 class Array;
 
-class GridField : public RankedDataset, public GridFieldOperator {
+class GridField: public RankedDataset, public GridFieldOperator {
 
- public:
-  GridField(Grid *G);
-  GridField(Grid *G, Dim_t k, Array *arr);
-  GridField(GridField *G);
-  ~GridField();
-
-  //void Bind(vector<Tuple *> &data);
-
-  void setGrid(Grid *G); 
-
-  //void subGridData(Grid *A, vector<Array *> &outvec); 
-  void nearest(const string &attr, Dim_t k, UnTypedPtr p, vector<CellId> &out);
-
-  void lookupInt(string attr, Dim_t k, int p, vector<CellId> &out);
-  void lookupFloat(string attr, Dim_t k, float p, vector<CellId> &out);
-
-  void Clear() { RankedDataset::Clear(); grid->unref(); }
-
-  Cell *getKCell(Dim_t k, CellId c) {
-    return this->grid->getKCells(k)->getCell(c);
-  };
-
-  void unref();
-  int notValid();
-  void RestrictAll(const GridField &Base);
-  void RangeRestrict(Dim_t k, const GridField &Base);
-  void print();
-  void print(int a);
-  void PrintTo(ostream &os, int indent) const; 
-
-  // gridfields are a trivial subclass of gridfieldoperator
-  void PrepareForExecution();
-  bool Updated(float sincetime);
-  void Execute();
-
-  Dim_t Dim() const { return this->grid->getdim(); };
-  size_t Card(Dim_t k) const { return this->grid->Size(k); };
-  
-  Grid *GetGrid() { return grid; };
-  friend class RestrictOp;
-
-  void ref() {
-    //cout << "ref: " << this << "(" << old << ")" << endl;
-    Object::ref();
-  }
-
- private:
-  Grid *grid;
-  void init(Grid *G);
+public:
+	GridField(Grid *G);
+	GridField(Grid *G, Dim_t k, Array *arr);
+	GridField(GridField *G);
+	~GridField();
+
+	//void Bind(vector<Tuple *> &data);
+
+	void setGrid(Grid *G);
+
+	//void subGridData(Grid *A, vector<Array *> &outvec);
+	void nearest(const string &attr, Dim_t k, UnTypedPtr p, vector<CellId> &out);
+
+	void lookupInt(string attr, Dim_t k, int p, vector<CellId> &out);
+	void lookupFloat(string attr, Dim_t k, float p, vector<CellId> &out);
+
+	void Clear()
+	{
+		RankedDataset::Clear();
+		grid->unref();
+	}
+
+	Cell *getKCell(Dim_t k, CellId c)
+	{
+		return this->grid->getKCells(k)->getCell(c);
+	}
+	;
+
+	void unref();
+	int notValid();
+	void RestrictAll(const GridField &Base);
+	void RangeRestrict(Dim_t k, const GridField &Base);
+	void print();
+	void print(int a);
+	void PrintTo(ostream &os, int indent) const;
+
+	// gridfields are a trivial subclass of gridfieldoperator
+	void PrepareForExecution();
+	bool Updated(float sincetime);
+	void Execute();
+
+	Dim_t Dim() const
+	{
+		return this->grid->getdim();
+	}
+	;
+	size_t Card(Dim_t k) const
+	{
+		return this->grid->Size(k);
+	}
+	;
+
+	Grid *GetGrid()
+	{
+		return grid;
+	}
+	;
+	friend class RestrictOp;
+
+	void ref()
+	{
+		//cout << "ref: " << this << "(" << old << ")" << endl;
+		Object::ref();
+	}
+
+private:
+	Grid *grid;
+	void init(Grid *G);
 
 };
 
-
-class UnitGridField : public GridField {
-  public: 
-    UnitGridField();
-    void Bind(const string &name, int val);
-    void Bind(const string &name, float val);
-    void Bind(const string &name, UnTypedPtr val);
+class UnitGridField: public GridField {
+public:
+	UnitGridField();
+	void Bind(const string &name, int val);
+	void Bind(const string &name, float val);
+	void Bind(const string &name, UnTypedPtr val);
 };
 
+} // namespace GF
+
 #endif /*_GRIDFIELD_H */
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/gridfieldoperator.cc gridfields/clib/src/gridfieldoperator.cc
--- tag/gridfieldsclib-0.7/src/gridfieldoperator.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/gridfieldoperator.cc	2014-05-16 22:57:00.796725198 +0200
@@ -1,3 +1,4 @@
+#include "config_gridfields.h"
 
 #include "timing.h"
 #include <iostream>
@@ -5,128 +6,156 @@
 #include "gridfield.h"
 #include "expr.h"
 using namespace std;
-ZeroaryGridFieldOperator::ZeroaryGridFieldOperator() {};
 
-UnaryGridFieldOperator::UnaryGridFieldOperator(GridFieldOperator *prev) 
-        : PreviousOp(prev), GF(NULL) {};
+namespace GF {
 
-BinaryGridFieldOperator::BinaryGridFieldOperator(GridFieldOperator *L, 
-                                                 GridFieldOperator *R)
-        : LeftOp(L), RightOp(R), A(NULL), B(NULL) {};
-
-GridFieldOperator::GridFieldOperator() : 
-         Result(NULL), updated(true), modtime(0) { //cleanup(true), { 
-}
-
-GridField *GridFieldOperator::getResult() { 
-  if (this->Updated(this->modtime)) {
-    //if (this->Result) { this->Result->getScheme()->print();}
-    GridField *tmp = this->Result;
-    this->modtime = gettime();
-    this->updated = false;
-    DEBUG << "Executing....";
-    this->Execute();
-    DEBUG << "Finished.";
-    if (tmp) {
-      DEBUG << "UNREFFING the result"<< endl;
-      tmp->unref();
-    }
-  }
-  DEBUG << "refcount: " << this->Result->refcount << endl;
-  return this->Result; 
-};
-
-void ZeroaryGridFieldOperator::PrepareForExecution() {} 
-
-void UnaryGridFieldOperator::PrepareForExecution() {
-  if (this->PreviousOp == NULL) {
-     if (this->GF == NULL) {
-       Fatal("No gridfield or previous operator provided as input to Operator.");
-     }
-  } else {
-    if (this->GF == NULL) {
-      //Warning("Overwriting GridField pointer with previous op's output.");
-    }
-    this->GF = this->PreviousOp->getResult();
-  }
-  
-  if (this->GF == NULL) {
-    Fatal("No gridfield provided as input to Operator.");
-  }
-  //std::cout << "UnOp: " << gettime() - start << std::endl; 
-}
-
-void BinaryGridFieldOperator::PrepareForExecution() {
-  char arg = '0';
-  if (this->LeftOp == NULL && this->A == NULL) {
-    arg = 'A';
-  }
-  if (this->RightOp == NULL && this->B == NULL) {
-    arg = 'B';
-  }
-  if (arg != '0') {
-    Fatal("No %c argument or previous operator provided as input to Operator.", arg);
-  }
-  
-  //cout << this->LeftOp << ", " << this->A << endl;
-  //cout << this->LeftOp->Updated() << endl;
-  if (this->LeftOp != NULL && this->A != NULL) {
-    arg = 'A';
-  }
-  if (this->RightOp != NULL && this->B != NULL) {
-    arg = 'B';
-  }
-  if (arg != '0') {
-  //  Warning("Overwriting pointer to argument %c with previous op's output.", arg);
-  }
-  
-  this->A = this->LeftOp->getResult();
-  this->B = this->RightOp->getResult();
-  
-  if (this->A == NULL || this->B == NULL) {
-    Fatal("No gridfield available as input to binary operator.");
-  }
-  //std::cout << "BinOp: " << gettime() - start << std::endl; 
-}
-
-GridFieldOperator::~GridFieldOperator() {
-  // if we're a trivial gridfield operator, do nothing
-  // otherwise dispose of our result
+ZeroaryGridFieldOperator::ZeroaryGridFieldOperator()
+{
+}
+;
+
+UnaryGridFieldOperator::UnaryGridFieldOperator(GridFieldOperator *prev) :
+		PreviousOp(prev), GF(NULL)
+{
+}
+;
+
+BinaryGridFieldOperator::BinaryGridFieldOperator(GridFieldOperator *L, GridFieldOperator *R) :
+		LeftOp(L), RightOp(R), A(NULL), B(NULL)
+{
+}
+;
+
+GridFieldOperator::GridFieldOperator() :
+		Result(NULL), updated(true), modtime(0)
+{ //cleanup(true), {
+}
+
+GridField *GridFieldOperator::getResult()
+{
+	if (this->Updated(this->modtime)) {
+		//if (this->Result) { this->Result->getScheme()->print();}
+		GridField *tmp = this->Result;
+		this->modtime = gettime();
+		this->updated = false;
+		DEBUG << "Executing....";
+		this->Execute();
+		DEBUG << "Finished.";
+		if (tmp) {
+			DEBUG << "UNREFFING the result" << endl;
+			tmp->unref();
+		}
+	}
+	DEBUG << "refcount: " << this->Result->refcount << endl;
+	return this->Result;
+}
+;
+
+void ZeroaryGridFieldOperator::PrepareForExecution()
+{
+}
+
+void UnaryGridFieldOperator::PrepareForExecution()
+{
+	if (this->PreviousOp == NULL) {
+		if (this->GF == NULL) {
+			Fatal("No gridfield or previous operator provided as input to Operator.");
+		}
+	}
+	else {
+		if (this->GF == NULL) {
+			//Warning("Overwriting GridField pointer with previous op's output.");
+		}
+		this->GF = this->PreviousOp->getResult();
+	}
+
+	if (this->GF == NULL) {
+		Fatal("No gridfield provided as input to Operator.");
+	}
+	//std::cout << "UnOp: " << gettime() - start << std::endl;
+}
+
+void BinaryGridFieldOperator::PrepareForExecution()
+{
+	char arg = '0';
+	if (this->LeftOp == NULL && this->A == NULL) {
+		arg = 'A';
+	}
+	if (this->RightOp == NULL && this->B == NULL) {
+		arg = 'B';
+	}
+	if (arg != '0') {
+		Fatal("No %c argument or previous operator provided as input to Operator.", arg);
+	}
+
+	//cout << this->LeftOp << ", " << this->A << endl;
+	//cout << this->LeftOp->Updated() << endl;
+	if (this->LeftOp != NULL && this->A != NULL) {
+		arg = 'A';
+	}
+	if (this->RightOp != NULL && this->B != NULL) {
+		arg = 'B';
+	}
+	if (arg != '0') {
+		//  Warning("Overwriting pointer to argument %c with previous op's output.", arg);
+	}
+
+	this->A = this->LeftOp->getResult();
+	this->B = this->RightOp->getResult();
+
+	if (this->A == NULL || this->B == NULL) {
+		Fatal("No gridfield available as input to binary operator.");
+	}
+	//std::cout << "BinOp: " << gettime() - start << std::endl;
+}
+
+GridFieldOperator::~GridFieldOperator()
+{
+	// if we're a trivial gridfield operator, do nothing
+	// otherwise dispose of our result
 //  cout << this << ", " << this->Result << ", " << (this->Result == this) << endl;
-  //if (this->cleanup) {
-    
- // DEBUG << "~gridfieldop: " << this << ", " << this->Result << ", " << this->Result->GetGrid() << " -> " << endl;
-    
-    //cout << "deleting result gridfield" << endl;
-    //this->Result->unref();
-  //clearResult();
- // }
-  //DEBUG << "Delete operator"  << endl;
+	//if (this->cleanup) {
+
+	// DEBUG << "~gridfieldop: " << this << ", " << this->Result << ", " << this->Result->GetGrid() << " -> " << endl;
+
+	//cout << "deleting result gridfield" << endl;
+	//this->Result->unref();
+	//clearResult();
+	// }
+	//DEBUG << "Delete operator"  << endl;
 }
 
-inline bool ZeroaryGridFieldOperator::Updated(float sincetime) {
-  return this->updated || this->modtime > sincetime;
+inline bool ZeroaryGridFieldOperator::Updated(float sincetime)
+{
+	return this->updated || this->modtime > sincetime;
 }
 
-bool UnaryGridFieldOperator::Updated(float sincetime) {
-  bool result = this->updated || this->modtime > sincetime || this->PreviousOp->Updated(sincetime);
-  return result;
+bool UnaryGridFieldOperator::Updated(float sincetime)
+{
+	bool result = this->updated || this->modtime > sincetime || this->PreviousOp->Updated(sincetime);
+	return result;
 }
 
-bool BinaryGridFieldOperator::Updated(float sincetime) {
-  bool result =  this->updated || this->modtime > sincetime 
-	      || this->LeftOp->Updated(sincetime) || this->RightOp->Updated(sincetime);
-  return result;
+bool BinaryGridFieldOperator::Updated(float sincetime)
+{
+	bool result = this->updated || this->modtime > sincetime || this->LeftOp->Updated(sincetime)
+			|| this->RightOp->Updated(sincetime);
+	return result;
 }
 
-void GridFieldOperator::Update() {
-  this->updated = true;
+void GridFieldOperator::Update()
+{
+	this->updated = true;
 }
 
-void GridFieldOperator::clearResult() {
-  DEBUG << "Clear operator"  << endl;
-  if (this->Result) { // && this->cleanup) {
-    //delete this->Result;
-    this->Result->unref();
-  }
+void GridFieldOperator::clearResult()
+{
+	DEBUG << "Clear operator" << endl;
+	if (this->Result) { // && this->cleanup) {
+		//delete this->Result;
+		this->Result->unref();
+	}
 }
+
+} // namespace GF
+
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/gridfieldoperator.h gridfields/clib/src/gridfieldoperator.h
--- tag/gridfieldsclib-0.7/src/gridfieldoperator.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/gridfieldoperator.h	2014-05-16 22:57:00.736725199 +0200
@@ -3,66 +3,103 @@
 
 #include "object.h"
 
+namespace GF {
+
 class GridField;
 
 //class GridFieldOperator : public Object {
 class GridFieldOperator {
 public:
-  GridFieldOperator();
-  virtual ~GridFieldOperator();
-  GridField *getResult();
-  virtual void Execute() = 0;
-  void Update();
-  void clearResult();
-  virtual bool Updated(float sincetime)=0;
-  float getModTime() { return this->modtime; };
+	GridFieldOperator();
+	virtual ~GridFieldOperator();
+	GridField *getResult();
+	virtual void Execute() = 0;
+	void Update();
+	void clearResult();
+	virtual bool Updated(float sincetime)=0;
+	float getModTime()
+	{
+		return this->modtime;
+	}
+	;
 protected:
-  //bool cleanup;
-  virtual void PrepareForExecution() = 0;
-  GridField *Result;
-  bool updated;
-  float modtime;
+	//bool cleanup;
+	virtual void PrepareForExecution() = 0;
+	GridField *Result;
+	bool updated;
+	float modtime;
 };
 
-class ZeroaryGridFieldOperator : public GridFieldOperator {
-  public:
-    bool Updated(float sincetime);
-  protected:
-    ZeroaryGridFieldOperator();
-    void PrepareForExecution();
+class ZeroaryGridFieldOperator: public GridFieldOperator {
+public:
+	bool Updated(float sincetime);
+protected:
+	ZeroaryGridFieldOperator();
+	void PrepareForExecution();
 };
 
-class UnaryGridFieldOperator : public GridFieldOperator {
-  public: 
-    bool Updated(float sincetime);
-    GridFieldOperator *GetPrevious() { return this->PreviousOp; this->Update(); };
-    void SetPrevious(GridFieldOperator *Op) { this->PreviousOp = Op; this->Update();};
-    
-    
-  protected:
-    UnaryGridFieldOperator(GridFieldOperator *prev);
-    void PrepareForExecution();
-    GridFieldOperator *PreviousOp;
-    GridField *GF;
+class UnaryGridFieldOperator: public GridFieldOperator {
+public:
+	bool Updated(float sincetime);
+	GridFieldOperator *GetPrevious()
+	{
+		return this->PreviousOp;
+		this->Update();
+	}
+	;
+	void SetPrevious(GridFieldOperator *Op)
+	{
+		this->PreviousOp = Op;
+		this->Update();
+	}
+	;
+
+protected:
+	UnaryGridFieldOperator(GridFieldOperator *prev);
+	void PrepareForExecution();
+	GridFieldOperator *PreviousOp;
+	GridField *GF;
 };
 
-class BinaryGridFieldOperator : public GridFieldOperator {
-  public:
-    bool Updated(float sincetime);
-    GridFieldOperator *GetLeft() { return this->LeftOp; };
-    void SetLeft(GridFieldOperator *L) { this->LeftOp = L; this->Update(); };
-    GridFieldOperator *GetRight() { return this->RightOp; };
-    void SetRight(GridFieldOperator *R) { this->RightOp = R; this->Update(); };
-
-  protected:
-    BinaryGridFieldOperator(GridFieldOperator *L, GridFieldOperator *R);
-    BinaryGridFieldOperator() {};
-    void PrepareForExecution();
-    GridFieldOperator *LeftOp;
-    GridFieldOperator *RightOp;
-    GridField *A;
-    GridField *B;
+class BinaryGridFieldOperator: public GridFieldOperator {
+public:
+	bool Updated(float sincetime);
+	GridFieldOperator *GetLeft()
+	{
+		return this->LeftOp;
+	}
+	;
+	void SetLeft(GridFieldOperator *L)
+	{
+		this->LeftOp = L;
+		this->Update();
+	}
+	;
+	GridFieldOperator *GetRight()
+	{
+		return this->RightOp;
+	}
+	;
+	void SetRight(GridFieldOperator *R)
+	{
+		this->RightOp = R;
+		this->Update();
+	}
+	;
+
+protected:
+	BinaryGridFieldOperator(GridFieldOperator *L, GridFieldOperator *R);
+	BinaryGridFieldOperator()
+	{
+	}
+	;
+	void PrepareForExecution();
+	GridFieldOperator *LeftOp;
+	GridFieldOperator *RightOp;
+	GridField *A;
+	GridField *B;
 };
 
+} // namespace GF
 
 #endif
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/gridfields_hash_map.h.in gridfields/clib/src/gridfields_hash_map.h.in
--- tag/gridfieldsclib-0.7/src/gridfields_hash_map.h.in	1970-01-01 01:00:00.000000000 +0100
+++ gridfields/clib/src/gridfields_hash_map.h.in	2014-05-16 22:57:00.776725199 +0200
@@ -0,0 +1,23 @@
+
+#ifndef _gridfields_hash_map_h
+#define _gridfields_hash_map_h
+
+// This header is built by configure. We need to be able to use either
+// ext/hash_map, tr1/unordered_map or unordered_map to define the
+// type of the map used by cellarray.h/.cc but we do not want to use
+// #defines in config.h since we would have to include that header in
+// cellarray.h which means that when other code uses this library symbol
+// name conflicts will occur (since autoconf uses the same symbol names
+// the 'client' code's #define VERSION ... will result in a noisy 
+// compiler warning.
+
+#include @GF_UNORDERED_MAP_HEADER@  // typical value: <unordered_map>
+#define HASH_MAP @GF_HASH_MAP@      // typically: std::unordered_map
+
+// if we are still working with the GNU 'hash_map'? If so, make sure
+// to set the namespace
+@GF_HASH_MAP_NAMESPACE@             // namespace GF { using namespace __gnu_cxx } or null
+
+@GF_USE_REHASH@                     // '#define USE_REHASH' or not
+
+#endif // _gridfields_hash_map_h
\ Brak znaku nowej linii na kocu pliku
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/grid.h gridfields/clib/src/grid.h
--- tag/gridfieldsclib-0.7/src/grid.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/grid.h	2014-05-16 22:57:00.783391865 +0200
@@ -12,152 +12,168 @@
 #include "util.h"
 #include "ordmap.h"
 
+namespace GF {
+using namespace std;
+
 class UnaryNodeMap;
 //class OrdMap;
 
 string testString(const string &s);
-class Grid : public Object {
+class Grid: public Object {
 //class Grid  {
 
- public:
-  string name;
+public:
+	string name;
 
-  Grid(string nm, Dim_t d);
-  Grid(string nm);
-  Grid(string nm, Dim_t d, OrdMap *om);
-  void ref();
-  void unref();
-  ~Grid();
-
-  std::string getName() { return this->name; }
-  void init(string nm, Dim_t d, OrdMap *om);
-
-  Dim_t getdim();
-  unsigned int Size(Dim_t k) {
-// cerr << "Grid::Size: k = " << k << endl;
-    assert(k<cellsets.size()); 
-    return cellsets[k]->getsize();
-  };
-  void setKCells(AbstractCellArray *cells, Dim_t k);
-  AbstractCellArray *getKCells(Dim_t k);
-  void setImplicit0Cells(int count);
-  unsigned int countKCells(Dim_t k);
-
-  bool empty();
-
-  // Out grid references In's k-cells
-  void shareCells(Grid *Out, Dim_t k);
-  // Copy In's k-cells to Out, subject to the bitmap filter
-  void copyCells(Grid *Out, bool *filter, Dim_t k);
-  //void nodeFilter(Grid *Out, vector<Node> &badnodes);
-  void nodeFilter(Grid *Out, bool *filter);
-  bool checkWellFormed();
-  int cellCount(int d);
-/*
-  void IncidentTo(CellId cid, Dim_t i, _OutputIterator<CellId> out, Dim_t j) {
-    AbstractCellArray *ci = this->getKCells(i);
-    AbstractCellArray *cj = this->getKCells(j);
-    Cell *c = ci->getCell(cid);
-
-    set<CellId> incis;
-    cj->getIncidentCells(*c, incis);
-
-    FOR (set<CellId>, x, incis) {
-      *out = x;
-      ++out;
-    }
-  }
-*/
-  void IncidentTo(CellId cid, Dim_t i, vector<CellId> &out, Dim_t j);
-
-  void normalize();
-  void mapNodes(UnaryNodeMap &h);
-  void setReferent(OrdMap *om);
-  
-  Grid *Intersection(Grid *Other);
-  Grid *Cross(Grid *Other);
-
-  void print(int indent);
-  void print();
-  friend class GridField;
-  OrdMap *ordmap;
-
- private:
-  //int dim;
-  vector<AbstractCellArray *> cellsets;
+	Grid(string nm, Dim_t d);
+	Grid(string nm);
+	Grid(string nm, Dim_t d, OrdMap *om);
+	void ref();
+	void unref();
+	// Added virtual to dtor since delete is called and Grid is abstract
+	// jhrg 2/13/14
+	virtual ~Grid();
+
+	std::string getName()
+	{
+		return this->name;
+	}
+	void init(string nm, Dim_t d, OrdMap *om);
+
+	Dim_t getdim();
+	unsigned int Size(Dim_t k)
+	{
+		// cerr << "Grid::Size: k = " << k << ", cellsets.size() = " << cellsets.size() << endl;
+		assert((unsigned )k < cellsets.size());
+		return cellsets[k]->getsize();
+	}
+	;
+	void setKCells(AbstractCellArray *cells, Dim_t k);
+	AbstractCellArray *getKCells(Dim_t k);
+	void setImplicit0Cells(int count);
+	unsigned int countKCells(Dim_t k);
+
+	bool empty();
+
+	// Out grid references In's k-cells
+	void shareCells(Grid *Out, Dim_t k);
+	// Copy In's k-cells to Out, subject to the bitmap filter
+	void copyCells(Grid *Out, bool *filter, Dim_t k);
+	//void nodeFilter(Grid *Out, vector<Node> &badnodes);
+	void nodeFilter(Grid *Out, bool *filter);
+	bool checkWellFormed();
+	int cellCount(int d);
+	/*
+	 void IncidentTo(CellId cid, Dim_t i, _OutputIterator<CellId> out, Dim_t j) {
+	 AbstractCellArray *ci = this->getKCells(i);
+	 AbstractCellArray *cj = this->getKCells(j);
+	 Cell *c = ci->getCell(cid);
+
+	 set<CellId> incis;
+	 cj->getIncidentCells(*c, incis);
+
+	 FOR (set<CellId>, x, incis) {
+	 *out = x;
+	 ++out;
+	 }
+	 }
+	 */
+	void IncidentTo(CellId cid, Dim_t i, vector<CellId> &out, Dim_t j);
+
+	void normalize();
+	void mapNodes(UnaryNodeMap &h);
+	void setReferent(OrdMap *om);
+
+	Grid *Intersection(Grid *Other);
+	Grid *Cross(Grid *Other);
+
+	void print(int indent);
+	void print();
+	friend class GridField;
+	OrdMap *ordmap;
+
+private:
+	//int dim;
+	vector<AbstractCellArray *> cellsets;
 
 };
 
-class UnitGrid : public Grid {
+class UnitGrid: public Grid {
+
+public:
 
- public:
+	UnitGrid() :
+			Grid("unit", 0)
+	{
+		CellArray *nodes = new CellArray();
+		Cell *c = new Cell(1);
+		c->getnodes()[0] = 0;
+		nodes->addCell(c);
+		this->setKCells(nodes, 0);
+		this->ref();
+	}
+	;
 
-  UnitGrid() : Grid("unit", 0) {
-    CellArray *nodes = new CellArray();
-    Cell *c = new Cell(1);
-    c->getnodes()[0] = 0;
-    nodes->addCell(c);
-    this->setKCells(nodes, 0);
-    this->ref();
-  };
-  
 };
 /*
-class ProductGrid : public Grid {
-   string name;
+ class ProductGrid : public Grid {
+ string name;
+
+ Grid(Grid *A, Grid *B);
+ void ref();
+ void unref();
+ ~Grid();
+
+ std::string getName() { return this->name; }
+
+ Dim_t getdim() { return ;
+ unsigned int Size(Dim_t k) {
+ assert(k<cellsets.size());
+ return cellsets[k]->getsize();
+ };
+ void setKCells(AbstractCellArray *cells, Dim_t k);
+ AbstractCellArray *getKCells(Dim_t k);
+ void setImplicit0Cells(int count);
+ unsigned int countKCells(Dim_t k);
+
+ bool Grid::empty();
+
+ // Out grid references In's k-cells
+ void shareCells(Grid *Out, Dim_t k);
+ // Copy In's k-cells to Out, subject to the bitmap filter
+ void copyCells(Grid *Out, bool *filter, Dim_t k);
+ //void nodeFilter(Grid *Out, vector<Node> &badnodes);
+ void nodeFilter(Grid *Out, bool *filter);
+ bool checkWellFormed();
+ int cellCount(int d);
+
+ void IncidentTo(CellId cid, Dim_t i, vector<CellId> &out, Dim_t j) {
+ AbstractCellArray *ci = this->getKCells(i);
+ AbstractCellArray *cj = this->getKCells(j);
+ Cell *c = ci->getCell(cid);
+
+ set<CellId> incis;
+ cj->getIncidentCells(*c, incis);
+
+ COPY(vector<CellId>, incis, out, ii)
+ }
+
+ void normalize();
+ void mapNodes(UnaryNodeMap &h);
+ void setReferent(OrdMap *om);
+
+ Grid *Intersection(Grid *Other);
+ Grid *Cross(Grid *Other);
+
+ void print(int indent);
+ void print();
+ friend class GridField;
+ OrdMap *ordmap;
+
+ }
+ */
+
+} // namespace GF
 
-  Grid(Grid *A, Grid *B);
-  void ref();
-  void unref();
-  ~Grid();
-
-  std::string getName() { return this->name; }
- 
-  Dim_t getdim() { return ;
-  unsigned int Size(Dim_t k) {
-    assert(k<cellsets.size());
-  return cellsets[k]->getsize();
-  };
-  void setKCells(AbstractCellArray *cells, Dim_t k);
-  AbstractCellArray *getKCells(Dim_t k);
-  void setImplicit0Cells(int count);
-  unsigned int countKCells(Dim_t k);
- 
-  bool Grid::empty();
- 
-  // Out grid references In's k-cells
-  void shareCells(Grid *Out, Dim_t k);
-  // Copy In's k-cells to Out, subject to the bitmap filter
-  void copyCells(Grid *Out, bool *filter, Dim_t k);
-  //void nodeFilter(Grid *Out, vector<Node> &badnodes);
-  void nodeFilter(Grid *Out, bool *filter);
-  bool checkWellFormed();
-  int cellCount(int d);
- 
-  void IncidentTo(CellId cid, Dim_t i, vector<CellId> &out, Dim_t j) {
-    AbstractCellArray *ci = this->getKCells(i);
-    AbstractCellArray *cj = this->getKCells(j);
-    Cell *c = ci->getCell(cid);
- 
-    set<CellId> incis;
-    cj->getIncidentCells(*c, incis);
- 
-    COPY(vector<CellId>, incis, out, ii)
-  }
- 
-  void normalize();
-  void mapNodes(UnaryNodeMap &h);
-  void setReferent(OrdMap *om);
-   
-  Grid *Intersection(Grid *Other);
-  Grid *Cross(Grid *Other);
- 
-  void print(int indent);
-  void print();
-  friend class GridField;
-  OrdMap *ordmap;
- 
-}
-*/
 #endif /* _GRID_H */
 
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/idnodemap.h gridfields/clib/src/idnodemap.h
--- tag/gridfieldsclib-0.7/src/idnodemap.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/idnodemap.h	2014-05-16 22:57:00.823391864 +0200
@@ -3,14 +3,28 @@
 
 #include "unarynodemap.h"
 
-class IdNodeMap : public UnaryNodeMap {
+namespace GF {
 
- public: 
-  IdNodeMap() : UnaryNodeMap() { };
-  virtual Node map(Node a) { return a };
-  Node inv(Node o) { return o; }
-  
- private:
+class IdNodeMap: public UnaryNodeMap {
+
+public:
+	IdNodeMap() :
+			UnaryNodeMap()
+	{
+	}
+	;
+	virtual Node map(Node a)
+	{
+	return a}
+;
+Node inv(Node o)
+{
+	return o;
+}
+
+private:
 };
 
+} // namespace GF
+
 #endif /* _IDNODEMAP_H */
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/idordmap.h gridfields/clib/src/idordmap.h
--- tag/gridfieldsclib-0.7/src/idordmap.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/idordmap.h	2014-05-16 22:57:00.790058532 +0200
@@ -3,20 +3,37 @@
 
 #include "ordmap.h"
 
-class IdOrdMap : public OrdMap {
+namespace GF {
 
- public: 
-  IdOrdMap(Grid *g) { G = g; };
-  virtual ~IdOrdMap() {};
-  virtual int getBaseOrd(Cell *c, int d) { 
-    AbstractCellArray *cells = G->getKCells(d);
-    int pos = cells->getOrd(*c);
-    return pos; 
-  };
-  virtual int getBaseSize(int d) { return G->cellCount(d); };
-  
- private:
-  Grid *G;
+class IdOrdMap: public OrdMap {
+
+public:
+	IdOrdMap(Grid *g)
+	{
+		G = g;
+	}
+	;
+	virtual ~IdOrdMap()
+	{
+	}
+	;
+	virtual int getBaseOrd(Cell *c, int d)
+	{
+		AbstractCellArray *cells = G->getKCells(d);
+		int pos = cells->getOrd(*c);
+		return pos;
+	}
+	;
+	virtual int getBaseSize(int d)
+	{
+		return G->cellCount(d);
+	}
+	;
+
+private:
+	Grid *G;
 };
 
+} // namespace GF
+
 #endif /* _IDORDMAP_H */
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/implicit0cells.cc gridfields/clib/src/implicit0cells.cc
--- tag/gridfieldsclib-0.7/src/implicit0cells.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/implicit0cells.cc	2014-05-16 22:57:00.773391865 +0200
@@ -1,3 +1,5 @@
+#include "config_gridfields.h"
+
 #include "implicit0cells.h"
 #include "implicitcrossnodemap.h"
 #include "crossnodemap.h"
@@ -6,165 +8,195 @@
 #include "util.h"
 #include <assert.h>
 #include <iterator>
-#include <ext/algorithm> 
+#include <algorithm>
+// jhrg 2/13/14 #include <ext/algorithm>
 
-void Implicit0Cells::print() {
-  this->print(0);
-}
+namespace GF {
 
-void Implicit0Cells::print(size_t indent) {
-  Implicit0Cells *ca = this;
-  size_t i;
-
-  for (i=0; i<indent; i++) cout << " ";
-  cout << "<CELLARRAY>: \n";
-  for (i=0; i<indent; i++) cout << " ";
-  cout << "size: " << ca->size << "\n";
-  cout << "nodecount: " << ca->getNodeCount() << "\n";
-  for (i=0; i<indent; i++) cout << " ";
-  cout << "cells: \n";
-    cout << "(implicit)" << endl;
-}
-
-void Implicit0Cells::toNodeSet(set<Node> &outset) {
-  for (size_t i=0; i<this->size; i++) {
-    outset.insert(i);
-  }
-}
-
-Cell Implicit0Cells::getCellCopy(idx i) {
-  assert(i < this->getsize());
-  Cell c(1);
-  c.getnodes()[0] = i;
-  return c;
-}
-
-Cell *Implicit0Cells::getCell(idx i) { 
-    assert(i < this->getsize());
-    if (i+1 > this->cleanup.size()) {
-      Cell c(1);
-      this->cleanup.resize(i+1, c);
-    }
-    Cell *r = &this->cleanup[i];
-    Node *n = r->getnodes();
-    n[0] = Node(i);
-    return r;
-}
-
-void Implicit0Cells::getIncidentCells(const Cell &c, set<CellId> &out) {
-  for (unsigned int i=0; i<c.getsize(); i++) {
-    out.insert(c.getnodes()[i]);
-  }
-}
-
-void Implicit0Cells::getIncidentCells(Node n, set<CellId> &out) {
-    out.insert(n);
-}
-
-
-void Implicit0Cells::mapNodes(NormNodeMap &) {  }; 
-void Implicit0Cells::mapNodes(UnaryNodeMap &) { 
-  //if (h.whoami() != NORMNODEMAP) {
-  //  Fatal("Can't map implicit nodes"); 
-  //}
-}; 
-  
-vector<Cell> *Implicit0Cells::getCellVector() {
-  Node *nodes = new Node[this->size];
-  vector<Cell> *cells = new vector<Cell>(this->size, Cell(1));
-  vector<Cell>::iterator p;
-  
-  for (size_t i=0; i<this->size; ++i) {
-    cells->operator[](i).setnodes(&nodes[i]);
-    nodes[i] = i;
-  }
-  return cells;
-}
-
-CellArray *Implicit0Cells::asCellArray() {
-  return new CellArray(*this->getCellVector());
-}
-
-CrossNodeMap Implicit0Cells::makeCrossNodeMap(Implicit0Cells *other) {
-    return ImplicitCrossNodeMap(this, other);
-}
-
-CrossNodeMap Implicit0Cells::makeCrossNodeMap(AbstractCellArray *other) {
-  if (other->whoami()) {
-    return CrossNodeMap(this, other);
-  } else {
-    return CrossNodeMap(this, other);
-    //return ImplicitCrossNodeMap(this, (Implicit0Cells *) other);
-  }
-}
-
-AbstractCellArray *Implicit0Cells::Cross(AbstractCellArray *othercells, CrossNodeMap &h) {
-  if (othercells->whoami()) {
-    Node nodes[this->size];
-  
-    for (size_t i=0; i<this->size; ++i) {
-      nodes[i] = i;
-    }
-  
-    CellArray ca(nodes, this->size, 1);
-    CellArray *out = ca.Cross(othercells, h);
-    //cout <<"slow implicit cross" << endl;
-    return out;
-  } else {
-    //cout <<"fast implicit cross" << endl;
-    return new Implicit0Cells(this->size * ((Implicit0Cells *)othercells)->size);  
-  }
-}
-
-Implicit0Cells *Implicit0Cells::Cross(Implicit0Cells *othercells, CrossNodeMap &) {
-  return new Implicit0Cells(this->size * othercells->size);  
-}
-
-
-CellArray *Implicit0Cells::Intersection(AbstractCellArray *othercells) {
-  CellArray *out = new CellArray();
-
-  Cell *c;
-  int max = this->size;
-  size_t count = othercells->getsize();
-  int node=-1;
-  for (size_t i=0; i<count; ++i) {
-    c = othercells->getCell(i);
-    
-    if (c->getsize() != 1) {
-      Fatal("Error: Attempt to intersect 0-cells with k-cells, k>0");
-    }
-    node = c->getnodes()[0];
-    if ((node>=0) && (node<max)) {
-      out->addCell(c);
-    }
-
-  }
-  return out;
-}
-
-Implicit0Cells *Implicit0Cells::Intersection(Implicit0Cells *others) {
-  if (this->size >= others->size) {
-    return others;
-  } else {
-    return this;
-  }
-}
-
-void Implicit0Cells::unref() {
-  int old = this->refcount;
-  if (old == 0) cout << "bad refcount" << endl;
-  Object::unref();
-  //cout << "implicit0cells " << this << ", unref: " << old << " -> " << this->refcount << endl;
-  if (this->norefs()) {
-    //cout << "deleting implicit0cells" << endl;
-    delete this;
-  }
-}
-
-void Implicit0Cells::ref() {
-  //cout << "cellarray ref" << endl;
-  Object::ref();
+void Implicit0Cells::print()
+{
+	this->print(0);
+}
+
+void Implicit0Cells::print(size_t indent)
+{
+	Implicit0Cells *ca = this;
+	size_t i;
+
+	for (i = 0; i < indent; i++)
+		cout << " ";
+	cout << "<CELLARRAY>: \n";
+	for (i = 0; i < indent; i++)
+		cout << " ";
+	cout << "size: " << ca->size << "\n";
+	cout << "nodecount: " << ca->getNodeCount() << "\n";
+	for (i = 0; i < indent; i++)
+		cout << " ";
+	cout << "cells: \n";
+	cout << "(implicit)" << endl;
+}
+
+void Implicit0Cells::toNodeSet(set<Node> &outset)
+{
+	for (size_t i = 0; i < this->size; i++) {
+		outset.insert(i);
+	}
+}
+
+Cell Implicit0Cells::getCellCopy(idx i)
+{
+	assert(i < this->getsize());
+	Cell c(1);
+	c.getnodes()[0] = i;
+	return c;
+}
+
+Cell *Implicit0Cells::getCell(idx i)
+{
+	assert(i < this->getsize());
+	if (i + 1 > this->cleanup.size()) {
+		Cell c(1);
+		this->cleanup.resize(i + 1, c);
+	}
+	Cell *r = &this->cleanup[i];
+	Node *n = r->getnodes();
+	n[0] = Node(i);
+	return r;
+}
+
+void Implicit0Cells::getIncidentCells(const Cell &c, set<CellId> &out)
+{
+	for (unsigned int i = 0; i < c.getsize(); i++) {
+		out.insert(c.getnodes()[i]);
+	}
+}
+
+void Implicit0Cells::getIncidentCells(Node n, set<CellId> &out)
+{
+	out.insert(n);
+}
+
+void Implicit0Cells::mapNodes(NormNodeMap &)
+{
+}
+;
+void Implicit0Cells::mapNodes(UnaryNodeMap &)
+{
+	//if (h.whoami() != NORMNODEMAP) {
+	//  Fatal("Can't map implicit nodes");
+	//}
+}
+;
+
+vector<Cell> *Implicit0Cells::getCellVector()
+{
+	Node *nodes = new Node[this->size];
+	vector<Cell> *cells = new vector<Cell>(this->size, Cell(1));
+	vector<Cell>::iterator p;
+
+	for (size_t i = 0; i < this->size; ++i) {
+		cells->operator[](i).setnodes(&nodes[i]);
+		nodes[i] = i;
+	}
+	return cells;
+}
+
+CellArray *Implicit0Cells::asCellArray()
+{
+	return new CellArray(*this->getCellVector());
+}
+
+CrossNodeMap Implicit0Cells::makeCrossNodeMap(Implicit0Cells *other)
+{
+	return ImplicitCrossNodeMap(this, other);
+}
+
+CrossNodeMap Implicit0Cells::makeCrossNodeMap(AbstractCellArray *other)
+{
+	if (other->whoami()) {
+		return CrossNodeMap(this, other);
+	}
+	else {
+		return CrossNodeMap(this, other);
+		//return ImplicitCrossNodeMap(this, (Implicit0Cells *) other);
+	}
+}
+
+AbstractCellArray *Implicit0Cells::Cross(AbstractCellArray *othercells, CrossNodeMap &h)
+{
+	if (othercells->whoami()) {
+		Node nodes[this->size];
+
+		for (size_t i = 0; i < this->size; ++i) {
+			nodes[i] = i;
+		}
+
+		CellArray ca(nodes, this->size, 1);
+		CellArray *out = ca.Cross(othercells, h);
+		//cout <<"slow implicit cross" << endl;
+		return out;
+	}
+	else {
+		//cout <<"fast implicit cross" << endl;
+		return new Implicit0Cells(this->size * ((Implicit0Cells *) othercells)->size);
+	}
+}
+
+Implicit0Cells *Implicit0Cells::Cross(Implicit0Cells *othercells, CrossNodeMap &)
+{
+	return new Implicit0Cells(this->size * othercells->size);
+}
+
+CellArray *Implicit0Cells::Intersection(AbstractCellArray *othercells)
+{
+	CellArray *out = new CellArray();
+
+	Cell *c;
+	int max = this->size;
+	size_t count = othercells->getsize();
+	int node = -1;
+	for (size_t i = 0; i < count; ++i) {
+		c = othercells->getCell(i);
+
+		if (c->getsize() != 1) {
+			Fatal("Error: Attempt to intersect 0-cells with k-cells, k>0");
+		}
+		node = c->getnodes()[0];
+		if ((node >= 0) && (node < max)) {
+			out->addCell(c);
+		}
+
+	}
+	return out;
+}
+
+Implicit0Cells *Implicit0Cells::Intersection(Implicit0Cells *others)
+{
+	if (this->size >= others->size) {
+		return others;
+	}
+	else {
+		return this;
+	}
+}
+
+void Implicit0Cells::unref()
+{
+	int old = this->refcount;
+	if (old == 0) cout << "bad refcount" << endl;
+	Object::unref();
+	//cout << "implicit0cells " << this << ", unref: " << old << " -> " << this->refcount << endl;
+	if (this->norefs()) {
+		//cout << "deleting implicit0cells" << endl;
+		delete this;
+	}
+}
+
+void Implicit0Cells::ref()
+{
+	//cout << "cellarray ref" << endl;
+	Object::ref();
 }
 
+} // namespace GF
 
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/implicit0cells.h gridfields/clib/src/implicit0cells.h
--- tag/gridfieldsclib-0.7/src/implicit0cells.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/implicit0cells.h	2014-05-16 22:57:00.830058531 +0200
@@ -1,10 +1,10 @@
 #ifndef _IMPLICIT0CELLS_H
-#define _IMPLICIT0CELLS_H 
+#define _IMPLICIT0CELLS_H
 
 #include <vector>
 #include <set>
 #include <map>
-#include <ext/hash_map>
+
 #include <iostream>
 #include "cellarray.h"
 #include "cell.h"
@@ -14,77 +14,128 @@
 #define BLOCKSIZ 100
 #define DIGITS 6
 
+namespace GF {
+
+class Implicit0Cells: public AbstractCellArray {
+public:
 
-class Implicit0Cells : public AbstractCellArray {
- public:
-  
-  Implicit0Cells(int s) :  materializednodes(NULL),size(s) { this->ref(); }
-  ~Implicit0Cells() { 
-     this->cleanup.clear(); 
-     if (materializednodes != NULL) {
-       delete [] materializednodes;
-     }
-  };
-  idx getsize() { return this->size; };
-
-  Cell *getCell(idx i);
-  Cell getCellCopy(idx i);
-  Node *getCellNodes(idx i) { 
-    // Calling this method effetcively destroys the benefits of the implicit array.
-    // CellArray should inherit from Implicit0Cells, or this method should be removed
-    if (materializednodes == NULL) {
-      materializednodes = new Node[this->size];
-      for (idx j=0; j<this->size; j++) {
-        materializednodes[j] = j;
-      }
-    }
-    return &materializednodes[i];
-  }
-
-  virtual int whoami() { return 0; };
-
-  bool contains(const Cell &c) { return (size > c.getnodes()[0] && (signed)c.getnodes()[0] >= 0); }; 
-  idx getOrd(const Cell &c) { Node &n = c.getnodes()[0]; return n < this->size ? n : -1; }
-  idx getOrd(Node n) { return n < this->size ? n : -1; }
-
-  void getIncidentCells(const Cell &c, set<CellId> &out); 
-  void getIncidentCells(Node n, set<CellId> &out);
-  void getAdjacentCells(CellId n, vector<CellId> &out) {(void)n;(void)out; };
-  unsigned int getNodeCount() { return size; };
-
-  void mapNodes(NormNodeMap &h); 
-  void mapNodes(UnaryNodeMap &h);
-  
-  void buildInvertedIndex() {};
-  void buildAdjacentIndex() {};
-
-  void print(size_t indent);
-  void print();
-  bool implicit() { return true; };
-  int bytes() { return 2*size*sizeof(int); };
-  
-  void unref();
-  void ref();
-
-  CellArray *asCellArray(); 
-  vector<Cell> *getCellVector();
-  void toNodeSet(set<Node> &outset);
-
-  //CellArray *nodeFilter(vector<Node> nodes);
-  CellArray *Intersection(AbstractCellArray *othercells);
-  Implicit0Cells *Intersection(Implicit0Cells *othercells);
-  AbstractCellArray *Cross(AbstractCellArray *othercells, CrossNodeMap &h);
-  Implicit0Cells *Cross(Implicit0Cells *othercells, CrossNodeMap &h);
-
-  CrossNodeMap makeCrossNodeMap(AbstractCellArray *other);
-  CrossNodeMap makeCrossNodeMap(Implicit0Cells *other);
-
-
- private:
-  vector<Cell> cleanup;
-  set<CellId> incidences;
-  Node *materializednodes;
-  unsigned int size;
+	Implicit0Cells(int s) :
+			materializednodes(NULL), size(s)
+	{
+		this->ref();
+	}
+	~Implicit0Cells()
+	{
+		this->cleanup.clear();
+		if (materializednodes != NULL) {
+			delete[] materializednodes;
+		}
+	}
+	;
+	idx getsize()
+	{
+		return this->size;
+	}
+	;
+
+	Cell *getCell(idx i);
+	Cell getCellCopy(idx i);
+	Node *getCellNodes(idx i)
+	{
+		// Calling this method effectively destroys the benefits of the implicit array.
+		// CellArray should inherit from Implicit0Cells, or this method should be removed
+		if (materializednodes == NULL) {
+			materializednodes = new Node[this->size];
+			for (idx j = 0; j < this->size; j++) {
+				materializednodes[j] = j;
+			}
+		}
+		return &materializednodes[i];
+	}
+
+	virtual int whoami()
+	{
+		return 0;
+	}
+	;
+
+	bool contains(const Cell &c)
+	{
+		return (size > c.getnodes()[0] && (signed) c.getnodes()[0] >= 0);
+	}
+	;
+	idx getOrd(const Cell &c)
+	{
+		Node &n = c.getnodes()[0];
+		return n < this->size ? n : -1;
+	}
+	idx getOrd(Node n)
+	{
+		return n < this->size ? n : -1;
+	}
+
+	void getIncidentCells(const Cell &c, set<CellId> &out);
+	void getIncidentCells(Node n, set<CellId> &out);
+	void getAdjacentCells(CellId n, vector<CellId> &out)
+	{
+		(void) n;
+		(void) out;
+	}
+	;
+	unsigned int getNodeCount()
+	{
+		return size;
+	}
+	;
+
+	void mapNodes(NormNodeMap &h);
+	void mapNodes(UnaryNodeMap &h);
+
+	void buildInvertedIndex()
+	{
+	}
+	;
+	void buildAdjacentIndex()
+	{
+	}
+	;
+
+	void print(size_t indent);
+	void print();
+	bool implicit()
+	{
+		return true;
+	}
+	;
+	int bytes()
+	{
+		return 2 * size * sizeof(int);
+	}
+	;
+
+	void unref();
+	void ref();
+
+	CellArray *asCellArray();
+	vector<Cell> *getCellVector();
+	void toNodeSet(set<Node> &outset);
+
+	//CellArray *nodeFilter(vector<Node> nodes);
+	CellArray *Intersection(AbstractCellArray *othercells);
+	Implicit0Cells *Intersection(Implicit0Cells *othercells);
+	AbstractCellArray *Cross(AbstractCellArray *othercells, CrossNodeMap &h);
+	Implicit0Cells *Cross(Implicit0Cells *othercells, CrossNodeMap &h);
+
+	CrossNodeMap makeCrossNodeMap(AbstractCellArray *other);
+	CrossNodeMap makeCrossNodeMap(Implicit0Cells *other);
+
+private:
+	vector<Cell> cleanup;
+	set<CellId> incidences;
+	Node *materializednodes;
+	unsigned int size;
 };
 
+} // namespace GF
+
 #endif /* _CELLARRAY_H */
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/implicitcrossnodemap.h gridfields/clib/src/implicitcrossnodemap.h
--- tag/gridfieldsclib-0.7/src/implicitcrossnodemap.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/implicitcrossnodemap.h	2014-05-16 22:57:00.756725199 +0200
@@ -5,38 +5,57 @@
 #include "abstractcellarray.h"
 #include "implicit0cells.h"
 
-class ImplicitCrossNodeMap : public CrossNodeMap {
+namespace GF {
 
- public: 
-  ImplicitCrossNodeMap(Implicit0Cells *An, Implicit0Cells *Bn) 
-          : CrossNodeMap(An, Bn), Anodes(An), Bnodes(Bn) { };
-  
-  inline virtual Node map(Node a, Node b) { 
-    //return Anodes->getOrd(a) * Bnodes->getsize() + Bnodes->getOrd(b) ;
-    return a * Bnodes->getsize() + b ;
-  };
-/*
-  bool sameCells(AbstractCellArray *cells) {
-    return ((*cells == *Anodes) || (*cells == *Bnodes))
-  }
-*/
-  Node inv_b(Node o, Node ) { 
-    Cell *c;
-    int i = o % Bnodes->getsize();
-    c = Bnodes->getCell(i);
-    return c->getnodes()[0];
-  };
-  
-  Node inv_a(Node o, Node ) { 
-    Cell *c;
-    int i = o / Bnodes->getsize();
-    c = Bnodes->getCell(i);
-    return c->getnodes()[0];
-  };
-  
- private:
-  Implicit0Cells *Anodes;
-  Implicit0Cells *Bnodes;
+class ImplicitCrossNodeMap: public CrossNodeMap {
+
+public:
+	ImplicitCrossNodeMap(Implicit0Cells *An, Implicit0Cells *Bn) :
+			CrossNodeMap(An, Bn), /* Unused. jhrg 4/4/14 Anodes(An),*/Bnodes(Bn)
+	{
+	}
+	;
+
+	// Added because of complaints from gcc about missing virtual dtor
+	// in a class with virtual methods. jhrg 4/4/14
+	virtual ~ImplicitCrossNodeMap()
+	{
+	}
+
+	inline virtual Node map(Node a, Node b)
+	{
+		//return Anodes->getOrd(a) * Bnodes->getsize() + Bnodes->getOrd(b) ;
+		return a * Bnodes->getsize() + b;
+	}
+	;
+	/*
+	 bool sameCells(AbstractCellArray *cells) {
+	 return ((*cells == *Anodes) || (*cells == *Bnodes))
+	 }
+	 */
+	Node inv_b(Node o, Node)
+	{
+		Cell *c;
+		int i = o % Bnodes->getsize();
+		c = Bnodes->getCell(i);
+		return c->getnodes()[0];
+	}
+	;
+
+	Node inv_a(Node o, Node)
+	{
+		Cell *c;
+		int i = o / Bnodes->getsize();
+		c = Bnodes->getCell(i);
+		return c->getnodes()[0];
+	}
+	;
+
+private:
+	// Anodes Unused. jhrg 4/4/14 Implicit0Cells *Anodes;
+	Implicit0Cells *Bnodes;
 };
 
+} // namespace GF
+
 #endif /* _CROSSNODEMAP_H */
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/leftnodemap.h gridfields/clib/src/leftnodemap.h
--- tag/gridfieldsclib-0.7/src/leftnodemap.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/leftnodemap.h	2014-05-16 22:57:00.820058531 +0200
@@ -3,15 +3,31 @@
 
 #include "binarynodemap.h"
 
-class CrossNodeMap : public BinaryNodeMap {
+namespace GF {
 
- public: 
-  LeftNodeMap() : BinaryNodeMap() { };
-  virtual Node map(Node a, Node b) { return a; };
-  Node inv_b(Node c, Node a) { assert(c==a); return a; }
-  Node inv_a(Node c, Node b) { assert(c==b); return b; }
-  
- private:
+class CrossNodeMap: public BinaryNodeMap {
+
+public:
+	LeftNodeMap() : BinaryNodeMap() {};
+	virtual Node map(Node a, Node b)
+	{
+		return a;
+	}
+	;
+	Node inv_b(Node c, Node a)
+	{
+		assert(c == a);
+		return a;
+	}
+	Node inv_a(Node c, Node b)
+	{
+		assert(c == b);
+		return b;
+	}
+
+private:
 };
 
+} // namespace GF
+
 #endif /* _LEFTNODEMAP_H */
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/merge.cc gridfields/clib/src/merge.cc
--- tag/gridfieldsclib-0.7/src/merge.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/merge.cc	2014-05-16 22:57:00.760058532 +0200
@@ -1,59 +1,69 @@
+#include "config_gridfields.h"
+
 #include "merge.h"
 #include "array.h"
 #include "timing.h"
 
+namespace GF {
 
-MergeOp::MergeOp(GridFieldOperator *left, GridFieldOperator *right) {
-  this->A = NULL;
-  this->B = NULL;
-  this->LeftOp = left;
-  this->RightOp = right;
+MergeOp::MergeOp(GridFieldOperator *left, GridFieldOperator *right)
+{
+	this->A = NULL;
+	this->B = NULL;
+	this->LeftOp = left;
+	this->RightOp = right;
 }
-    
-void MergeOp::Execute() {
-  this->PrepareForExecution();
-  Result = this->Merge(this->A, this->B);
+
+void MergeOp::Execute()
+{
+	this->PrepareForExecution();
+	Result = this->Merge(this->A, this->B);
 }
 
-GridField *MergeOp::Merge(GridField *Aa, GridField *Bb) {
+GridField *MergeOp::Merge(GridField *Aa, GridField *Bb)
+{
 
-  Grid *G;
-  GridField *Gg;
-  Grid *A = Aa->GetGrid();
-  Grid *B = Bb->GetGrid();
+	Grid *G;
+	GridField *Gg;
+	Grid *A = Aa->GetGrid();
+	Grid *B = Bb->GetGrid();
 #if 0
-  cout << "Merge(...)" << endl;
-  Aa->getAttribute("salt")->print();
-  Bb->getAttribute("sumsalt")->print();
+	cout << "Merge(...)" << endl;
+	Aa->getAttribute("salt")->print();
+	Bb->getAttribute("sumsalt")->print();
 #endif
-  string gname = newName(A->name, B->name);
+	string gname = newName(A->name, B->name);
 
-  if (A == B) {
-    Gg = new GridField(Aa);
-    for (Dim_t k=0; k<=Aa->Dim(); k++) {
-      Scheme sch = Bb->GetScheme(k);
-      for (unsigned int i=0; i<Bb->Arity(k); i++) {
-        Gg->Bind(k, Bb->GetAttribute(k, sch.getAttribute(i)));
-      }
-    }
-  } else {
-     
-    G = A->Intersection(B);
-
-    Gg = new GridField(G);
-
-    if (G->empty()) return Gg;
- 
-    Gg->RestrictAll(*Aa);
-    Gg->RestrictAll(*Bb);
+	if (A == B) {
+		Gg = new GridField(Aa);
+		for (Dim_t k = 0; k <= Aa->Dim(); k++) {
+			Scheme sch = Bb->GetScheme(k);
+			for (unsigned int i = 0; i < Bb->Arity(k); i++) {
+				Gg->Bind(k, Bb->GetAttribute(k, sch.getAttribute(i)));
+			}
+		}
+	}
+	else {
+
+		G = A->Intersection(B);
+
+		Gg = new GridField(G);
 
-  }
-  return Gg;
-}
+		if (G->empty()) return Gg;
 
+		Gg->RestrictAll(*Aa);
+		Gg->RestrictAll(*Bb);
 
-string MergeOp::newName(string Aname, string Bname) {
+	}
+	return Gg;
+}
 
-  string gname = "m(" + Aname + ", " + Bname + ")";
-  return gname;
+string MergeOp::newName(string Aname, string Bname)
+{
+
+	string gname = "m(" + Aname + ", " + Bname + ")";
+	return gname;
 }
+
+} // namespace GF
+
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/merge.h gridfields/clib/src/merge.h
--- tag/gridfieldsclib-0.7/src/merge.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/merge.h	2014-05-16 22:57:00.760058532 +0200
@@ -2,13 +2,16 @@
 #include "gridfield.h"
 #include "gridfieldoperator.h"
 
-class MergeOp : public BinaryGridFieldOperator {
- public:
-  MergeOp(GridFieldOperator *left, GridFieldOperator *right);
-  void Execute(); 
-  static GridField *Merge(GridField *A, GridField *B);
- private:
-  static string newName(string Aname, string Bname);
+namespace GF {
+
+class MergeOp: public BinaryGridFieldOperator {
+public:
+	MergeOp(GridFieldOperator *left, GridFieldOperator *right);
+	void Execute();
+	static GridField *Merge(GridField *A, GridField *B);
+private:
+	static string newName(string Aname, string Bname);
 
 };
 
+} // namespace GF
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/netcdfadaptor.cc gridfields/clib/src/netcdfadaptor.cc
--- tag/gridfieldsclib-0.7/src/netcdfadaptor.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/netcdfadaptor.cc	2014-05-16 22:57:00.830058531 +0200
@@ -1,286 +1,315 @@
+#include "config_gridfields.h"
+
 #include "netcdfadaptor.h"
 #include "util.h"
 #include "cellarray.h"
 #include "array.h"
 using namespace std;
 
-Type NetCDFAdaptor::mapType(NcType t) {Type nty=INT;
-  switch (t) {
-    case ncFloat:
-      nty= FLOAT;
-    case ncInt:
-      nty= INT;
-    default:
-      cout<<t<<endl;
-      Fatal("Only ncFloat and ncInt are supported.");
-      break;
-      exit(1);
-      nty=INT;
-  }
-return nty;
-}
-
-NcType NetCDFAdaptor::mapType(Type t) {NcType nty=ncInt;
-  switch (t) {
-    case FLOAT:
-      nty= ncFloat;
-      break;
-    case INT:
-      nty= ncInt;
-      break;
-    default:
-      Fatal("Unknown Type encountered during netCDF emission");
-      break;
-      exit(1);
-      nty= ncInt;
-  }
-return nty;
-}
-
-bool NetCDFAdaptor::HasVar(NcFile *ncdf, const string varname) {
-  for (int i=0; i<ncdf->num_vars(); i++) {
-    NcVar *var = ncdf->get_var(i);
-    if (string(var->name()) == varname) {
-      return 1;
-    }
-  }
-  return 0;
-}
-
-bool NetCDFAdaptor::HasDim(NcFile *ncdf, const string dimname) {
-  NcDim *nodedim;
-  int i=0;
-  DEBUG << "_" << endl;
-  for (; i<ncdf->num_dims(); i++) {
-    nodedim = ncdf->get_dim(i);
-    DEBUG << "|" << nodedim->name() << endl;
-    if (string(nodedim->name()) == dimname) break;
-  }
-  if (i==ncdf->num_dims()) {
-    return 0;
-  } else {
-    return 1;
-  }
-}
-
-bool NetCDFAdaptor::HasAttr(NcFile *ncdf, const string attr) {
-  DEBUG << "Has attr " << attr << "? ";
-  for (int i=0; i<ncdf->num_atts(); i++) {
-    NcAtt *a = ncdf->get_att(i);
-    if (string(a->name()) == (attr)) {
-      DEBUG << "yes" << endl;
-      return 1;
-    }
-  }
-  DEBUG << "no" << endl;
-  return 0;
-}
-
-void NetCDFAdaptor::Open(string mode) {
-  this->Close();
-  const char *fn = filename.c_str();
-  NcFile::FileMode m=NcFile::Replace;
-  if (mode == "r") {
-    m = NcFile::ReadOnly;
-  } else if (mode == "w+") {
-    m = NcFile::Write;
-  } else if (mode == "w") {
-    m = NcFile::Replace;
-  } else {
-    Fatal("Unknown file mode %s", mode.c_str());
-    exit(1);
-  }
-  ncdf = new NcFile(fn, m);
-  if (!ncdf->is_valid()) {
-    Fatal("Error opening netcdf file");
-  }
-}
-
-void NetCDFAdaptor::Close() {
-  if (ncdf!=NULL) {
-    delete ncdf;
-    ncdf = NULL;
-  } 
-}
-
-void NetCDFAdaptor::NodesFromDim(string ncdim, Grid *G) {
-   NcDim *ncd = ncdf->get_dim(ncdim.c_str());
-   G->setImplicit0Cells(ncd->size());
+namespace GF {
+
+Type NetCDFAdaptor::mapType(NcType t)
+{
+	Type nty = INT;
+	switch (t) {
+	case ncFloat:
+		nty = FLOAT;
+	case ncInt:
+		nty = INT;
+	default:
+		cout << t << endl;
+		Fatal("Only ncFloat and ncInt are supported.");
+		break;
+		exit(1);
+		nty = INT;
+	}
+	return nty;
+}
+
+NcType NetCDFAdaptor::mapType(Type t)
+{
+	NcType nty = ncInt;
+	switch (t) {
+	case FLOAT:
+		nty = ncFloat;
+		break;
+	case INT:
+		nty = ncInt;
+		break;
+	default:
+		Fatal("Unknown Type encountered during netCDF emission");
+		break;
+		exit(1);
+		nty = ncInt;
+	}
+	return nty;
+}
+
+bool NetCDFAdaptor::HasVar(NcFile *ncdf, const string varname)
+{
+	for (int i = 0; i < ncdf->num_vars(); i++) {
+		NcVar *var = ncdf->get_var(i);
+		if (string(var->name()) == varname) {
+			return 1;
+		}
+	}
+	return 0;
+}
+
+bool NetCDFAdaptor::HasDim(NcFile *ncdf, const string dimname)
+{
+	NcDim *nodedim;
+	int i = 0;
+	DEBUG << "_" << endl;
+	for (; i < ncdf->num_dims(); i++) {
+		nodedim = ncdf->get_dim(i);
+		DEBUG << "|" << nodedim->name() << endl;
+		if (string(nodedim->name()) == dimname) break;
+	}
+	if (i == ncdf->num_dims()) {
+		return 0;
+	}
+	else {
+		return 1;
+	}
+}
+
+bool NetCDFAdaptor::HasAttr(NcFile *ncdf, const string attr)
+{
+	DEBUG << "Has attr " << attr << "? ";
+	for (int i = 0; i < ncdf->num_atts(); i++) {
+		NcAtt *a = ncdf->get_att(i);
+		if (string(a->name()) == (attr)) {
+			DEBUG << "yes" << endl;
+			return 1;
+		}
+	}
+	DEBUG << "no" << endl;
+	return 0;
+}
+
+void NetCDFAdaptor::Open(string mode)
+{
+	this->Close();
+	const char *fn = filename.c_str();
+	NcFile::FileMode m = NcFile::Replace;
+	if (mode == "r") {
+		m = NcFile::ReadOnly;
+	}
+	else if (mode == "w+") {
+		m = NcFile::Write;
+	}
+	else if (mode == "w") {
+		m = NcFile::Replace;
+	}
+	else {
+		Fatal("Unknown file mode %s", mode.c_str());
+		exit(1);
+	}
+	ncdf = new NcFile(fn, m);
+	if (!ncdf->is_valid()) {
+		Fatal("Error opening netcdf file");
+	}
+}
+
+void NetCDFAdaptor::Close()
+{
+	if (ncdf != NULL) {
+		delete ncdf;
+		ncdf = NULL;
+	}
+}
+
+void NetCDFAdaptor::NodesFromDim(string ncdim, Grid *G)
+{
+	NcDim *ncd = ncdf->get_dim(ncdim.c_str());
+	G->setImplicit0Cells(ncd->size());
 }
 
-// Read two arrays from the file one relating (cells and nodes), and the other 
-// relating (cells and edges) 
+// Read two arrays from the file one relating (cells and nodes), and the other
+// relating (cells and edges)
 // Use the information to construct 2-cells and 1-cells
-void NetCDFAdaptor::WellSupportedPolygonsFromVars(string cellnode, string celledge, Grid *G) {
-   NcVar *nccellnode = ncdf->get_var(cellnode.c_str());
-   if (nccellnode->num_dims() != 2) {
-     Fatal("To build cells from a netcdf variable, the variable must have two dimensions (number_of_cells, cell_count)");
-   }
-   NcVar *nccelledge = ncdf->get_var(celledge.c_str());
-   if (nccelledge->num_dims() != 2) {
-     Fatal("To build cells from a netcdf variable, the variable must have two dimensions (number_of_cells, cell_count)");
-   }
-
-   // Polygons have the same number of nodes and edges
-   NcDim *ncells = nccellnode->get_dim(0);
-   if (ncells == NULL) {
-     Fatal("Error retrieving number of cells");
-   }
-
-   // Polygons have the same number of nodes and edges
-   NcDim *nnodes = nccellnode->get_dim(1);
-   if (nnodes == NULL) {
-     Fatal("Error retrieving number of nodes per cell");
-   }
-
-   CellArray *twocells = new CellArray();
-   CellArray *onecells = new CellArray();
-
-   map<int, Cell> edgemap;
-
-   Node *nodes = new Node[nnodes->size()+1];
-   Node *edges = new Node[nnodes->size()];
-   Cell edge(2);
-   for (unsigned int i=0; i<(unsigned)ncells->size(); i++) {
-     // add the cell
-     nccellnode->get((int *) nodes, 1, nnodes->size());
-
-     // complete the cycle: set last + 1 = first
-     nodes[nnodes->size()] = nodes[0];
-
-     // add the 2-cell as a list of nodes
-     twocells->addCellNodes(nodes, nnodes->size());
-
-     // gather the edges
-     nccelledge->get((int *) edges, 1, nnodes->size());
-     for (unsigned int j=0; j<(unsigned)nnodes->size(); j++) {
-       // set the nodes array of the placeholder edge
-       edge.setnodes(nodes+j);
-       // insert the edge into the map
-       //cout << edges[j] << ": " << edge.getnodes()[0] << ", " << edge.getnodes()[1]  << endl;
-       edgemap[edges[j]] = edge;
-     }
-     // set the iterators
-     nccellnode->set_cur(i+1,0);
-     nccelledge->set_cur(i+1,0);
-   }
- 
-   // insert the edges in sorted order
-   for (unsigned int i=0; i<edgemap.size(); i++) {
-     onecells->addCell(edgemap[i]);
-   }
-
-   twocells->cleanup_node_array = true;
-   onecells->cleanup_node_array = true;
-   // assumes contiguous nodes 
-   // assumes cells span nodes
-   G->setKCells(twocells, 2);
-   G->setKCells(onecells, 1);
-   delete nodes;
-   delete edges;
-}
-
-void NetCDFAdaptor::HomogeneousCellsFromVar(Dim_t d, string ncvar, Grid *G) {
-   NcVar *ncv = ncdf->get_var(ncvar.c_str());
-   if (ncv->num_dims() != 2) {
-     Fatal("To build cells from a netcdf variable, the variable must have two dimensions (number_of_cells, cell_count");
-   }
-
-   NcDim *d0 = ncv->get_dim(0);
-   if (d0 == NULL) {
-     Fatal("Error retrieving first dimension");
-   }
- 
-   NcDim *d1 = ncv->get_dim(1);
-   if (d1 == NULL) {
-     Fatal("Error retrieving second dimension");
-   }
-  
-   CellArray *cells = new CellArray();
-   Node *nodes = new Node[d1->size()];
-   for (unsigned int i=0; i<(unsigned)d0->size(); i++) {
-     ncv->get((int *) nodes, 1, d1->size());
-     cells->addCellNodes(nodes, d1->size());
-     ncv->set_cur(i+1,0);
-   } 
-   cells->cleanup_node_array = true;
-   // assumes contiguous nodes 
-   // assumes cells span nodes
-   G->setKCells(cells, d);
-   delete nodes;
-}
-
-void NetCDFAdaptor::AttributeFromVar(Dim_t d, string ncvar, GridField *G) {
-  NcVar *ncv = ncdf->get_var(ncvar.c_str());
-  if (ncv == NULL) {
-    Fatal("Error reading variable %s", ncvar.c_str());
-  }
-
-  Array *arr = new Array(ncv->name(), mapType(ncv->type()));
-  arr->setVals((UnTypedPtr) ncv->values()->base(), ncv->num_vals());
-
-  G->Bind(d, arr);
-}
-
-
-void NetCDFAdaptor::CreateDim(const string &name, unsigned int size) {
-  this->ncdf->add_dim(name.c_str(), size);
-}
-
-void NetCDFAdaptor::DimFromDim(const string &name, GridField *gf, Dim_t d) {
-  this->ncdf->add_dim(name.c_str(), gf->Card(d));
-}
-
-void NetCDFAdaptor::VarFromAttribute(const string &name, GridField *gf, Dim_t d, const vector<string> &dims) {
-  const NcDim** ncdims = new const NcDim*[dims.size()];
-  for (unsigned int i=0; i<dims.size(); i++) {
-    ncdims[i] = ncdf->get_dim(dims[i].c_str());
-  }
-  Array *arr = gf->GetAttribute(d, name);
-  NcVar *var = ncdf->add_var(name.c_str(), mapType(arr->gettype()), dims.size(),ncdims);
-  switch (arr->gettype()) {
-    case INT:
-      var->put((int *) arr->getVals(), var->edges());
-      break;
-    case FLOAT:
-      var->put((float *) arr->getVals(),var->edges());
-      break;
-    case OBJ:
-      Fatal("Only floats and ints currently supported.");
-      break;
-    case TUPLE:
-      Fatal("Only floats and ints currently supported.");
-      break;
-    case GRIDFIELD:
-      Fatal("Only floats and ints currently supported.");
-      break;
-  }
-  delete [] ncdims;
-}
-
-void NetCDFAdaptor::VarFromIncidence(const string &name, GridField *gf, Dim_t c, Dim_t d, string dim1, string dim2) {
-  NcDim *d1 = ncdf->get_dim(dim1.c_str());
-  NcDim *d2 = ncdf->get_dim(dim2.c_str());
-  NcVar *var = ncdf->add_var(name.c_str(), ncInt, d1, d2);
-
-  unsigned int cols = d2->size();
-
-  int *ids = new int[var->num_vals()];
-
-  Grid *G = gf->GetGrid();
-  vector<CellId> out;
-  //_OutputIterator<CellId> out;
-  for (unsigned int i=0; i<gf->Card(c); i++) {
-    //out = (OutputIterator<CellId>) &ids[i*col];
-    G->IncidentTo(i, c, out, d);
-    for (unsigned int j=0; j<out.size(); j++) {
-      // Output CellIds not Cells.  "Automatic" normalization.
-      ids[i*cols + j] = out[j];
-    }
-    out.clear();
-  }
-
+void NetCDFAdaptor::WellSupportedPolygonsFromVars(string cellnode, string celledge, Grid *G)
+{
+	NcVar *nccellnode = ncdf->get_var(cellnode.c_str());
+	if (nccellnode->num_dims() != 2) {
+		Fatal(
+				"To build cells from a netcdf variable, the variable must have two dimensions (number_of_cells, cell_count)");
+	}
+	NcVar *nccelledge = ncdf->get_var(celledge.c_str());
+	if (nccelledge->num_dims() != 2) {
+		Fatal(
+				"To build cells from a netcdf variable, the variable must have two dimensions (number_of_cells, cell_count)");
+	}
+
+	// Polygons have the same number of nodes and edges
+	NcDim *ncells = nccellnode->get_dim(0);
+	if (ncells == NULL) {
+		Fatal("Error retrieving number of cells");
+	}
+
+	// Polygons have the same number of nodes and edges
+	NcDim *nnodes = nccellnode->get_dim(1);
+	if (nnodes == NULL) {
+		Fatal("Error retrieving number of nodes per cell");
+	}
+
+	CellArray *twocells = new CellArray();
+	CellArray *onecells = new CellArray();
+
+	map<int, Cell> edgemap;
+
+	Node *nodes = new Node[nnodes->size() + 1];
+	Node *edges = new Node[nnodes->size()];
+	Cell edge(2);
+	for (unsigned int i = 0; i < (unsigned) ncells->size(); i++) {
+		// add the cell
+		nccellnode->get((int *) nodes, 1, nnodes->size());
+
+		// complete the cycle: set last + 1 = first
+		nodes[nnodes->size()] = nodes[0];
+
+		// add the 2-cell as a list of nodes
+		twocells->addCellNodes(nodes, nnodes->size());
+
+		// gather the edges
+		nccelledge->get((int *) edges, 1, nnodes->size());
+		for (unsigned int j = 0; j < (unsigned) nnodes->size(); j++) {
+			// set the nodes array of the placeholder edge
+			edge.setnodes(nodes + j);
+			// insert the edge into the map
+			//cout << edges[j] << ": " << edge.getnodes()[0] << ", " << edge.getnodes()[1]  << endl;
+			edgemap[edges[j]] = edge;
+		}
+		// set the iterators
+		nccellnode->set_cur(i + 1, 0);
+		nccelledge->set_cur(i + 1, 0);
+	}
+
+	// insert the edges in sorted order
+	for (unsigned int i = 0; i < edgemap.size(); i++) {
+		onecells->addCell(edgemap[i]);
+	}
+
+	twocells->cleanup_node_array = true;
+	onecells->cleanup_node_array = true;
+	// assumes contiguous nodes
+	// assumes cells span nodes
+	G->setKCells(twocells, 2);
+	G->setKCells(onecells, 1);
+	delete nodes;
+	delete edges;
+}
+
+void NetCDFAdaptor::HomogeneousCellsFromVar(Dim_t d, string ncvar, Grid *G)
+{
+	NcVar *ncv = ncdf->get_var(ncvar.c_str());
+	if (ncv->num_dims() != 2) {
+		Fatal(
+				"To build cells from a netcdf variable, the variable must have two dimensions (number_of_cells, cell_count");
+	}
+
+	NcDim *d0 = ncv->get_dim(0);
+	if (d0 == NULL) {
+		Fatal("Error retrieving first dimension");
+	}
+
+	NcDim *d1 = ncv->get_dim(1);
+	if (d1 == NULL) {
+		Fatal("Error retrieving second dimension");
+	}
+
+	CellArray *cells = new CellArray();
+	Node *nodes = new Node[d1->size()];
+	for (unsigned int i = 0; i < (unsigned) d0->size(); i++) {
+		ncv->get((int *) nodes, 1, d1->size());
+		cells->addCellNodes(nodes, d1->size());
+		ncv->set_cur(i + 1, 0);
+	}
+	cells->cleanup_node_array = true;
+	// assumes contiguous nodes
+	// assumes cells span nodes
+	G->setKCells(cells, d);
+	delete nodes;
+}
+
+void NetCDFAdaptor::AttributeFromVar(Dim_t d, string ncvar, GridField *G)
+{
+	NcVar *ncv = ncdf->get_var(ncvar.c_str());
+	if (ncv == NULL) {
+		Fatal("Error reading variable %s", ncvar.c_str());
+	}
+
+	Array *arr = new Array(ncv->name(), mapType(ncv->type()));
+	arr->setVals((UnTypedPtr) ncv->values()->base(), ncv->num_vals());
+
+	G->Bind(d, arr);
+}
+
+void NetCDFAdaptor::CreateDim(const string &name, unsigned int size)
+{
+	this->ncdf->add_dim(name.c_str(), size);
+}
+
+void NetCDFAdaptor::DimFromDim(const string &name, GridField *gf, Dim_t d)
+{
+	this->ncdf->add_dim(name.c_str(), gf->Card(d));
+}
+
+void NetCDFAdaptor::VarFromAttribute(const string &name, GridField *gf, Dim_t d, const vector<string> &dims)
+{
+	const NcDim** ncdims = new const NcDim*[dims.size()];
+	for (unsigned int i = 0; i < dims.size(); i++) {
+		ncdims[i] = ncdf->get_dim(dims[i].c_str());
+	}
+	Array *arr = gf->GetAttribute(d, name);
+	NcVar *var = ncdf->add_var(name.c_str(), mapType(arr->gettype()), dims.size(), ncdims);
+	switch (arr->gettype()) {
+	case INT:
+		var->put((int *) arr->getVals(), var->edges());
+		break;
+	case FLOAT:
+		var->put((float *) arr->getVals(), var->edges());
+		break;
+	case OBJ:
+		Fatal("Only floats and ints currently supported.");
+		break;
+	case TUPLE:
+		Fatal("Only floats and ints currently supported.");
+		break;
+	case GRIDFIELD:
+		Fatal("Only floats and ints currently supported.");
+		break;
+	}
+	delete[] ncdims;
+}
+
+void NetCDFAdaptor::VarFromIncidence(const string &name, GridField *gf, Dim_t c, Dim_t d, string dim1, string dim2)
+{
+	NcDim *d1 = ncdf->get_dim(dim1.c_str());
+	NcDim *d2 = ncdf->get_dim(dim2.c_str());
+	NcVar *var = ncdf->add_var(name.c_str(), ncInt, d1, d2);
+
+	unsigned int cols = d2->size();
+
+	int *ids = new int[var->num_vals()];
+
+	Grid *G = gf->GetGrid();
+	vector<CellId> out;
+	//_OutputIterator<CellId> out;
+	for (unsigned int i = 0; i < gf->Card(c); i++) {
+		//out = (OutputIterator<CellId>) &ids[i*col];
+		G->IncidentTo(i, c, out, d);
+		for (unsigned int j = 0; j < out.size(); j++) {
+			// Output CellIds not Cells.  "Automatic" normalization.
+			ids[i * cols + j] = out[j];
+		}
+		out.clear();
+	}
 
-  var->put(ids, var->edges());
-  delete [] ids;
+	var->put(ids, var->edges());
+	delete[] ids;
 }
+
+} // namespace GF
+
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/netcdfadaptor.h gridfields/clib/src/netcdfadaptor.h
--- tag/gridfieldsclib-0.7/src/netcdfadaptor.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/netcdfadaptor.h	2014-05-16 22:57:00.746725199 +0200
@@ -9,36 +9,57 @@
 #include <string>
 #include <vector>
 
+namespace GF {
+
 class NetCDFAdaptor {
 public:
-  NetCDFAdaptor(string fn) : filename(fn), ncdf(NULL) {};
-  NetCDFAdaptor(const char *fn) : filename(fn), ncdf(NULL) {};
-  void Open(string mode = "r"); 
-  void Close(); 
-  void setFileName(char *fn) { filename = string(fn); };
-  void setFileName(string fn) { filename = string(fn); };
-
-  // Read functions
-  void NodesFromDim(string ncdim, Grid *G);
-  void WellSupportedPolygonsFromVars(string cnodes, string cedges, Grid *G);
-  void HomogeneousCellsFromVar(Dim_t d, string ncvar, Grid *G);
-  void AttributeFromVar(Dim_t d, string ncvar, GridField *G);
-
-  // Write functions
-  void CreateDim(const string &name, unsigned int size);
-  void DimFromDim(const string &name, GridField *gf, Dim_t d);
-  void VarFromAttribute(const string &name, GridField *gf, Dim_t d, const vector<string> &dims);
-  void VarFromIncidence(const string &name, GridField *gf, Dim_t c, Dim_t d, string d1, string d2);
-
-  // Utility netcdf functions
-  static NcType mapType(Type t);
-  static Type mapType(NcType t);
-  static bool HasDim(NcFile *ncdf, const string dimname);
-  static bool HasVar(NcFile *ncdf, const string varname);
-  static bool HasAttr(NcFile *ncdf, const string attr);
+	NetCDFAdaptor(string fn) :
+			filename(fn), ncdf(NULL)
+	{
+	}
+	;
+	NetCDFAdaptor(const char *fn) :
+			filename(fn), ncdf(NULL)
+	{
+	}
+	;
+	void Open(string mode = "r");
+	void Close();
+	void setFileName(char *fn)
+	{
+		filename = string(fn);
+	}
+	;
+	void setFileName(string fn)
+	{
+		filename = string(fn);
+	}
+	;
+
+	// Read functions
+	void NodesFromDim(string ncdim, Grid *G);
+	void WellSupportedPolygonsFromVars(string cnodes, string cedges, Grid *G);
+	void HomogeneousCellsFromVar(Dim_t d, string ncvar, Grid *G);
+	void AttributeFromVar(Dim_t d, string ncvar, GridField *G);
+
+	// Write functions
+	void CreateDim(const string &name, unsigned int size);
+	void DimFromDim(const string &name, GridField *gf, Dim_t d);
+	void VarFromAttribute(const string &name, GridField *gf, Dim_t d, const vector<string> &dims);
+	void VarFromIncidence(const string &name, GridField *gf, Dim_t c, Dim_t d, string d1, string d2);
+
+	// Utility netcdf functions
+	static NcType mapType(Type t);
+	static Type mapType(NcType t);
+	static bool HasDim(NcFile *ncdf, const string dimname);
+	static bool HasVar(NcFile *ncdf, const string varname);
+	static bool HasAttr(NcFile *ncdf, const string attr);
 
 private:
-  string filename;
-  NcFile *ncdf;
+	string filename;
+	NcFile *ncdf;
 };
+
+} // namespace GF
+
 #endif
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/nodemap.h gridfields/clib/src/nodemap.h
--- tag/gridfieldsclib-0.7/src/nodemap.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/nodemap.h	2014-05-16 22:57:00.806725198 +0200
@@ -3,10 +3,14 @@
 
 #include "type.h"
 
+namespace GF {
+
 class NodeMap {
 
- public:
- private:
+public:
+private:
 };
 
+} // namespace GF
+
 #endif /* _NODEMAP_H */
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/normnodemap.h gridfields/clib/src/normnodemap.h
--- tag/gridfieldsclib-0.7/src/normnodemap.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/normnodemap.h	2014-05-16 22:57:00.803391865 +0200
@@ -1,39 +1,65 @@
 #ifndef _NORMNODEMAP_H
 #define _NORMNODEMAP_H
 
+#if 0
+#ifdef HAVE_UNORDERED_MAP
+#include <unordered_map>
+#define HASH_MAP std::unordered_map
+#else
+#include <ext/hash_map>
+#define HASH_MAP hash_map
+#endif
+#endif
+
 #include "unarynodemap.h"
 #include "cellarray.h"
 #include "assert.h"
 
-class NormNodeMap : public UnaryNodeMap {
+namespace GF {
+
+class NormNodeMap: public UnaryNodeMap {
+
+public:
+	NormNodeMap(AbstractCellArray *zcs) :
+			UnaryNodeMap()
+	{
+		zerocells = zcs;
+		Cell *c;
+		int x;
+		// jhrg 2/13/14
+#ifdef USE_HASH_MAP_RESIZE
+		nodemap.resize(zerocells->getsize());
+#else
+		nodemap.rehash(zerocells->getsize());
+#endif
+		for (unsigned int i = 0; i < zerocells->getsize(); i++) {
+			c = zerocells->getCell(i);
+			x = c->getnodes()[0];
+			nodemap[x] = i;
+		}
+	}
+	;
+	virtual Node map(Node x)
+	{
+		return nodemap[x];
+	}
+	;
 
- public: 
-  NormNodeMap(AbstractCellArray *zcs) : UnaryNodeMap() { 
-    zerocells = zcs;
-    Cell *c;
-    int x;
-    nodemap.resize(zerocells->getsize());
-    for (unsigned int i=0; i<zerocells->getsize(); i++) {
-      c = zerocells->getCell(i);
-      x = c->getnodes()[0];
-      nodemap[x] = i;
-    }
-  };
-  virtual Node map(Node x) {
-    return nodemap[x];
-  };
-  
-  Node inv(Node o) { 
-    Cell *c;
-    c = zerocells->getCell(o);
-    assert(c->getsize() == 1);
-    return c->getnodes()[0];
-  };
-  
- private:
-  hash_map<int, int> nodemap;
-  //std::map<int, int> nodemap;
-  AbstractCellArray *zerocells;
+	Node inv(Node o)
+	{
+		Cell *c;
+		c = zerocells->getCell(o);
+		assert(c->getsize() == 1);
+		return c->getnodes()[0];
+	}
+	;
+
+private:
+	HASH_MAP<int, int> nodemap;
+	//std::map<int, int> nodemap;
+	AbstractCellArray *zerocells;
 };
 
+} // namespace GF
+
 #endif /* _CROSSNODEMAP_H */
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/object.h gridfields/clib/src/object.h
--- tag/gridfieldsclib-0.7/src/object.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/object.h	2014-05-16 22:57:00.796725198 +0200
@@ -1,51 +1,65 @@
 #ifndef OBJECT_H
 #define OBJECT_H
 
+namespace GF {
+
 // manual reference counting for shared objects
 // We can replace this with a smart pointer implementation at some point.
 class Object {
-  public:
-    Object() : refcount(0) {};
-    /*
-    void *operator new(size_t sz) { 
-
-      cout << "obj::new" << endl;
-      return malloc(sz); 
-    };
-    void operator delete(void *mem) { 
-      cout << "obj::delete" << endl;
-      Object *o = ((Object *) mem);
-      o->unref(); 
-      if (o->norefs()) free(mem);
-    };
-    */
-    void ref() {
-      refcount++;
-    };
-    
-    bool norefs() { return (refcount == 0); }
-    
-    /*
-    void unref() { 
-      refcount--; 
-      cout << "obj::unref" << endl; 
-      if (refcount == 0) delete this;
-    };
-    */
-    void unref() { 
-      refcount--; 
-    };
-    
-    //with a virtual destructor, I should be able
-    //to use delete this in unref above and have
-    //the correct destructor called.
-    //SWIG, however, seems to want a destructor for Object
-    
-    //virtual ~Object()=0;
+public:
+	Object() :
+			refcount(0)
+	{
+	}
+	;
+	/*
+	 void *operator new(size_t sz) {
+
+	 cout << "obj::new" << endl;
+	 return malloc(sz);
+	 };
+	 void operator delete(void *mem) {
+	 cout << "obj::delete" << endl;
+	 Object *o = ((Object *) mem);
+	 o->unref();
+	 if (o->norefs()) free(mem);
+	 };
+	 */
+	void ref()
+	{
+		refcount++;
+	}
+	;
+
+	bool norefs()
+	{
+		return (refcount == 0);
+	}
+
+	/*
+	 void unref() {
+	 refcount--;
+	 cout << "obj::unref" << endl;
+	 if (refcount == 0) delete this;
+	 };
+	 */
+	void unref()
+	{
+		refcount--;
+	}
+	;
+
+	//with a virtual destructor, I should be able
+	//to use delete this in unref above and have
+	//the correct destructor called.
+	//SWIG, however, seems to want a destructor for Object
+
+	//virtual ~Object()=0;
 
-    int refcount;
-  protected:
+	int refcount;
+protected:
 };
 
+} // namespace GF
 
 #endif
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/onegrid.h gridfields/clib/src/onegrid.h
--- tag/gridfieldsclib-0.7/src/onegrid.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/onegrid.h	2014-05-16 22:57:00.836725197 +0200
@@ -8,31 +8,41 @@
  *
  */
 
-class OneGrid : public Grid {
+namespace GF {
 
- public:
+class OneGrid: public Grid {
 
-  OneGrid(string name, int size) : Grid(name) {
-    setImplicit0Cells(size);
-    CellArray *onecells = new CellArray;
-    Node nodes[2];
-    for (int i=1; i<size; i++) {
-      nodes[0] = i-1;
-      nodes[1] = i;
-      onecells->addCellNodes(nodes, 2);
-    }
-    setKCells(onecells, 1);
-    this->ref();
-  };
+public:
 
-};
+	OneGrid(string name, int size) :
+			Grid(name)
+	{
+		setImplicit0Cells(size);
+		CellArray *onecells = new CellArray;
+		Node nodes[2];
+		for (int i = 1; i < size; i++) {
+			nodes[0] = i - 1;
+			nodes[1] = i;
+			onecells->addCellNodes(nodes, 2);
+		}
+		setKCells(onecells, 1);
+		this->ref();
+	}
+	;
 
+};
 
-class ZeroGrid : public Grid {
-  public:
-    ZeroGrid(string name, unsigned int size) : Grid(name, 0) {
-      setImplicit0Cells(size);
-      this->ref();
-    };
+class ZeroGrid: public Grid {
+public:
+	ZeroGrid(string name, unsigned int size) :
+			Grid(name, 0)
+	{
+		setImplicit0Cells(size);
+		this->ref();
+	}
+	;
 };
+
+} // namespace GF
+
 #endif /*  _ONEGRID_H   */
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/ordmap.h gridfields/clib/src/ordmap.h
--- tag/gridfieldsclib-0.7/src/ordmap.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/ordmap.h	2014-05-16 22:57:00.806725198 +0200
@@ -1,15 +1,22 @@
 #ifndef _ORDMAP_H
 #define _ORDMAP_H
 
+namespace GF {
+
 class Cell;
 
 class OrdMap {
 
- public:
-  //virtual ~OrdMap()=0;
-  virtual int getBaseSize(int d) = 0;
-  virtual int getBaseOrd(Cell *c, int d) = 0;
- private:
+public:
+	//virtual ~OrdMap()=0;
+	virtual ~OrdMap()
+	{
+	} // The class needs a dtor since it has virtual methods. jhrg 4/4/14
+	virtual int getBaseSize(int d) = 0;
+	virtual int getBaseOrd(Cell *c, int d) = 0;
+private:
 };
 
+} // namespace GF
+
 #endif /* _ORDMAP_H */
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/output.cc gridfields/clib/src/output.cc
--- tag/gridfieldsclib-0.7/src/output.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/output.cc	2014-05-16 22:57:00.820058531 +0200
@@ -1,8 +1,11 @@
+#include "config_gridfields.h"
+
 #include "gridfield.h"
-extern "C" {
-#include "stdio.h"
+#include <stdio.h>
+//extern "C" {
+// #include "stdio.h"
 #include "elio.h"
-}
+//}
 #include "expr.h"
 #include "timing.h"
 #include <iostream>
@@ -18,249 +21,260 @@
 
 using namespace std;
 
-OutputOp::OutputOp(string fn, GridFieldOperator *op)  
- : UnaryGridFieldOperator(op), offset(0), filename(fn) {
-   GF = NULL;
-   //cleanup = false;
-}
-
-OutputOp::OutputOp(string fn, long off, GridFieldOperator *op)  
- : UnaryGridFieldOperator(op), offset(off), filename(fn) {
-   //cleanup = false;
-   GF = NULL;
-}
-
+namespace GF {
 
-void OutputOp::Execute() {
-  this->PrepareForExecution();
-  this->Output(this->GF, this->filename, this->offset);
-  this->Result = this->GF;
+OutputOp::OutputOp(string fn, GridFieldOperator *op) :
+		UnaryGridFieldOperator(op), offset(0), filename(fn)
+{
+	GF = NULL;
+	//cleanup = false;
+}
+
+OutputOp::OutputOp(string fn, long off, GridFieldOperator *op) :
+		UnaryGridFieldOperator(op), offset(off), filename(fn)
+{
+	//cleanup = false;
+	GF = NULL;
+}
+
+void OutputOp::Execute()
+{
+	this->PrepareForExecution();
+	this->Output(this->GF, this->filename, this->offset);
+	this->Result = this->GF;
 }
 /*
-void OutputOp::WriteNetCDF(vector<GridField *> &dims, GridField *cross) {
+ void OutputOp::WriteNetCDF(vector<GridField *> &dims, GridField *cross) {
 
-   vector<GridField *>::iterator p;
-   
-   NcFile *ncdf = new NcFile("./test.cdf", NcFile::Replace); 
-   
-   //put the dims
-   NcDim *d[dims.size()];
-   long counts[dims.size()];
-   int expectedcard = 1;
-   GridField *gf;
-   string attr;
-   
-   for (int i=0; i<dims.size(); i++) {
-      gf = dims[i];
-      attr = gf->getScheme()->getAttribute(0);
-      counts[i] = gf->card();
-      expectedcard *= gf->card();
-      d[i] = ncdf->add_dim(gf->getAttribute(attr.c_str())->name, gf->card());
-   }
-   
-   //put the dim variables
-   NcVar *var;
-   Array *a;
-   Scheme *sch;
-   NcType t;
-   long size;
-   for (int i=0; i<dims.size(); i++) {
-     gf = dims[i];
-     sch = gf->getScheme();
-     for (int j=0; j<gf->getarity(); j++) {
-       attr = sch->getAttribute(j);
-       cout << "(i,j)=" << i << ", " << j << " attr: " << attr << endl;
-       a = gf->getAttribute(attr.c_str());
-       size = (long) a->size;
-       OutputOp::putData(a, ncdf, &size, &(d[i]), 1); 
-     }
-   }
-   
-   //sanity check
-   if (cross->card() != expectedcard) {
-     Fatal("product grid cardinality different than product of component grid cardinalities. (%i, %i)", cross->card(), expectedcard);
-   }
-   
-   //put the cross variables
-   delete sch;
-   sch = cross->getScheme();
-   for (int j=0; j<cross->getarity(); j++) {
-     attr = sch->getAttribute(j);
-     cout << "(j)=" << ", " << j << " attr: " << attr << endl;
-     a = cross->getAttribute(attr.c_str());
-     OutputOp::putData(a, ncdf, counts, d, dims.size()); 
-   }
-   
-
-   delete ncdf;
-   
-  //Write each dim, using first attribute as 'name'
-  //
-  //Write each dim's arrays
-  //
-  //Write each cross attribute
-  
-}
-
-NcVar *OutputOp::putData(Array *a, NcFile *ncdf, long *counts, NcDim **d, int dimcount) {
-  Type t = a->type;
-  NcVar *var = NULL;
-  UnTypedPtr p;
-  cout << a->name << ", " << a->size << endl; 
-  switch (t) {
-    case INT:
-      var = ncdf->add_var(a->name, ncInt, dimcount, (const NcDim **) d);
-      a->getData((int *) p);
-      var->put((int *) p, counts);
-      break;
-    case FLOAT:
-      var = ncdf->add_var(a->name, ncFloat, dimcount, (const NcDim **) d);
-      a->getData((float *) p);
-      var->put((float *) p, counts);
-      break;
-    default:
-      break;
-  }
-  return var;
-}
-*/
-void OutputOp::Output(GridField *GF, string filename, long ) {
-  /*
-   * internal representation:
-   *  magic : 'GFGRID'
-   *  gridnamelength : i
-   *  gridname : gridnamelength*(char : c)
-   *  dim : i
-   *  implicitflag : i
-   *  implicitflag==0 ? (
-   *    zerocellcount : i
-   *    zerocells : zerocellcount*(id : i)
-   *  ) ( 
-   *    zerocellcount : i
-   *  )
-   *  kcelldata : dim*(
-   *    kcellcount : i
-   *    kcells : kcellcount*(
-   *      size : i
-   *      nodes : size*(node : i)
-   *    )
-   */
-   ofstream f(filename.c_str(), ios::binary | ios::out);
-    
-   char magic[7] = "GFGRID";
-   f.write(magic, 6);
-   writeGrid(GF->GetGrid(), f);
-   writeGridField(GF, f);
-   f.flush();
-   f.close();
-   GF->ref();
-}
+ vector<GridField *>::iterator p;
 
-void OutputOp::writeGrid(Grid *G, ofstream &f) {
-  
-   writeName(G->name, f);
-   
-   int dim = G->getdim();
-   f.write((char *) &dim, sizeof(int));
-   int implicitflag = G->getKCells(0)->implicit();
-   f.write((char *) &implicitflag, sizeof(int));
-
-   int nodecount = G->getKCells(0)->getsize();
-   f.write((char *) &nodecount, sizeof(int));
-   
-   if (!implicitflag) {
-     
-     AbstractCellArray *ca = G->getKCells(0);
-     Node *ns;
-     for (unsigned int i=0; i<ca->getsize(); ++i) {
-       ns = ca->getCellNodes(i);
-       //f.write((char *) &(c->size), sizeof(int));
-       f.write((char *) ns, sizeof(int));
-     }
-   } 
-   
-   for (int i=1; i<=dim; i++) {
-     writeCellArray(G->getKCells(i), f);
-   }
-}
+ NcFile *ncdf = new NcFile("./test.cdf", NcFile::Replace);
 
-void OutputOp::writeGridField(GridField *GF, ofstream &f) {
-  for (int i=0; i<GF->Dim(); i++) {
-    f.write((char *) &i, sizeof(int));
-    int a = GF->Arity(i);
-    f.write((char *) &a, sizeof(int));
-    if (GF->Arity(i)) {
-      writeDataset(GF->GetDataset(i), f);
-    }
-  }
-}
-void OutputOp::writeDataset(const Dataset &ds, ofstream &f) {
-   int arity = ds.Arity();
-   
-   ArrayWriter aw(&f);
-   Array *a;
-   const Scheme &sch = ds.GetScheme();
-   for (int i=0; i<arity; ++i) {
-     a = ds.GetAttribute(sch.getAttribute(i));
-     writeName(string(a->getName()), f);
-     f.write((char *) &a->type, sizeof(Type));
-     //f.write((char *) &a->size(), sizeof(int));
-     aw.Write(ds, string(a->getName()));
-   }
+ //put the dims
+ NcDim *d[dims.size()];
+ long counts[dims.size()];
+ int expectedcard = 1;
+ GridField *gf;
+ string attr;
+
+ for (int i=0; i<dims.size(); i++) {
+ gf = dims[i];
+ attr = gf->getScheme()->getAttribute(0);
+ counts[i] = gf->card();
+ expectedcard *= gf->card();
+ d[i] = ncdf->add_dim(gf->getAttribute(attr.c_str())->name, gf->card());
+ }
+
+ //put the dim variables
+ NcVar *var;
+ Array *a;
+ Scheme *sch;
+ NcType t;
+ long size;
+ for (int i=0; i<dims.size(); i++) {
+ gf = dims[i];
+ sch = gf->getScheme();
+ for (int j=0; j<gf->getarity(); j++) {
+ attr = sch->getAttribute(j);
+ cout << "(i,j)=" << i << ", " << j << " attr: " << attr << endl;
+ a = gf->getAttribute(attr.c_str());
+ size = (long) a->size;
+ OutputOp::putData(a, ncdf, &size, &(d[i]), 1);
+ }
+ }
+
+ //sanity check
+ if (cross->card() != expectedcard) {
+ Fatal("product grid cardinality different than product of component grid cardinalities. (%i, %i)", cross->card(), expectedcard);
+ }
+
+ //put the cross variables
+ delete sch;
+ sch = cross->getScheme();
+ for (int j=0; j<cross->getarity(); j++) {
+ attr = sch->getAttribute(j);
+ cout << "(j)=" << ", " << j << " attr: " << attr << endl;
+ a = cross->getAttribute(attr.c_str());
+ OutputOp::putData(a, ncdf, counts, d, dims.size());
+ }
+
+
+ delete ncdf;
+
+ //Write each dim, using first attribute as 'name'
+ //
+ //Write each dim's arrays
+ //
+ //Write each cross attribute
+
+ }
+
+ NcVar *OutputOp::putData(Array *a, NcFile *ncdf, long *counts, NcDim **d, int dimcount) {
+ Type t = a->type;
+ NcVar *var = NULL;
+ UnTypedPtr p;
+ cout << a->name << ", " << a->size << endl;
+ switch (t) {
+ case INT:
+ var = ncdf->add_var(a->name, ncInt, dimcount, (const NcDim **) d);
+ a->getData((int *) p);
+ var->put((int *) p, counts);
+ break;
+ case FLOAT:
+ var = ncdf->add_var(a->name, ncFloat, dimcount, (const NcDim **) d);
+ a->getData((float *) p);
+ var->put((float *) p, counts);
+ break;
+ default:
+ break;
+ }
+ return var;
+ }
+ */
+void OutputOp::Output(GridField *GF, string filename, long)
+{
+	/*
+	 * internal representation:
+	 *  magic : 'GFGRID'
+	 *  gridnamelength : i
+	 *  gridname : gridnamelength*(char : c)
+	 *  dim : i
+	 *  implicitflag : i
+	 *  implicitflag==0 ? (
+	 *    zerocellcount : i
+	 *    zerocells : zerocellcount*(id : i)
+	 *  ) (
+	 *    zerocellcount : i
+	 *  )
+	 *  kcelldata : dim*(
+	 *    kcellcount : i
+	 *    kcells : kcellcount*(
+	 *      size : i
+	 *      nodes : size*(node : i)
+	 *    )
+	 */
+	ofstream f(filename.c_str(), ios::binary | ios::out);
+
+	char magic[7] = "GFGRID";
+	f.write(magic, 6);
+	writeGrid(GF->GetGrid(), f);
+	writeGridField(GF, f);
+	f.flush();
+	f.close();
+	GF->ref();
+}
+
+void OutputOp::writeGrid(Grid *G, ofstream &f)
+{
+
+	writeName(G->name, f);
+
+	int dim = G->getdim();
+	f.write((char *) &dim, sizeof(int));
+	int implicitflag = G->getKCells(0)->implicit();
+	f.write((char *) &implicitflag, sizeof(int));
+
+	int nodecount = G->getKCells(0)->getsize();
+	f.write((char *) &nodecount, sizeof(int));
+
+	if (!implicitflag) {
+
+		AbstractCellArray *ca = G->getKCells(0);
+		Node *ns;
+		for (unsigned int i = 0; i < ca->getsize(); ++i) {
+			ns = ca->getCellNodes(i);
+			//f.write((char *) &(c->size), sizeof(int));
+			f.write((char *) ns, sizeof(int));
+		}
+	}
+
+	for (int i = 1; i <= dim; i++) {
+		writeCellArray(G->getKCells(i), f);
+	}
+}
+
+void OutputOp::writeGridField(GridField *GF, ofstream &f)
+{
+	for (int i = 0; i < GF->Dim(); i++) {
+		f.write((char *) &i, sizeof(int));
+		int a = GF->Arity(i);
+		f.write((char *) &a, sizeof(int));
+		if (GF->Arity(i)) {
+			writeDataset(GF->GetDataset(i), f);
+		}
+	}
+}
+void OutputOp::writeDataset(const Dataset &ds, ofstream &f)
+{
+	int arity = ds.Arity();
+
+	ArrayWriter aw(&f);
+	Array *a;
+	const Scheme &sch = ds.GetScheme();
+	for (int i = 0; i < arity; ++i) {
+		a = ds.GetAttribute(sch.getAttribute(i));
+		writeName(string(a->getName()), f);
+		f.write((char *) &a->type, sizeof(Type));
+		//f.write((char *) &a->size(), sizeof(int));
+		aw.Write(ds, string(a->getName()));
+	}
+}
+
+void OutputOp::writeCellArray(AbstractCellArray *ca, ofstream &f)
+{
+	int size = ca->getsize();
+
+	f.write((char *) &size, sizeof(int));
+
+	int bytesize = ca->bytes();
+	f.write((char *) &bytesize, sizeof(int));
+
+	Cell *c;
+	int s;
+	for (int i = 0; i < size; i++) {
+		c = ca->getCell(i);
+		s = c->getsize();
+		f.write((char *) &s, sizeof(int));
+		f.write((char *) c->getnodes(), sizeof(int) * s);
+	}
+}
+
+void OutputOp::writeName(string name, ofstream &f)
+{
+	int s = name.size();
+	f.write((char *) &s, sizeof(int));
+	f.write(name.c_str(), name.size());
 }
 
-
-void OutputOp::writeCellArray(AbstractCellArray *ca, ofstream &f) {
-   int size = ca->getsize();
-   
-   f.write((char *) &size, sizeof(int));
-   
-   int bytesize = ca->bytes();
-   f.write((char *) &bytesize, sizeof(int)); 
- 
-   Cell *c;
-   int s;
-   for (int i=0; i<size; i++) {
-     c = ca->getCell(i);
-     s = c->getsize();
-     f.write((char *) &s, sizeof(int));
-     f.write((char *) c->getnodes(), sizeof(int)*s);
-   } 
-}
-
-void OutputOp::writeName(string name, ofstream &f) {
-   int s = name.size();
-   f.write((char *) &s, sizeof(int));
-   f.write(name.c_str(), name.size());
-}
-
-
 /*----------------------------------------*/
 /* OutputElcircOp
  *
  *
- */ 
- /* 
-OutputElcircOp::OutputElcircOp(string fn, ElcircHeader *copy, GridFieldOperator *op)  
+ */
+/*
+ OutputElcircOp::OutputElcircOp(string fn, ElcircHeader *copy, GridFieldOperator *op)
  : OutputOp(fn, op), copy(copy) {
-   GF = NULL;
-}
+ GF = NULL;
+ }
+
+ void OutputElcircOp::Output(GridField *GF, string filename, long offset) {
+ h.magic = copy->magic;
+ h.version = copy->version;
+ ElioAllocateHeader(ElcircHeader *h);
+ cout << "elcircoutput" << endl;
+ cout << GF->Card(0);
+ f.write((char *) h.magic, 48);
+ f.write((char *) h.version, 48);
+ f.write((char *) h.start_time, 48);
+ f.write((char *) h.variable_nm, 48);
+ f.write((char *) h.variable_dim, 48);
+ f.write((char *) &(h.nsteps), sizeof(int));
+ f.write((char *) &(h.timestep), sizeof(float));
+ f.write((char *) &(h.skip), sizeof(int));
+ f.write((char *) &(h.ivs), sizeof(int));
+ f.write((char *) &(h.i23d), sizeof(int));
+ }
+ */
+
+} // namespace GF
 
-void OutputElcircOp::Output(GridField *GF, string filename, long offset) {
-  h.magic = copy->magic;
-  h.version = copy->version;
-  ElioAllocateHeader(ElcircHeader *h);
-  cout << "elcircoutput" << endl;
-  cout << GF->Card(0);
-  f.write((char *) h.magic, 48);
-  f.write((char *) h.version, 48);
-  f.write((char *) h.start_time, 48);
-  f.write((char *) h.variable_nm, 48);
-  f.write((char *) h.variable_dim, 48);
-  f.write((char *) &(h.nsteps), sizeof(int));
-  f.write((char *) &(h.timestep), sizeof(float));
-  f.write((char *) &(h.skip), sizeof(int));
-  f.write((char *) &(h.ivs), sizeof(int));
-  f.write((char *) &(h.i23d), sizeof(int));
-}
-  */
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/output.h gridfields/clib/src/output.h
--- tag/gridfieldsclib-0.7/src/output.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/output.h	2014-05-16 22:57:00.793391865 +0200
@@ -6,42 +6,51 @@
 //#include "netcdfcpp.h"
 #include <iostream>
 
-class OutputOp : public UnaryGridFieldOperator {
+namespace GF {
+
+class OutputOp: public UnaryGridFieldOperator {
 public:
-  OutputOp(string fn, long off, GridFieldOperator *Op);
-  OutputOp(string fn, GridFieldOperator *Op);
-  
-  int offset;
-  string filename;
-  void Execute();
-  void setFileName(char *fn) { filename = string(fn); };
-  virtual void Output(GridField *GF, string filename, long offset);
-  //static void WriteNetCDF(vector<GridField *> &dims, GridField *cross);
+	OutputOp(string fn, long off, GridFieldOperator *Op);
+	OutputOp(string fn, GridFieldOperator *Op);
+
+	int offset;
+	string filename;
+	void Execute();
+	void setFileName(char *fn)
+	{
+		filename = string(fn);
+	}
+	;
+	virtual void Output(GridField *GF, string filename, long offset);
+	//static void WriteNetCDF(vector<GridField *> &dims, GridField *cross);
 
 private:
 
-  static void writeCellArray(AbstractCellArray *ca, ofstream &f);
-  static void writeGrid(Grid *G, ofstream &f);
-  static void writeGridField(GridField *GF, ofstream &f);
-  static void writeDataset(const Dataset &ds, ofstream &f);
-  static void writeName(string name, ofstream &f);
+	static void writeCellArray(AbstractCellArray *ca, ofstream &f);
+	static void writeGrid(Grid *G, ofstream &f);
+	static void writeGridField(GridField *GF, ofstream &f);
+	static void writeDataset(const Dataset &ds, ofstream &f);
+	static void writeName(string name, ofstream &f);
 
-  //static NcVar *putData(Array *a, NcFile *ncdf, long *counts, NcDim **d, int dimcount);
+	//static NcVar *putData(Array *a, NcFile *ncdf, long *counts, NcDim **d, int dimcount);
 };
 /*
-class OutputElcircOp : public OutputOp {
-public:
-  OutputElcircOp(string fn, ElcircHeader *copy, GridFieldOperator *Op);
-  
-  virtual void Output(GridField *GF, string filename, long offset);
-  //static void WriteNetCDF(vector<GridField *> &dims, GridField *cross);
+ class OutputElcircOp : public OutputOp {
+ public:
+ OutputElcircOp(string fn, ElcircHeader *copy, GridFieldOperator *Op);
+
+ virtual void Output(GridField *GF, string filename, long offset);
+ //static void WriteNetCDF(vector<GridField *> &dims, GridField *cross);
+
+ private:
+ ElcircHeader h;
+ ElcircHeader *copy;
+ ElcircTimeStep t;
+
+ //static NcVar *putData(Array *a, NcFile *ncdf, long *counts, NcDim **d, int dimcount);
+ };
+ */
+
+} // namespace GF
 
-private:
-   ElcircHeader h;
-   ElcircHeader *copy;
-   ElcircTimeStep t;
-   
-  //static NcVar *putData(Array *a, NcFile *ncdf, long *counts, NcDim **d, int dimcount);
-};
-*/
 #endif
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/outputtuples.cc gridfields/clib/src/outputtuples.cc
--- tag/gridfieldsclib-0.7/src/outputtuples.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/outputtuples.cc	2014-05-16 22:57:00.786725198 +0200
@@ -1,8 +1,11 @@
+#include "config_gridfields.h"
+
 #include "gridfield.h"
-extern "C" {
-#include "stdio.h"
+#include <stdio.h>
+//extern "C" {
+//#include "stdio.h"
 #include "elio.h"
-}
+//}
 #include "expr.h"
 #include "timing.h"
 #include <iostream>
@@ -18,218 +21,230 @@
 
 using namespace std;
 
-OutputTuplesOp::OutputTuplesOp(string fn, GridFieldOperator *op)  
- : UnaryGridFieldOperator(op), offset(0), filename(fn) {
-   GF = NULL;
-   //cleanup = false;
-}
+namespace GF {
 
-OutputTuplesOp::OutputTuplesOp(string fn, long off, GridFieldOperator *op)  
- : UnaryGridFieldOperator(op), offset(off), filename(fn) {
-   //cleanup = false;
-   GF = NULL;
+OutputTuplesOp::OutputTuplesOp(string fn, GridFieldOperator *op) :
+		UnaryGridFieldOperator(op), offset(0), filename(fn)
+{
+	GF = NULL;
+	//cleanup = false;
+}
+
+OutputTuplesOp::OutputTuplesOp(string fn, long off, GridFieldOperator *op) :
+		UnaryGridFieldOperator(op), offset(off), filename(fn)
+{
+	//cleanup = false;
+	GF = NULL;
+}
+
+void OutputTuplesOp::Execute()
+{
+	this->PrepareForExecution();
+	this->Output(this->GF, this->filename, this->offset);
+	this->Result = this->GF;
 }
+/*
+ void OutputTuplesOp::WriteNetCDF(vector<GridField *> &dims, GridField *cross) {
 
+ vector<GridField *>::iterator p;
 
-void OutputTuplesOp::Execute() {
-  this->PrepareForExecution();
-  this->Output(this->GF, this->filename, this->offset);
-  this->Result = this->GF;
-}
-/*
-void OutputTuplesOp::WriteNetCDF(vector<GridField *> &dims, GridField *cross) {
+ NcFile *ncdf = new NcFile("./test.cdf", NcFile::Replace);
 
-   vector<GridField *>::iterator p;
-   
-   NcFile *ncdf = new NcFile("./test.cdf", NcFile::Replace); 
-   
-   //put the dims
-   NcDim *d[dims.size()];
-   long counts[dims.size()];
-   int expectedcard = 1;
-   GridField *gf;
-   string attr;
-   
-   for (int i=0; i<dims.size(); i++) {
-      gf = dims[i];
-      attr = gf->getScheme()->getAttribute(0);
-      counts[i] = gf->card();
-      expectedcard *= gf->card();
-      d[i] = ncdf->add_dim(gf->getAttribute(attr.c_str())->name, gf->card());
-   }
-   
-   //put the dim variables
-   NcVar *var;
-   Array *a;
-   Scheme *sch;
-   NcType t;
-   long size;
-   for (int i=0; i<dims.size(); i++) {
-     gf = dims[i];
-     sch = gf->getScheme();
-     for (int j=0; j<gf->getarity(); j++) {
-       attr = sch->getAttribute(j);
-       cout << "(i,j)=" << i << ", " << j << " attr: " << attr << endl;
-       a = gf->getAttribute(attr.c_str());
-       size = (long) a->size;
-       OutputTuplesOp::putData(a, ncdf, &size, &(d[i]), 1); 
-     }
-   }
-   
-   //sanity check
-   if (cross->card() != expectedcard) {
-     Fatal("product grid cardinality different than product of component grid cardinalities. (%i, %i)", cross->card(), expectedcard);
-   }
-   
-   //put the cross variables
-   delete sch;
-   sch = cross->getScheme();
-   for (int j=0; j<cross->getarity(); j++) {
-     attr = sch->getAttribute(j);
-     cout << "(j)=" << ", " << j << " attr: " << attr << endl;
-     a = cross->getAttribute(attr.c_str());
-     OutputTuplesOp::putData(a, ncdf, counts, d, dims.size()); 
-   }
-   
-
-   delete ncdf;
-   
-  //Write each dim, using first attribute as 'name'
-  //
-  //Write each dim's arrays
-  //
-  //Write each cross attribute
-  
-}
-
-NcVar *OutputTuplesOp::putData(Array *a, NcFile *ncdf, long *counts, NcDim **d, int dimcount) {
-  Type t = a->type;
-  NcVar *var = NULL;
-  UnTypedPtr p;
-  cout << a->name << ", " << a->size << endl; 
-  switch (t) {
-    case INT:
-      var = ncdf->add_var(a->name, ncInt, dimcount, (const NcDim **) d);
-      a->getData((int *) p);
-      var->put((int *) p, counts);
-      break;
-    case FLOAT:
-      var = ncdf->add_var(a->name, ncFloat, dimcount, (const NcDim **) d);
-      a->getData((float *) p);
-      var->put((float *) p, counts);
-      break;
-    default:
-      break;
-  }
-  return var;
-}
-*/
-void OutputTuplesOp::Output(GridField *GF, string filename, long ) {
-  /*
-   * internal representation:
-   *  magic : 'GFGRID'
-   *  gridnamelength : i
-   *  gridname : gridnamelength*(char : c)
-   *  dim : i
-   *  implicitflag : i
-   *  implicitflag==0 ? (
-   *    zerocellcount : i
-   *    zerocells : zerocellcount*(id : i)
-   *  ) ( 
-   *    zerocellcount : i
-   *  )
-   *  kcelldata : dim*(
-   *    kcellcount : i
-   *    kcells : kcellcount*(
-   *      size : i
-   *      nodes : size*(node : i)
-   *    )
-   */
-   ofstream f(filename.c_str(), ios::binary | ios::out);
-    
-   char magic[7] = "GFGRID";
-   f.write(magic, 6);
-   writeGrid(GF->GetGrid(), f);
-   writeGridField(GF, f);
-   f.flush();
-   f.close();
-   GF->ref();
-}
-
-void OutputTuplesOp::writeGrid(Grid *G, ofstream &f) {
-  
-   writeName(G->name, f);
-   
-   int dim = G->getdim();
-   f.write((char *) &dim, sizeof(int));
-   int implicitflag = G->getKCells(0)->implicit();
-   f.write((char *) &implicitflag, sizeof(int));
-
-   int nodecount = G->getKCells(0)->getsize();
-   f.write((char *) &nodecount, sizeof(int));
-   
-   if (!implicitflag) {
-     
-     AbstractCellArray *ca = G->getKCells(0);
-     Node *ns;
-     for (size_t i=0; i<ca->getsize(); ++i) {
-       ns = ca->getCellNodes(i);
-       //f.write((char *) &(c->size), sizeof(int));
-       f.write((char *) ns, sizeof(int));
-     }
-   } 
-   
-   for (int i=1; i<=dim; i++) {
-     writeCellArray(G->getKCells(i), f);
-   }
-}
-
-void OutputTuplesOp::writeGridField(GridField *GF, ofstream &f) {
-  for (int i=0; i<GF->Dim(); i++) {
-    f.write((char *) &i, sizeof(int));
-    int a = GF->Arity(i);
-    f.write((char *) &a, sizeof(int));
-    if (GF->Arity(i)) {
-      writeDataset(GF->GetDataset(i), f);
-    }
-  }
-}
-void OutputTuplesOp::writeDataset(const Dataset &ds, ofstream &f) {
-   int arity = ds.Arity();
-   
-   ArrayWriter aw(&f);
-   Array *a;
-   const Scheme &sch = ds.GetScheme();
-   for (int i=0; i<arity; ++i) {
-     a = ds.GetAttribute(sch.getAttribute(i));
-     writeName(string(a->getName()), f);
-     f.write((char *) &a->type, sizeof(Type));
-     //f.write((char *) &a->size(), sizeof(int));
-     aw.Write(ds, string(a->getName()));
-   }
-}
-
-
-void OutputTuplesOp::writeCellArray(AbstractCellArray *ca, ofstream &f) {
-   int size = ca->getsize();
-   
-   f.write((char *) &size, sizeof(int));
-   
-   int bytesize = ca->bytes();
-   f.write((char *) &bytesize, sizeof(int)); 
- 
-   Cell *c;
-   int s;
-   for (int i=0; i<size; i++) {
-     c = ca->getCell(i);
-     s = c->getsize();
-     f.write((char *) &s, sizeof(int));
-     f.write((char *) c->getnodes(), sizeof(int)*s);
-   } 
-}
-
-void OutputTuplesOp::writeName(string name, ofstream &f) {
-   int s = name.size();
-   f.write((char *) &s, sizeof(int));
-   f.write(name.c_str(), name.size());
+ //put the dims
+ NcDim *d[dims.size()];
+ long counts[dims.size()];
+ int expectedcard = 1;
+ GridField *gf;
+ string attr;
+
+ for (int i=0; i<dims.size(); i++) {
+ gf = dims[i];
+ attr = gf->getScheme()->getAttribute(0);
+ counts[i] = gf->card();
+ expectedcard *= gf->card();
+ d[i] = ncdf->add_dim(gf->getAttribute(attr.c_str())->name, gf->card());
+ }
+
+ //put the dim variables
+ NcVar *var;
+ Array *a;
+ Scheme *sch;
+ NcType t;
+ long size;
+ for (int i=0; i<dims.size(); i++) {
+ gf = dims[i];
+ sch = gf->getScheme();
+ for (int j=0; j<gf->getarity(); j++) {
+ attr = sch->getAttribute(j);
+ cout << "(i,j)=" << i << ", " << j << " attr: " << attr << endl;
+ a = gf->getAttribute(attr.c_str());
+ size = (long) a->size;
+ OutputTuplesOp::putData(a, ncdf, &size, &(d[i]), 1);
+ }
+ }
+
+ //sanity check
+ if (cross->card() != expectedcard) {
+ Fatal("product grid cardinality different than product of component grid cardinalities. (%i, %i)", cross->card(), expectedcard);
+ }
+
+ //put the cross variables
+ delete sch;
+ sch = cross->getScheme();
+ for (int j=0; j<cross->getarity(); j++) {
+ attr = sch->getAttribute(j);
+ cout << "(j)=" << ", " << j << " attr: " << attr << endl;
+ a = cross->getAttribute(attr.c_str());
+ OutputTuplesOp::putData(a, ncdf, counts, d, dims.size());
+ }
+
+
+ delete ncdf;
+
+ //Write each dim, using first attribute as 'name'
+ //
+ //Write each dim's arrays
+ //
+ //Write each cross attribute
+
+ }
+
+ NcVar *OutputTuplesOp::putData(Array *a, NcFile *ncdf, long *counts, NcDim **d, int dimcount) {
+ Type t = a->type;
+ NcVar *var = NULL;
+ UnTypedPtr p;
+ cout << a->name << ", " << a->size << endl;
+ switch (t) {
+ case INT:
+ var = ncdf->add_var(a->name, ncInt, dimcount, (const NcDim **) d);
+ a->getData((int *) p);
+ var->put((int *) p, counts);
+ break;
+ case FLOAT:
+ var = ncdf->add_var(a->name, ncFloat, dimcount, (const NcDim **) d);
+ a->getData((float *) p);
+ var->put((float *) p, counts);
+ break;
+ default:
+ break;
+ }
+ return var;
+ }
+ */
+void OutputTuplesOp::Output(GridField *GF, string filename, long)
+{
+	/*
+	 * internal representation:
+	 *  magic : 'GFGRID'
+	 *  gridnamelength : i
+	 *  gridname : gridnamelength*(char : c)
+	 *  dim : i
+	 *  implicitflag : i
+	 *  implicitflag==0 ? (
+	 *    zerocellcount : i
+	 *    zerocells : zerocellcount*(id : i)
+	 *  ) (
+	 *    zerocellcount : i
+	 *  )
+	 *  kcelldata : dim*(
+	 *    kcellcount : i
+	 *    kcells : kcellcount*(
+	 *      size : i
+	 *      nodes : size*(node : i)
+	 *    )
+	 */
+	ofstream f(filename.c_str(), ios::binary | ios::out);
+
+	char magic[7] = "GFGRID";
+	f.write(magic, 6);
+	writeGrid(GF->GetGrid(), f);
+	writeGridField(GF, f);
+	f.flush();
+	f.close();
+	GF->ref();
+}
+
+void OutputTuplesOp::writeGrid(Grid *G, ofstream &f)
+{
+
+	writeName(G->name, f);
+
+	int dim = G->getdim();
+	f.write((char *) &dim, sizeof(int));
+	int implicitflag = G->getKCells(0)->implicit();
+	f.write((char *) &implicitflag, sizeof(int));
+
+	int nodecount = G->getKCells(0)->getsize();
+	f.write((char *) &nodecount, sizeof(int));
+
+	if (!implicitflag) {
+
+		AbstractCellArray *ca = G->getKCells(0);
+		Node *ns;
+		for (size_t i = 0; i < ca->getsize(); ++i) {
+			ns = ca->getCellNodes(i);
+			//f.write((char *) &(c->size), sizeof(int));
+			f.write((char *) ns, sizeof(int));
+		}
+	}
+
+	for (int i = 1; i <= dim; i++) {
+		writeCellArray(G->getKCells(i), f);
+	}
+}
+
+void OutputTuplesOp::writeGridField(GridField *GF, ofstream &f)
+{
+	for (int i = 0; i < GF->Dim(); i++) {
+		f.write((char *) &i, sizeof(int));
+		int a = GF->Arity(i);
+		f.write((char *) &a, sizeof(int));
+		if (GF->Arity(i)) {
+			writeDataset(GF->GetDataset(i), f);
+		}
+	}
+}
+void OutputTuplesOp::writeDataset(const Dataset &ds, ofstream &f)
+{
+	int arity = ds.Arity();
+
+	ArrayWriter aw(&f);
+	Array *a;
+	const Scheme &sch = ds.GetScheme();
+	for (int i = 0; i < arity; ++i) {
+		a = ds.GetAttribute(sch.getAttribute(i));
+		writeName(string(a->getName()), f);
+		f.write((char *) &a->type, sizeof(Type));
+		//f.write((char *) &a->size(), sizeof(int));
+		aw.Write(ds, string(a->getName()));
+	}
+}
+
+void OutputTuplesOp::writeCellArray(AbstractCellArray *ca, ofstream &f)
+{
+	int size = ca->getsize();
+
+	f.write((char *) &size, sizeof(int));
+
+	int bytesize = ca->bytes();
+	f.write((char *) &bytesize, sizeof(int));
+
+	Cell *c;
+	int s;
+	for (int i = 0; i < size; i++) {
+		c = ca->getCell(i);
+		s = c->getsize();
+		f.write((char *) &s, sizeof(int));
+		f.write((char *) c->getnodes(), sizeof(int) * s);
+	}
+}
+
+void OutputTuplesOp::writeName(string name, ofstream &f)
+{
+	int s = name.size();
+	f.write((char *) &s, sizeof(int));
+	f.write(name.c_str(), name.size());
 }
+
+} // namespace GF
+
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/outputtuples.h gridfields/clib/src/outputtuples.h
--- tag/gridfieldsclib-0.7/src/outputtuples.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/outputtuples.h	2014-05-16 22:57:00.726725200 +0200
@@ -5,27 +5,35 @@
 //#include "netcdfcpp.h"
 #include <iostream>
 
-class OutputTuplesOp : public UnaryGridFieldOperator {
+namespace GF {
+
+class OutputTuplesOp: public UnaryGridFieldOperator {
 public:
-  OutputTuplesOp(string fn, long off, GridFieldOperator *Op);
-  OutputTuplesOp(string fn, GridFieldOperator *Op);
-  
-  int offset;
-  string filename;
-  void Execute();
-  void setFileName(char *fn) { filename = string(fn); };
-  static void Output(GridField *GF, string filename, long offset);
-  //static void WriteNetCDF(vector<GridField *> &dims, GridField *cross);
+	OutputTuplesOp(string fn, long off, GridFieldOperator *Op);
+	OutputTuplesOp(string fn, GridFieldOperator *Op);
+
+	int offset;
+	string filename;
+	void Execute();
+	void setFileName(char *fn)
+	{
+		filename = string(fn);
+	}
+	;
+	static void Output(GridField *GF, string filename, long offset);
+	//static void WriteNetCDF(vector<GridField *> &dims, GridField *cross);
 
 private:
 
-  static void writeCellArray(AbstractCellArray *ca, ofstream &f);
-  static void writeGrid(Grid *G, ofstream &f);
-  static void writeGridField(GridField *GF, ofstream &f);
-  static void writeDataset(const Dataset &ds, ofstream &f);
-  static void writeName(string name, ofstream &f);
+	static void writeCellArray(AbstractCellArray *ca, ofstream &f);
+	static void writeGrid(Grid *G, ofstream &f);
+	static void writeGridField(GridField *GF, ofstream &f);
+	static void writeDataset(const Dataset &ds, ofstream &f);
+	static void writeName(string name, ofstream &f);
 
-  //static NcVar *putData(Array *a, NcFile *ncdf, long *counts, NcDim **d, int dimcount);
+	//static NcVar *putData(Array *a, NcFile *ncdf, long *counts, NcDim **d, int dimcount);
 };
 
+} // namespace GF
+
 #endif
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/partition.h gridfields/clib/src/partition.h
--- tag/gridfieldsclib-0.7/src/partition.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/partition.h	2014-05-16 22:57:00.770058532 +0200
@@ -6,76 +6,79 @@
 #include "gridfieldoperator.h"
 #include <string>
 
+namespace GF {
+
 class Stencil {
-  /*
-  pattern of cells forming an atomic unit for partitioning
-  
-  we want to tag each cell with a partition number
-
-  Cell is an integer 
-
-  Incidence relation on disk:
-  2 -> 0, 0, 0
-
-  Or potentially:
-  2,0
-  2,0
-  2,0
-
-<bad>
-  We need to partition the incidence relation into pages such that 
-  connectedness, well-supportedness, homogeneity, are preserved in 
-  the derived page-grids.
-
-  For example, if nodes a,b,c are incident to a 2-cell e in a grid G, then if a subgrid Gi that contains e, it must also contain a,b,c to maintain well-supportedness
-
-  Some of these properties can be encoded as an assignment function.  For a cell c, return all the cells in G that need to be included with it in Gi to maintain the appropriate property.
-
-  Properties of the form:
-  if P(a,b) in G, then P(a,b) in Gi
-  can be written as a function Cell -> [Cell]
-  (\a . [x | x in P(a,x)])
-
-  keep adding cells to a page
-</bad>
- 
-  Each query plan has a topological access pattern for each cell of each dimension.  Some need only the data of the cells of one dimension.  Some need the surrounding cells (gradient, particle tracking).  These access patterns are precisely the assignment functions of the aggregate operators (and special assignment functions for enforcing certain properties)
-
-  restrict: (\x. [y | y in cells(G), x > y])
-  
-  Given an assignment function m, try to partition the grid such that 
-  x in Gi => m(x) in Gi
-
-  regrid operators have different source and target grids and use data inthe assignment functions.  These are processed as nested-loops joins with a lumped, materialized output.   Another partition operation may be necessary to repair fractured stencils upstream.
-  
-  Stencil is an assignment function G -> G that involves only topology
-  
-  S = Stencil
-
-  if |S| > MAX_P,
-    raise an error
-
-  for each cell c,
-    plug it into the stencil
-    return neighboring cells N
-    if |P| + |N| > MAX_P,
-      flush P
-      
-    
-  */
+	/*
+	 pattern of cells forming an atomic unit for partitioning
+
+	 we want to tag each cell with a partition number
+
+	 Cell is an integer
+
+	 Incidence relation on disk:
+	 2 -> 0, 0, 0
+
+	 Or potentially:
+	 2,0
+	 2,0
+	 2,0
+
+	 <bad>
+	 We need to partition the incidence relation into pages such that
+	 connectedness, well-supportedness, homogeneity, are preserved in
+	 the derived page-grids.
+
+	 For example, if nodes a,b,c are incident to a 2-cell e in a grid G, then if a subgrid Gi that contains e, it must also contain a,b,c to maintain well-supportedness
+
+	 Some of these properties can be encoded as an assignment function.  For a cell c, return all the cells in G that need to be included with it in Gi to maintain the appropriate property.
+
+	 Properties of the form:
+	 if P(a,b) in G, then P(a,b) in Gi
+	 can be written as a function Cell -> [Cell]
+	 (\a . [x | x in P(a,x)])
+
+	 keep adding cells to a page
+	 </bad>
+
+	 Each query plan has a topological access pattern for each cell of each dimension.  Some need only the data of the cells of one dimension.  Some need the surrounding cells (gradient, particle tracking).  These access patterns are precisely the assignment functions of the aggregate operators (and special assignment functions for enforcing certain properties)
+
+	 restrict: (\x. [y | y in cells(G), x > y])
+
+	 Given an assignment function m, try to partition the grid such that
+	 x in Gi => m(x) in Gi
+
+	 regrid operators have different source and target grids and use data inthe assignment functions.  These are processed as nested-loops joins with a lumped, materialized output.   Another partition operation may be necessary to repair fractured stencils upstream.
+
+	 Stencil is an assignment function G -> G that involves only topology
+
+	 S = Stencil
+
+	 if |S| > MAX_P,
+	 raise an error
+
+	 for each cell c,
+	 plug it into the stencil
+	 return neighboring cells N
+	 if |P| + |N| > MAX_P,
+	 flush P
+
+
+	 */
 }
 
-class PartitionOp : public UnaryGridFieldOperator {
- public:
-  PartitionOp(GridFieldOperator *op, string tupleexpr);
-  PartitionOp(GridFieldOperator *op, string attr, string expr);
-  void Execute();
-  static GridField *Partition(GridField *Gg,
-			  string tupleexpr);
+class PartitionOp: public UnaryGridFieldOperator {
+public:
+	PartitionOp(GridFieldOperator *op, string tupleexpr);
+	PartitionOp(GridFieldOperator *op, string attr, string expr);
+	void Execute();
+	static GridField *Partition(GridField *Gg, string tupleexpr);
 
- private:
-  string unparsedExpr;
+private:
+	string unparsedExpr;
 
 };
 
+} // namespace GF
+
 #endif /* APPLY_H */
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/project.cc gridfields/clib/src/project.cc
--- tag/gridfieldsclib-0.7/src/project.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/project.cc	2014-05-16 22:57:00.733391866 +0200
@@ -1,41 +1,48 @@
+#include "config_gridfields.h"
+
 #include "apply.h"
 #include "timing.h"
 #include "project.h"
 #include "expr.h"
 #include <math.h>
 
-ProjectOp::ProjectOp(GridFieldOperator *op, Dim_t k, string attribute_list) 
-         :  UnaryGridFieldOperator(op),_k(k) 
+namespace GF {
+
+ProjectOp::ProjectOp(GridFieldOperator *op, Dim_t k, string attribute_list) :
+		UnaryGridFieldOperator(op), _k(k)
 {
-  split(attribute_list, ";, -:", keepers);
+	split(attribute_list, ";, -:", keepers);
 }
 
-ProjectOp::ProjectOp(GridFieldOperator *op, Dim_t k, vector<string> &ks) 
-  : UnaryGridFieldOperator(op), _k(k), keepers(ks)
+ProjectOp::ProjectOp(GridFieldOperator *op, Dim_t k, vector<string> &ks) :
+		UnaryGridFieldOperator(op), _k(k), keepers(ks)
 {
 }
 
-void ProjectOp::Execute() {
-  this->PrepareForExecution();
-  this->Result =  Project(this->GF, this->_k,
-                          this->keepers);
+void ProjectOp::Execute()
+{
+	this->PrepareForExecution();
+	this->Result = Project(this->GF, this->_k, this->keepers);
 }
 
-GridField *ProjectOp::Project(GridField *Gg, Dim_t k, string keeper) {
-  return ProjectOp::Project(Gg, k, vector<string>(1, keeper));
+GridField *ProjectOp::Project(GridField *Gg, Dim_t k, string keeper)
+{
+	return ProjectOp::Project(Gg, k, vector<string>(1, keeper));
 }
 
-GridField *ProjectOp::Project(GridField *Gg, Dim_t k,
-                              vector<string> keepers) {
+GridField *ProjectOp::Project(GridField *Gg, Dim_t k, vector<string> keepers)
+{
 
-  GridField *Out = new GridField(Gg->GetGrid());
+	GridField *Out = new GridField(Gg->GetGrid());
 
-  
-  vector<string>::iterator p;
-  for (p=keepers.begin(); p!=keepers.end(); ++p) {
-    if (Gg->IsAttribute(k, *p)) {
-      Out->Bind(k, Gg->GetAttribute(k, *p));
-    }
-  }
-  return Out;
+	vector<string>::iterator p;
+	for (p = keepers.begin(); p != keepers.end(); ++p) {
+		if (Gg->IsAttribute(k, *p)) {
+			Out->Bind(k, Gg->GetAttribute(k, *p));
+		}
+	}
+	return Out;
 }
+
+} // namespace GF
+
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/project.h gridfields/clib/src/project.h
--- tag/gridfieldsclib-0.7/src/project.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/project.h	2014-05-16 22:57:00.770058532 +0200
@@ -1,27 +1,36 @@
 #ifndef _PROJECT_H
 #define _PROJECT_H
 
+// #include "config.h"
+
 #include <iostream>
+// #include <functional>
 #include "tuple.h"
 #include "array.h"
 #include "gridfield.h"
 #include "fparser.hh"
 #include "gridfieldoperator.h"
-#include <ext/functional>
+//#ifdef HAVE_TR1_FUNCTIONAL
+//#include <tr1/functional>
+//#endif
+// old code jhrg #include <ext/functional>
 #include <string>
 
+namespace GF {
+
+class ProjectOp: public UnaryGridFieldOperator {
+public:
+	ProjectOp(GridFieldOperator *op, Dim_t k, vector<string> &keepers);
+	ProjectOp(GridFieldOperator *op, Dim_t k, string attribute_list);
 
-class ProjectOp : public UnaryGridFieldOperator {
- public:
-  ProjectOp(GridFieldOperator *op, Dim_t k, vector<string> &keepers);
-  ProjectOp(GridFieldOperator *op, Dim_t k, string attribute_list);
-  
-  void Execute();
-  static GridField *Project(GridField *Gg, Dim_t k, vector<string> ks);
-  static GridField *Project(GridField *Gg, Dim_t k, string keeper);
- private:
-  Dim_t _k;
-  vector<string> keepers;
+	void Execute();
+	static GridField *Project(GridField *Gg, Dim_t k, vector<string> ks);
+	static GridField *Project(GridField *Gg, Dim_t k, string keeper);
+private:
+	Dim_t _k;
+	vector<string> keepers;
 };
 
+} // namespace GF
+
 #endif /* PROJECT_H */
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/rankeddataset.cc gridfields/clib/src/rankeddataset.cc
--- tag/gridfieldsclib-0.7/src/rankeddataset.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/rankeddataset.cc	2014-05-16 22:57:00.826725198 +0200
@@ -1,3 +1,5 @@
+#include "config_gridfields.h"
+
 #include "rankeddataset.h"
 #include "dataset.h"
 #include "array.h"
@@ -5,100 +7,123 @@
 #include <sstream>
 #include <iostream>
 
-UnTypedPtr RankedDataset::GetVoidPointer(const string &attr, Dim_t d) const { 
-   if (d<=MaxRank()) {
-     return ranks[d].GetVoidPointer(attr);
-   } else {
-     Fatal("dim %i requested on a rankeddataset of dim %i", d, MaxRank());
-     return NULL;
-   }
-}
-   
-Dataset::IntIterator RankedDataset::BeginInt(Dim_t d, const string &attr) {
-   if (d<=MaxRank()) {
-     return ranks[d].BeginInt(attr);
-   } else {
-     Fatal("dim %i requested on a rankeddataset of dim %i", d, MaxRank());
-     return NULL;
-   }
-}
-
-Dataset::IntIterator RankedDataset::EndInt(Dim_t d, const string &attr) {
-   if (d<=MaxRank()) {
-     return ranks[d].EndInt(attr);
-   } else {
-     Fatal("dim %i requested on a rankeddataset of dim %i", d, MaxRank());
-     return NULL;
-   }
-}
-
-Dataset::FloatIterator RankedDataset::BeginFloat(Dim_t d, const string &attr) {
-   if (d<=MaxRank()) {
-     return ranks[d].BeginFloat(attr);
-   } else {
-     Fatal("dim %i requested on a rankeddataset of dim %i", d, MaxRank());
-     return NULL;
-   }
-}
-
-Dataset::FloatIterator RankedDataset::EndFloat(Dim_t d, const string &attr) {
-   if (d<=MaxRank()) {
-     return ranks[d].EndFloat(attr);
-   } else {
-     Fatal("dim %i requested on a rankeddataset of dim %i", d, MaxRank());
-     return NULL;
-   }
-}
-
-void RankedDataset::GetDataset(Dim_t d, const string &attrs, Dataset &ds) {
-  vector<string> words;
-  split(attrs, ",; :/", words);
-
-  FOR(vector<string>, w, words) {
-    Array *arr = this->GetAttribute(d, *w);
-    ds.AddAttribute(arr);
-    
-    this->RemoveAttribute(d, *w);
-  }
-}
-
-void RankedDataset::Zip(Dim_t d, const Dataset &ds) {
-  /*
-  if (Size(d) != ds.Size()) {
-    std::stringstream ss;
-    ss << "Cardinality of G_";
-    ss << d << " (" << Size(d) << ") ";
-    ss <<"does not match cardinality of dataset (";
-    ss << ds.Size() << ")";
-    Fatal(ss.str().c_str());
-    //throw GFException(ss.str());
-  }
-  */
-  ranks[d].Zip(ds);
-}
-
-void RankedDataset::Apply(const string &expr, Dim_t d) {
-  if (d<=this->Dim()) {
-    this->ranks[d].Apply(expr);
-  }
-}
-
-void RankedDataset::PrintTo(ostream &os, int indent) const {
-  os << "RankedDataset:" <<endl;
-  vector<Dataset>::const_iterator di;
-  
-  for (di=this->ranks.begin(); di!=this->ranks.end(); di++) {
-    di->PrintTo(os, indent+4);
-  }
-}
-
-void RankedDataset::unref() {
-  int old = refcount;
-  Object::unref();
-  DEBUG << "rankeddatset.unref " << this << ", " << "unref: " << old << " -> " << this->refcount << endl;
-  if (this->norefs()) {
-
-    DEBUG << "....deleting" << endl;
-    delete this;
-  }
+namespace GF {
+
+UnTypedPtr RankedDataset::GetVoidPointer(const string &attr, Dim_t d) const
+{
+	if (d <= MaxRank()) {
+		return ranks[d].GetVoidPointer(attr);
+	}
+	else {
+		Fatal("dim %i requested on a rankeddataset of dim %i", d, MaxRank());
+		return NULL;
+	}
+}
+
+Dataset::IntIterator RankedDataset::BeginInt(Dim_t d, const string &attr)
+{
+	if (d <= MaxRank()) {
+		return ranks[d].BeginInt(attr);
+	}
+	else {
+		Fatal("dim %i requested on a rankeddataset of dim %i", d, MaxRank());
+		return NULL;
+	}
+}
+
+Dataset::IntIterator RankedDataset::EndInt(Dim_t d, const string &attr)
+{
+	if (d <= MaxRank()) {
+		return ranks[d].EndInt(attr);
+	}
+	else {
+		Fatal("dim %i requested on a rankeddataset of dim %i", d, MaxRank());
+		return NULL;
+	}
+}
+
+Dataset::FloatIterator RankedDataset::BeginFloat(Dim_t d, const string &attr)
+{
+	if (d <= MaxRank()) {
+		return ranks[d].BeginFloat(attr);
+	}
+	else {
+		Fatal("dim %i requested on a rankeddataset of dim %i", d, MaxRank());
+		return NULL;
+	}
+}
+
+Dataset::FloatIterator RankedDataset::EndFloat(Dim_t d, const string &attr)
+{
+	if (d <= MaxRank()) {
+		return ranks[d].EndFloat(attr);
+	}
+	else {
+		Fatal("dim %i requested on a rankeddataset of dim %i", d, MaxRank());
+		return NULL;
+	}
+}
+
+void RankedDataset::GetDataset(Dim_t d, const string &attrs, Dataset &ds)
+{
+	vector<string> words;
+	split(attrs, ",; :/", words);
+
+	FOR(vector<string>, w, words)
+	{
+		Array *arr = this->GetAttribute(d, *w);
+		ds.AddAttribute(arr);
+
+		// TODO Look at this and make sure it doesn't result in an invalid
+		// iterator. jhrg 4/3/14
+		this->RemoveAttribute(d, *w);
+	}
+}
+
+void RankedDataset::Zip(Dim_t d, const Dataset &ds)
+{
+	/*
+	 if (Size(d) != ds.Size()) {
+	 std::stringstream ss;
+	 ss << "Cardinality of G_";
+	 ss << d << " (" << Size(d) << ") ";
+	 ss <<"does not match cardinality of dataset (";
+	 ss << ds.Size() << ")";
+	 Fatal(ss.str().c_str());
+	 //throw GFException(ss.str());
+	 }
+	 */
+	ranks[d].Zip(ds);
+}
+
+void RankedDataset::Apply(const string &expr, Dim_t d)
+{
+	if (d <= this->Dim()) {
+		this->ranks[d].Apply(expr);
+	}
+}
+
+void RankedDataset::PrintTo(ostream &os, int indent) const
+{
+	os << "RankedDataset:" << endl;
+	vector<Dataset>::const_iterator di;
+
+	for (di = this->ranks.begin(); di != this->ranks.end(); di++) {
+		di->PrintTo(os, indent + 4);
+	}
+}
+
+void RankedDataset::unref()
+{
+	int old = refcount;
+	Object::unref();
+	DEBUG << "rankeddatset.unref " << this << ", " << "unref: " << old << " -> " << this->refcount << endl;
+	if (this->norefs()) {
+
+		DEBUG << "....deleting" << endl;
+		delete this;
+	}
 }
+
+} // namespace GF
+
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/rankeddataset.h gridfields/clib/src/rankeddataset.h
--- tag/gridfieldsclib-0.7/src/rankeddataset.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/rankeddataset.h	2014-05-16 22:57:00.740058533 +0200
@@ -9,95 +9,171 @@
 #include <iostream>
 #include <string>
 
-using namespace std;
+//using namespace std;
+
+namespace GF {
 
 typedef vector<size_t> Shape;
 
-class RankedDataset : public Object {
+class RankedDataset: public Object {
 
- public:
-   RankedDataset(const Shape &s) { 
-     this->ref(); 
-     this->SetShape(s);
-   };
-   void SetShape(const Shape &s) {
-     this->Clear();
-     for (unsigned int i=0; i<s.size(); i++) {
-       ranks.push_back(Dataset(s[i]));
-     }
-   }
-  
- 
-   RankedDataset() { this->ref(); };
-   Dim_t Dim() { return ranks.size()-1; };
- 
-   UnTypedPtr GetVoidPointer(const string &attr, Dim_t d) const;
-
-   Dataset::IntIterator BeginInt(Dim_t d, const string &attr);
-   Dataset::IntIterator EndInt(Dim_t d, const string &attr);
-   Dataset::FloatIterator BeginFloat(Dim_t d, const string &attr);
-   Dataset::FloatIterator EndFloat(Dim_t d, const string &attr);
-
-   void Clear() { ranks.clear(); }
-
-   void CoerceScheme(Dim_t k, Scheme *sch, size_t sz=0) { assert(k<ranks.size()); return ranks[k].CoerceScheme(*sch, sz);};
-  
-   void AddAttribute(Dim_t k, Array *data) { 
-     if (k>=(Dim_t)ranks.size()) {
-       Fatal("Attempt to add an attribute at rank %i for rankeddataset of dim %i", k,this->Dim());
-     }
-     ranks[k].AddAttribute(data); 
-   };
-   void Bind(Dim_t k, Array *data) { this->AddAttribute(k, data); };
-   void unBind(Dim_t k, const string &attr) { this->RemoveAttribute(k, attr); };
-
-   void unref();
-   Scheme GetScheme(Dim_t k) const { 
-     if (k<(Dim_t)ranks.size()) return ranks[k].GetScheme(); 
-     else return Scheme();
-   };
-   
-   bool IsAttribute(Dim_t k, const string &attr) {
-     if (k<(Dim_t)ranks.size()) return ranks[k].IsAttribute(attr); 
-     else return false;
-   };
-   Array *GetAttribute(Dim_t k, const string &attr) { 
-      if (k<(Dim_t)ranks.size()) return ranks[k].GetAttribute(attr); 
-      else {
-        Fatal("Request for an attribute at rank %i on a gridfield with max rank %i", k, ranks.size()-1);
-        return NULL;
-      }
-   };
-   void RemoveAttribute(Dim_t k, const string &attr) {
-     if (k>=(Dim_t)ranks.size()) return;
-     ranks[k].RemoveAttribute(GetAttribute(k, attr)); 
-   };
-   
-   UnTypedPtr GetAttributeValue(Dim_t k, const string &attr, idx i) { 
-     return ranks[k].GetAttributeVal(attr, i); 
-   };
-   float GetFloatAttributeValue(Dim_t k, const string &attr, idx i) { 
-     return *(float *) ranks[k].GetAttributeVal(attr, i); 
-   };
-   float GetIntAttributeValue(Dim_t k, const string &attr, idx i) { 
-     return *(int *) ranks[k].GetAttributeVal(attr, i); 
-   };
-  
-   size_t Arity(Dim_t k) { if (k<(Dim_t)ranks.size()) return ranks[k].Arity(); else return 0; };
-   size_t Size(Dim_t k) { if (k<(Dim_t)ranks.size()) return ranks[k].Size(); else return 0; };
-   Dim_t MaxRank() const {  return ranks.size()-1; };
-
-   void Apply(const string &expr, Dim_t d);
- 
-   void GetDataset(Dim_t d, const string &attrs, Dataset &Result);
-   const Dataset &GetDataset(Dim_t d) const { if (d<(Dim_t)ranks.size()) return ranks[d]; else return empty; };
-   void Zip(Dim_t d, const Dataset &D);
-
-   void PrintTo(ostream &os, int indent) const;
-
- private:
-   Dataset empty;
-   vector<Dataset> ranks;
+public:
+	RankedDataset(const Shape &s)
+	{
+		this->ref();
+		this->SetShape(s);
+	}
+	;
+	void SetShape(const Shape &s)
+	{
+		this->Clear();
+		for (unsigned int i = 0; i < s.size(); i++) {
+			ranks.push_back(Dataset(s[i]));
+		}
+	}
+
+	RankedDataset()
+	{
+		this->ref();
+	}
+	;
+	Dim_t Dim()
+	{
+		return ranks.size() - 1;
+	}
+	;
+
+	UnTypedPtr GetVoidPointer(const string &attr, Dim_t d) const;
+
+	Dataset::IntIterator BeginInt(Dim_t d, const string &attr);
+	Dataset::IntIterator EndInt(Dim_t d, const string &attr);
+	Dataset::FloatIterator BeginFloat(Dim_t d, const string &attr);
+	Dataset::FloatIterator EndFloat(Dim_t d, const string &attr);
+
+	void Clear()
+	{
+		ranks.clear();
+	}
+
+	void CoerceScheme(Dim_t k, Scheme *sch, size_t sz = 0)
+	{
+		assert((unsigned )k < ranks.size());
+		return ranks[k].CoerceScheme(*sch, sz);
+	}
+	;
+
+	void AddAttribute(Dim_t k, Array *data)
+	{
+		if (k >= (Dim_t) ranks.size()) {
+			Fatal("Attempt to add an attribute at rank %i for rankeddataset of dim %i", k, this->Dim());
+		}
+		ranks[k].AddAttribute(data);
+	}
+	;
+	void Bind(Dim_t k, Array *data)
+	{
+		this->AddAttribute(k, data);
+	}
+	;
+	void unBind(Dim_t k, const string &attr)
+	{
+		this->RemoveAttribute(k, attr);
+	}
+	;
+
+	void unref();
+	Scheme GetScheme(Dim_t k) const
+	{
+		if (k < (Dim_t) ranks.size())
+			return ranks[k].GetScheme();
+		else
+			return Scheme();
+	}
+	;
+
+	bool IsAttribute(Dim_t k, const string &attr)
+	{
+		if (k < (Dim_t) ranks.size())
+			return ranks[k].IsAttribute(attr);
+		else
+			return false;
+	}
+	;
+	Array *GetAttribute(Dim_t k, const string &attr)
+	{
+		if (k < (Dim_t) ranks.size())
+			return ranks[k].GetAttribute(attr);
+		else {
+			Fatal("Request for an attribute at rank %i on a gridfield with max rank %i", k, ranks.size() - 1);
+			return NULL;
+		}
+	}
+	;
+	void RemoveAttribute(Dim_t k, const string &attr)
+	{
+		if (k >= (Dim_t) ranks.size()) return;
+		ranks[k].RemoveAttribute(GetAttribute(k, attr));
+	}
+	;
+
+	UnTypedPtr GetAttributeValue(Dim_t k, const string &attr, idx i)
+	{
+		return ranks[k].GetAttributeVal(attr, i);
+	}
+	;
+	float GetFloatAttributeValue(Dim_t k, const string &attr, idx i)
+	{
+		return *(float *) ranks[k].GetAttributeVal(attr, i);
+	}
+	;
+	float GetIntAttributeValue(Dim_t k, const string &attr, idx i)
+	{
+		return *(int *) ranks[k].GetAttributeVal(attr, i);
+	}
+	;
+
+	size_t Arity(Dim_t k)
+	{
+		if (k < (Dim_t) ranks.size())
+			return ranks[k].Arity();
+		else
+			return 0;
+	}
+	;
+	size_t Size(Dim_t k)
+	{
+		if (k < (Dim_t) ranks.size())
+			return ranks[k].Size();
+		else
+			return 0;
+	}
+	;
+	Dim_t MaxRank() const
+	{
+		return ranks.size() - 1;
+	}
+	;
+
+	void Apply(const string &expr, Dim_t d);
+
+	void GetDataset(Dim_t d, const string &attrs, Dataset &Result);
+	const Dataset &GetDataset(Dim_t d) const
+	{
+		if (d < (Dim_t) ranks.size())
+			return ranks[d];
+		else
+			return empty;
+	}
+	;
+	void Zip(Dim_t d, const Dataset &D);
+
+	void PrintTo(ostream &os, int indent) const;
+
+private:
+	Dataset empty;
+	vector<Dataset> ranks;
 };
 
+} // namespace GF
+
 #endif /*_RANKEDDATASET_H */
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/refrestrict.cc gridfields/clib/src/refrestrict.cc
--- tag/gridfieldsclib-0.7/src/refrestrict.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/refrestrict.cc	2014-05-16 22:57:00.786725198 +0200
@@ -1,23 +1,28 @@
+#include "config_gridfields.h"
+
 #include "gridfield.h"
 #include "refrestrict.h"
 #include "expr.h"
 #include "ordmap.h"
 #include "subgridordmap.h"
 
-void RefRestrictOp::Execute() {
-  this->PrepareForExecution();
-  SubgridOrdMap *ordmap = new SubgridOrdMap(GF->GetGrid());
+namespace GF {
 
-  Result = RestrictOp::Restrict(this->expr, this->k, this->GF);
-  Result->GetGrid()->setReferent((OrdMap *) ordmap);
-}
+void RefRestrictOp::Execute()
+{
+	this->PrepareForExecution();
+	SubgridOrdMap *ordmap = new SubgridOrdMap(GF->GetGrid());
 
-GridField *RefRestrictOp::Restrict(const string &expr, Dim_t k, GridField *GF) {
-  GridField *result = RestrictOp::Restrict( expr, k, GF );
-  SubgridOrdMap *ordmap = new SubgridOrdMap( GF->GetGrid() );
-  result->GetGrid()->setReferent( ordmap );
-  return result;
+	Result = RestrictOp::Restrict(this->expr, this->k, this->GF);
+	Result->GetGrid()->setReferent((OrdMap *) ordmap);
 }
 
+GridField *RefRestrictOp::Restrict(const string &expr, Dim_t k, GridField *GF)
+{
+	GridField *result = RestrictOp::Restrict(expr, k, GF);
+	SubgridOrdMap *ordmap = new SubgridOrdMap(GF->GetGrid());
+	result->GetGrid()->setReferent(ordmap);
+	return result;
+}
 
-
+} // namespace GF
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/refrestrict.h gridfields/clib/src/refrestrict.h
--- tag/gridfieldsclib-0.7/src/refrestrict.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/refrestrict.h	2014-05-16 22:57:00.760058532 +0200
@@ -1,11 +1,17 @@
-
 #include "restrict.h"
 
-class RefRestrictOp : public RestrictOp {
+namespace GF {
+
+class RefRestrictOp: public RestrictOp {
 public:
-  RefRestrictOp(const string &expr, Dim_t k, GridFieldOperator *GF) : RestrictOp(expr, k, GF) {};
-  void Execute();
-  static GridField *Restrict(const string &expr, Dim_t k, GridField *GF);
+	RefRestrictOp(const string &expr, Dim_t k, GridFieldOperator *GF) :
+			RestrictOp(expr, k, GF)
+	{
+	}
+	;
+	void Execute();
+	static GridField *Restrict(const string &expr, Dim_t k, GridField *GF);
 
 };
 
+} // namespace GF
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/remesh.cc gridfields/clib/src/remesh.cc
--- tag/gridfieldsclib-0.7/src/remesh.cc	1970-01-01 01:00:00.000000000 +0100
+++ gridfields/clib/src/remesh.cc	2014-05-16 22:57:00.750058533 +0200
@@ -0,0 +1,546 @@
+#include "gridfield.h"
+#include "array.h"
+#include "remesh.h"
+#include "apply.h"
+#include "expr.h"
+#include "timing.h"
+#include "RTree.h"
+#include "assignments.h"
+#include "triangulate.h"
+using namespace std;
+using namespace Assign;
+using namepsace GF {
+
+	RemeshOp::RemeshOp(string attrx,string attry,GridField * Gnew, GridFieldOperator *op)
+	: UnaryGridFieldOperator(op),Gnew(Gnew),attry(attry),attrx(attrx)
+	{
+	}
+
+	void RemeshOp::Execute() {
+		this->PrepareForExecution();
+		Remesh(this->attrx,this->attry, this->GF,this->Gnew);
+
+	}
+
+	RTree<CellId, double, 2> RemeshOp::constructtree(Array* xs,Array* ys,vector< vector<int> > nodess) {
+		RTree<CellId, double, 2> tree;
+		double xp,yp;
+		double min[2];
+		double max[2];
+		vector<double>a;
+
+		for (int j=0; j<nodess.size(); j++) {
+			a.reserve(nodess.at(j).size());
+			xp = xs->getValfloat(nodess.at(j).at(0));
+			yp = ys->getValfloat(nodess.at(j).at(0));
+			min[0]=xp;
+			min[1]=yp;
+			max[0]=xp;
+			max[1]=yp;
+			for (int k1=1;k1<nodess.at(j).size();k1++)
+			{   xp = xs->getValfloat(nodess.at(j).at(k1));
+				yp = ys->getValfloat(nodess.at(j).at(k1));
+				a.push_back(nodess.at(j).at(k1));
+				if (xp < min[0]) min[0] = xp;
+				if (xp > max[0]) max[0] = xp;
+				if (yp < min[1]) min[1] = yp;
+				if (yp > max[1]) max[1] = yp;}
+			tree.Insert(min, max, j+1); // Note, all values including zero are fine in this version
+
+		}
+		return tree;
+	}
+
+	bool RemeshOp::point_inside_polygon(double x,double y,CPolygon poly) {
+
+		int n=3,c=0;
+		bool inside =0;
+		double xinters;
+		double p1x= poly.getpoint(1).getx(1);
+		double p1y=poly.getpoint(1).getx(2);
+		for (int j=2;j<=n+1;j++) {
+			int i;i=j-1;i=i%n;i=i+1;
+
+			double p2x= poly.getpoint(i).getx(1);
+			double p2y=poly.getpoint(i).getx(2);
+			if (y-min(p1y,p2y)>1.0e-15) {
+				if (y - max(p1y,p2y)<=1.0e-15) {
+					if ((x- max(p1x,p2x))<= 1.0e-15) {
+						if (abs(p1y - p2y)>1.0e-15) {
+							xinters = (y-p1y)*(p2x-p1x)/(p2y-p1y)+p1x;}
+						if (abs(p1x-p2x)<1.0e-15 || x-xinters<= 1.0e-15) {
+							inside = 1-inside;}
+					}
+				}
+			}
+			p1x= p2x;
+			p1y= p2y;
+
+		}
+		c=inside;
+
+		return c;
+	}
+
+	bool RemeshOp::inside(vector<double>& p,vector<double>& plane) //test if points are inside or outside polygon
+	{
+		double d=p[0]*plane[0]+p[1]*plane[1];
+		bool bin;
+		if (d>= plane[2])
+		{   bin=1;}
+		else
+		{   bin=0;}
+
+		return bin;}
+
+	void RemeshOp::clip(vector<double>& c,vector<double>& p1,vector<double>& p2,vector<double>& plane) {
+		c.clear();
+		double d1=p1[0]*plane[0]+p1[1]*plane[1]-plane[2];
+		double d2=p2[0]*plane[0]+p2[1]*plane[1]-plane[2];
+		double t=(0.0-d1)/(d2-d1);
+		c.reserve(2);
+		c.push_back(p1[0] + t*(p2[0]-p1[0]));
+		c.push_back(p1[1] + t*(p2[1]-p1[1]));
+	}
+
+	int RemeshOp::intersect(CPolygon* pout,CPolygon* pin,CPolygon* pin2)
+	{   CPolygon* pout1=new CPolygon;CPolygon* pout2=new CPolygon;CPolygon* pout3=new CPolygon;
+		double xin1[2],xin2[2];
+
+		xin1[0]=pin2->getpoint(1).getx(1);
+		xin1[1]=pin2->getpoint(1).getx(2);
+
+		xin2[0]=pin2->getpoint(2).getx(1);
+		xin2[1]=pin2->getpoint(2).getx(2);
+
+		polyclip(pout1,pin,xin1,xin2);
+
+		xin1[0]=pin2->getpoint(2).getx(1);
+		xin1[1]=pin2->getpoint(2).getx(2);
+
+		xin2[0]=pin2->getpoint(3).getx(1);
+		xin2[1]=pin2->getpoint(3).getx(2);
+
+		if (pout1->Numpts>0)
+		{
+
+			polyclip(pout2,pout1,xin1,xin2);}
+
+		xin1[0]=pin2->getpoint(3).getx(1);
+		xin1[1]=pin2->getpoint(3).getx(2);
+
+		xin2[0]=pin2->getpoint(1).getx(1);
+		xin2[1]=pin2->getpoint(1).getx(2);
+
+		if (pout2->Numpts>0)
+		{
+			polyclip(pout3,pout2,xin1,xin2);
+		}
+
+		int outcheck=0;
+		if (pout3->Numpts>=3) {
+
+			double Pm1[2];
+			Pm1[0]=0.0;
+			Pm1[1]=0.0;
+			for (int i1=1;i1<=pout3->Numpts;i1++)
+			{
+				Pm1[0]=pout3->getpoint(i1).getx(1)/(pout3->Numpts)+Pm1[0];
+				Pm1[1]=pout3->getpoint(i1).getx(2)/(pout3->Numpts)+Pm1[1];
+
+			}
+
+			bool b=point_inside_polygon(Pm1[0],Pm1[1],*pin);
+			if(b) {outcheck=1;
+				pout->Numpts=0;
+				for (int i1=1;i1<=pout3->Numpts;i1++)
+				{
+					pout->addpoint(pout3->getpoint(i1));
+
+				}
+
+			}
+		}
+
+		delete pout1;delete pout2;delete pout3;
+		return outcheck;
+	}
+
+	void RemeshOp::polyclip(CPolygon* pout,CPolygon* pin,double x1[2],double x2[2])
+	{
+
+		vector<double> plane;
+		plane.reserve(3);
+
+		plane.push_back(x1[1]-x2[1]);
+		plane.push_back(x2[0]-x1[0]);
+		plane.push_back(x1[0]*plane[0]+x1[1]*plane[1]);
+
+		int n=pin->Numpts;
+		vector<double> s;
+		s.reserve(2);
+		s.push_back(pin->getpoint(n).getx(1));
+		s.push_back(pin->getpoint(n).getx(2));
+
+		vector<double> p;
+		vector<double> t;
+		t.reserve(2);
+		p.reserve(2);
+		int b;
+
+		for (int c1=1;c1<=n;c1++)
+		{
+			p.clear();
+			p.push_back(pin->getpoint(c1).getx(1));
+			p.push_back(pin->getpoint(c1).getx(2));
+
+			if (inside(p,plane)) {
+				if (inside(s,plane)) { // case 1
+					b=1;
+					{
+						Cgridpoint a;a.setgridpoint(p.at(0),p.at(1));
+						pout->addpoint(a);}
+				}
+				else { // case 4
+					b=2;
+					clip(t,s,p,plane);
+					double s1=t[0]-p[0];
+					double s2=t[1]-p[1];
+					if(sqrt(s1*s1+s2*s2)>1.0e-16) {
+
+						{   Cgridpoint a;a.setgridpoint(t.at(0),t.at(1));
+							pout->addpoint(a);
+
+							Cgridpoint a1;a1.setgridpoint(p.at(0),p.at(1));
+							pout->addpoint(a1);}
+					}
+					else {
+						{
+							Cgridpoint a;a.setgridpoint(t.at(0),t.at(1));
+							pout->addpoint(a);}
+					}
+				}
+			}
+			else {
+				if (inside(s,plane)) { // case 2
+					b=3;
+					clip(t,s,p,plane);
+					double s1=t[0]-s[0];
+					double s2=t[1]-s[1];
+					if(sqrt(s1*s1+s2*s2)>1.0e-16) {
+						{
+							Cgridpoint a;a.setgridpoint(t.at(0),t.at(1));
+							pout->addpoint(a);}
+					}
+				}
+			}
+			s.clear();
+			s.push_back(p.at(0));
+			s.push_back(p.at(1));
+
+		}
+
+	}
+
+	set<int> RemeshOp::constructintersection(RTree<CellId, double, 2>& tree,CPolygon& Tri) {
+		double x3, y3;
+		double coordsmin[2],coordsmax[2];
+		x3 = Tri.getpoint(1).getx(1);
+		y3 = Tri.getpoint(1).getx(2);
+		set<int> hits;
+		hits.clear();
+
+		coordsmin[0]=x3;
+		coordsmin[1]=y3;
+		coordsmax[0]=x3;
+		coordsmax[1]=y3;
+
+		for (int k1=2;k1<=3;k1++) {
+			x3 = Tri.getpoint(k1).getx(1);
+			y3 = Tri.getpoint(k1).getx(2);
+			if (x3 < coordsmin[0]) {coordsmin[0] = x3;}
+			if (x3 > coordsmax[0]) {coordsmax[0] = x3;}
+			if (y3 < coordsmin[1]) {coordsmin[1] = y3;}
+			if (y3 > coordsmax[1]) {coordsmax[1] = y3;}
+		}
+
+		tree.Search(coordsmin, coordsmax, TestCallback,&hits);
+		return hits;
+	}
+
+	extern "C" void dgesv_(const int *N, const int *nrhs, double *A, const int *lda, int
+			*ipiv, double *b, const int *ldb, int *info);
+
+	GridField* RemeshOp::Remesh(const string &attrx,const string &attry,GridField *GF, GridField* Gnew) {
+
+		int nums1=0;
+		GridField *Out;
+		Grid *G = GF->GetGrid();
+		string name = "r" + G->name;
+		Array* xa=GF->GetAttribute(0, attrx);
+		Array* ya=GF->GetAttribute(0, attry);
+		Array* ua=GF->GetAttribute(0, "u");
+		vector<double> u=ua->makeArrayf();
+//  vector<double> x=xa->makeArrayf();
+
+		Array* xab=Gnew->GetAttribute(0, attrx);
+		Array* yab=Gnew->GetAttribute(0, attry);
+//  vector<double> x1=xab->makeArrayf();
+//  vector<double> y1=yab->makeArrayf();
+//  vector<double> y=ya->makeArrayf();
+		int n=xa->size(), n1=xab->size();
+		vector<double> Mt(n1*n1);vector<double> bvec(n1);
+
+		for (int m=1;m<=n1;m++)
+		for(int n=1;n<=n1;n++)
+		{   Mt[n1*(n-1)+m-1]=0.0;}
+		for (int m=1;m<=n1;m++) {bvec[m-1]=0.0;}
+		CellArray* Inb=(CellArray*)(Gnew->GetGrid()->getKCells(2));
+		CellArray* In = (CellArray*)(GF->GetGrid()->getKCells(2));
+		vector< vector<int> > nodes2=Inb->makeArrayInts();
+		vector< vector<int> > nodes=In->makeArrayInts();
+//  vector< vector<double> >nodesx;
+//  vector< vector<double> >nodesy;
+
+		int tot=0;
+		RTree<CellId, double, 2> tree=constructtree(xa,ya,nodes);
+
+		vector< vector<int> > index;
+		vector< vector<double> > ptot;
+
+		Vector2dVector spts;
+		spts.push_back(Vector2d(0.000000000000000,0.000000000000000 ));
+		spts.push_back(Vector2d(0.125959254959390,0.125959254959390 ));
+		spts.push_back(Vector2d(-0.251918509918779,0.125959254959390 ));
+		spts.push_back(Vector2d(0.125959254959390,-0.251918509918779 ));
+		spts.push_back(Vector2d(-0.162764025581573,-0.162764025581573 ));
+		spts.push_back(Vector2d(0.325528051163147,-0.162764025581573 ));
+		spts.push_back(Vector2d(-0.162764025581573,0.325528051163147 ));
+		spts.push_back(Vector2d(-0.282786105016302,-0.282786105016302 ));
+		spts.push_back(Vector2d( 0.565572210032605,-0.282786105016302 ));
+		spts.push_back(Vector2d(-0.282786105016302, 0.565572210032605 ));
+		spts.push_back(Vector2d(-0.324938555923375,-0.070220503698695 ));
+		spts.push_back(Vector2d( -0.324938555923375,0.395159059622071 ));
+		spts.push_back(Vector2d( -0.070220503698695,-0.324938555923375 ));
+		spts.push_back(Vector2d( -0.070220503698695,0.395159059622071 ));
+		spts.push_back(Vector2d( 0.395159059622071,-0.324938555923375 ));
+		spts.push_back(Vector2d( 0.395159059622071,-0.070220503698695 ));
+
+		vector<double> wgts;
+		wgts.push_back(0.0721578038388935 );
+		wgts.push_back(0.0475458171336425 );
+		wgts.push_back(0.0475458171336425 );
+		wgts.push_back(0.0475458171336425 );
+		wgts.push_back(0.0516086852673590 );
+		wgts.push_back(0.0516086852673590 );
+		wgts.push_back(0.0516086852673590 );
+		wgts.push_back(0.0162292488115990 );
+		wgts.push_back(0.0162292488115990 );
+		wgts.push_back(0.0162292488115990 );
+		wgts.push_back(0.0136151570872175 );
+		wgts.push_back(0.0136151570872175 );
+		wgts.push_back(0.0136151570872175 );
+		wgts.push_back(0.0136151570872175 );
+		wgts.push_back(0.0136151570872175 );
+		wgts.push_back(0.0136151570872175 );
+
+		int mpoints=16;
+		for (int j=0; j<nodes2.size(); j++) {
+
+			Cgridpoint gpt1;
+			gpt1.setgridpoint(xab->getValfloat(nodes2.at(j).at(0)),yab->getValfloat(nodes2.at(j).at(0)));
+			double x2p1=xab->getValfloat(nodes2.at(j).at(0));
+			double y2p1=yab->getValfloat(nodes2.at(j).at(0));
+			Cgridpoint gpt2;
+			gpt2.setgridpoint(xab->getValfloat(nodes2.at(j).at(1)),yab->getValfloat(nodes2.at(j).at(1)));
+			double x2p2=xab->getValfloat(nodes2.at(j).at(1));double y2p2=yab->getValfloat(nodes2.at(j).at(1));
+			Cgridpoint gpt3;
+			gpt3.setgridpoint(xab->getValfloat(nodes2.at(j).at(2)),yab->getValfloat(nodes2.at(j).at(2)));
+			double x2p3=xab->getValfloat(nodes2.at(j).at(2));double y2p3=yab->getValfloat(nodes2.at(j).at(2));
+			vector<Cgridpoint> a1;a1.reserve(3);a1.push_back(gpt1);a1.push_back(gpt2);a1.push_back(gpt3);
+
+			CPolygon* gTri2=new CPolygon(3,a1);
+
+			int n21=nodes2.at(j).at(0);
+			double c2a1= (x2p2*y2p3 - x2p3*y2p2)/(x2p3*y2p1 - x2p2*y2p1 + x2p2*y2p3 - x2p3*y2p2 + x2p1*(y2p2 - y2p3));
+			double c2a2= (y2p2 - y2p3)/(x2p3*y2p1 - x2p2*y2p1 + x2p2*y2p3 - x2p3*y2p2 + x2p1*(y2p2 - y2p3));
+			double c2a3= -(x2p2 - x2p3)/(x2p3*y2p1 - x2p2*y2p1 + x2p2*y2p3 - x2p3*y2p2 + x2p1*(y2p2 - y2p3));
+			int n22=nodes2.at(j).at(1);
+			double c2b1= (x2p3*y2p1 - x2p1*y2p3)/(x2p3*y2p1 - x2p2*y2p1 + x2p2*y2p3 - x2p3*y2p2 + x2p1*(y2p2 - y2p3));
+			double c2b2= (y2p3 - y2p1)/(x2p3*y2p1 - x2p2*y2p1 + x2p2*y2p3 - x2p3*y2p2 + x2p1*(y2p2 - y2p3));
+			double c2b3= -(x2p3 - x2p1)/(x2p3*y2p1 - x2p2*y2p1 + x2p2*y2p3 - x2p3*y2p2 + x2p1*(y2p2 - y2p3));
+			int n23=nodes2.at(j).at(2);
+			double c2c1= (x2p1*y2p2 - x2p2*y2p1)/(x2p3*y2p1 - x2p2*y2p1 + x2p2*y2p3 - x2p3*y2p2 + x2p1*(y2p2 - y2p3));
+			double c2c2= (y2p1 - y2p2)/(x2p3*y2p1 - x2p2*y2p1 + x2p2*y2p3 - x2p3*y2p2 + x2p1*(y2p2 - y2p3));
+			double c2c3= -(x2p1 - x2p2)/(x2p3*y2p1 - x2p2*y2p1 + x2p2*y2p3 - x2p3*y2p2 + x2p1*(y2p2 - y2p3));
+
+			set<int>::iterator it;
+			set<int> hits=constructintersection(tree,*gTri2);
+			int indic=0;
+			for (it=hits.begin(); it!=hits.end(); it++)
+			{   tot=tot+1;
+
+				Cgridpoint gpoint1;
+				double x1p1=xa->getValfloat(nodes.at(*it-1).at(0));double y1p1=ya->getValfloat(nodes.at(*it-1).at(0));
+				gpoint1.setgridpoint(xa->getValfloat(nodes.at(*it-1).at(0)),ya->getValfloat(nodes.at(*it-1).at(0)));
+
+				Cgridpoint gpoint2;
+				gpoint2.setgridpoint(xa->getValfloat(nodes.at(*it-1).at(1)),ya->getValfloat(nodes.at(*it-1).at(1)));
+				double x1p2=xa->getValfloat(nodes.at(*it-1).at(1));double y1p2=ya->getValfloat(nodes.at(*it-1).at(1));
+
+				Cgridpoint gpoint3;
+				gpoint3.setgridpoint(xa->getValfloat(nodes.at(*it-1).at(2)),ya->getValfloat(nodes.at(*it-1).at(2)));
+				double x1p3=xa->getValfloat(nodes.at(*it-1).at(2));double y1p3=ya->getValfloat(nodes.at(*it-1).at(2));
+				vector<Cgridpoint> b4;b4.reserve(3);b4.push_back(gpoint1);b4.push_back(gpoint2);b4.push_back(gpoint3);
+				CPolygon* gTri1=new CPolygon(3,b4);vector<Cgridpoint> a2;CPolygon* gTriout=new CPolygon(0,a2);
+
+				int n11=nodes.at(*it-1).at(0);
+				double c1a1= (x1p2*y1p3 - x1p3*y1p2)/(x1p3*y1p1 - x1p2*y1p1 + x1p2*y1p3 - x1p3*y1p2 + x1p1*(y1p2 - y1p3));
+				double c1a2= (y1p2 - y1p3)/(x1p3*y1p1 - x1p2*y1p1 + x1p2*y1p3 - x1p3*y1p2 + x1p1*(y1p2 - y1p3));
+				double c1a3= -(x1p2 - x1p3)/(x1p3*y1p1 - x1p2*y1p1 + x1p2*y1p3 - x1p3*y1p2 + x1p1*(y1p2 - y1p3));
+				int n12=nodes.at(*it-1).at(1);
+				double c1b1= (x1p3*y1p1 - x1p1*y1p3)/(x1p3*y1p1 - x1p2*y1p1 + x1p2*y1p3 - x1p3*y1p2 + x1p1*(y1p2 - y1p3));
+				double c1b2= (y1p3 - y1p1)/(x1p3*y1p1 - x1p2*y1p1 + x1p2*y1p3 - x1p3*y1p2 + x1p1*(y1p2 - y1p3));
+				double c1b3= -(x1p3 - x1p1)/(x1p3*y1p1 - x1p2*y1p1 + x1p2*y1p3 - x1p3*y1p2 + x1p1*(y1p2 - y1p3));
+				int n13=nodes.at(*it-1).at(2);
+				double c1c1= (x1p1*y1p2 - x1p2*y1p1)/(x1p3*y1p1 - x1p2*y1p1 + x1p2*y1p3 - x1p3*y1p2 + x1p1*(y1p2 - y1p3));
+				double c1c2= (y1p1 - y1p2)/(x1p3*y1p1 - x1p2*y1p1 + x1p2*y1p3 - x1p3*y1p2 + x1p1*(y1p2 - y1p3));
+				double c1c3= -(x1p1 - x1p2)/(x1p3*y1p1 - x1p2*y1p1 + x1p2*y1p3 - x1p3*y1p2 + x1p1*(y1p2 - y1p3));
+
+				int b=intersect( gTriout,gTri2,gTri1);
+
+				if(b==1)
+				{   indic=1; nums1=nums1+1;
+
+					Vector2dVector a;
+					for(int k1=1;k1<=gTriout->Numpts;k1++)
+					{   a.reserve(a.size()+1);
+						a.push_back(Vector2d(gTriout->getpoint(k1).getx(1),gTriout->getpoint(k1).getx(2)));
+					}
+
+					Vector2dVector result;
+					//  Invoke the triangulator to triangulate this polygon.
+					Triangulate::Process(a,result);
+
+					// print out the results.
+					int tcount = result.size()/3;
+					//if(tcount>0){indic=1;}
+					for (int i=0; i<tcount; i++)
+					{
+						const Vector2d &p1 = result[i*3+0];
+						const Vector2d &p2 = result[i*3+1];
+						const Vector2d &p3 = result[i*3+2];
+						const double x1 = p1.GetX();
+						const double y1 = p1.GetY();
+						const double x2 = p2.GetX();
+						const double y2 = p2.GetY();
+						const double x3 = p3.GetX();
+						const double y3 = p3.GetY();
+
+						const double xc = (x1+x2+x3)/3.0;
+						const double yc = (y1+y2+y3)/3.0;
+
+//coefficients for equations corresponding to nodes in the source
+
+						double intD1=0.0;//elements of target vs. source
+						double intD2=0.0;
+						double intD3=0.0;
+
+						double intT1=0.0;//elements of target vs. target
+						double intT2=0.0;
+						double intT3=0.0;
+
+						for (int m=1; m<=mpoints; m++)
+						{
+							double s = spts.at(m-1).GetX();
+							double t = spts.at(m-1).GetY();
+
+							double xinter= xc + (x2-x1)*s + (x3-x1)*t;
+							double yinter= yc + (y2-y1)*s + (y3-y1)*t;
+
+							bvec[n21]=bvec[n21]+u.at(n11)*wgts.at(m-1)*(c1a1+xinter*c1a2+yinter*c1a3)*(c2a1+xinter*c2a2+yinter*c2a3); //elements of target vs. source
+							bvec[n21]=bvec[n21]+u.at(n12)*wgts.at(m-1)*(c1b1+xinter*c1b2+yinter*c1b3)*(c2a1+xinter*c2a2+yinter*c2a3);
+							bvec[n21]=bvec[n21]+u.at(n13)*wgts.at(m-1)*(c1c1+xinter*c1c2+yinter*c1c3)*(c2a1+xinter*c2a2+yinter*c2a3);
+
+							bvec[n22]=bvec[n22]+u.at(n11)*wgts.at(m-1)*(c1a1+xinter*c1a2+yinter*c1a3)*(c2b1+xinter*c2b2+yinter*c2b3);//elements of target vs. source
+							bvec[n22]=bvec[n22]+u.at(n12)*wgts.at(m-1)*(c1b1+xinter*c1b2+yinter*c1b3)*(c2b1+xinter*c2b2+yinter*c2b3);
+							bvec[n22]=bvec[n22]+u.at(n13)*wgts.at(m-1)*(c1c1+xinter*c1c2+yinter*c1c3)*(c2b1+xinter*c2b2+yinter*c2b3);
+
+							bvec[n23]=bvec[n23]+u.at(n11)*wgts.at(m-1)*(c1a1+xinter*c1a2+yinter*c1a3)*(c2c1+xinter*c2c2+yinter*c2c3);//elements of target vs. source
+							bvec[n23]=bvec[n23]+u.at(n12)*wgts.at(m-1)*(c1b1+xinter*c1b2+yinter*c1b3)*(c2c1+xinter*c2c2+yinter*c2c3);
+							bvec[n23]=bvec[n23]+u.at(n13)*wgts.at(m-1)*(c1c1+xinter*c1c2+yinter*c1c3)*(c2c1+xinter*c2c2+yinter*c2c3);
+
+							Mt[n1*n21+n21]+=wgts.at(m-1)*(c2a1+xinter*c2a2+yinter*c2a3)*(c2a1+xinter*c2a2+yinter*c2a3);//elements of target vs. target
+							Mt[n1*n21+n22]+=wgts.at(m-1)*(c2b1+xinter*c2b2+yinter*c2b3)*(c2a1+xinter*c2a2+yinter*c2a3);
+							Mt[n1*n21+n23]+=wgts.at(m-1)*(c2c1+xinter*c2c2+yinter*c2c3)*(c2a1+xinter*c2a2+yinter*c2a3);
+
+							Mt[n1*n22+n21]+=wgts.at(m-1)*(c2a1+xinter*c2a2+yinter*c2a3)*(c2b1+xinter*c2b2+yinter*c2b3);
+							Mt[n1*n22+n22]+=wgts.at(m-1)*(c2b1+xinter*c2b2+yinter*c2b3)*(c2b1+xinter*c2b2+yinter*c2b3);
+							Mt[n1*n22+n23]+=wgts.at(m-1)*(c2c1+xinter*c2c2+yinter*c2c3)*(c2b1+xinter*c2b2+yinter*c2b3);
+
+							Mt[n1*n23+n21]+=wgts.at(m-1)*(c2a1+xinter*c2a2+yinter*c2a3)*(c2c1+xinter*c2c2+yinter*c2c3);
+							Mt[n1*n23+n22]+=wgts.at(m-1)*(c2b1+xinter*c2b2+yinter*c2b3)*(c2c1+xinter*c2c2+yinter*c2c3);
+							Mt[n1*n23+n23]+=wgts.at(m-1)*(c2c1+xinter*c2c2+yinter*c2c3)*(c2c1+xinter*c2c2+yinter*c2c3);
+
+							double intT2=intT2+wgts.at(m-1)*(c2b1+xinter*c2b2+yinter*c2a3)*(c2b1+xinter*c2b2+yinter*c2b3);
+							double intT3=intT3+wgts.at(m-1)*(c2c1+xinter*c2c2+yinter*c2a3)*(c2c1+xinter*c2c2+yinter*c2c3);
+
+						}
+
+						//printf("Triangle %d => (%0.0e,%0.0e) (%0.0e,%0.0e) (%0.0e,%0.0e)\n",i+1,p1.GetX(),p1.GetY(),p2.GetX(),p2.GetY(),p3.GetX(),p3.GetY());
+					}
+
+				}
+
+				delete gTri1;delete gTriout;
+			}
+			delete gTri2;
+
+		}
+
+		int info;
+		int k=1;
+		vector<int> ipiv(n1);
+
+		for (int m=1;m<=n1;m++)
+		{   for(int n=1;n<=n1;n++)
+			{   double a=Mt[n1*(n-1)+m-1]-Mt[n1*(m-1)+n-1];
+
+			}
+		}
+
+		ofstream arrayData("data/test2/array2.txt"); // File Creation(on C drive)
+
+		for(int k=0;k<n1*n1;k++)
+		{
+			arrayData<<Mt[k]<<endl; //Outputs array to txtFile
+		}
+		vector<double> a1(Mt);
+		vector<double> b1(bvec);
+
+		dgesv_(&n1, &k, &*Mt.begin(), &n1, &*ipiv.begin(), &*bvec.begin(), &n1, &info);
+		cout<<"info= "<<info<<endl;
+		Array* u2=new Array("u",FLOAT,n1);
+
+		float placehold;
+		for(int loop=0;loop<n1;loop++)
+		{   placehold=bvec.at(loop);
+			u2->set(loop,placehold);
+
+		}
+		Gnew->Bind(0,u2);
+		double eps = 0.;double eps2 = 0.;
+		for (int i = 0; i < n1; ++i)
+		{
+			double sum = 0.;
+			for (int j = 0; j < n1; ++j)
+			sum += a1[i + j*n1]*bvec[j];
+			eps += fabs(b1[i] - sum);
+			eps2 +=b1[i]-bvec[i];
+		}
+		cout << "check is " << eps<<" "<<eps2 << endl;
+
+		return Gnew;
+	}
+
+}
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/remesh.h gridfields/clib/src/remesh.h
--- tag/gridfieldsclib-0.7/src/remesh.h	1970-01-01 01:00:00.000000000 +0100
+++ gridfields/clib/src/remesh.h	2014-05-16 22:57:00.750058533 +0200
@@ -0,0 +1,142 @@
+#ifndef _RemeshOP_H
+#define _RemeshOP_H
+
+#include "expr.h"
+#include "gridfieldoperator.h"
+#include "assignments.h"
+#include "RTree.h"
+
+using namespace GF {
+
+	class RemeshOp : public UnaryGridFieldOperator {
+	public:
+		RemeshOp(string attrx,string attry, GridField * Gnew,GridFieldOperator *op);
+		GridField* Gnew;
+		string attry;
+		string attrx;
+		void Execute();
+
+		class Cgridpoint {
+		public:
+			double px;
+			double py;
+			double pz;
+			//Cgridpoint(){px=new double;py=new double;pz=new double;}
+			void setgridpoint(double x,double y)
+			{ //px=new double;py=new double;pz=new double;
+				px=x;
+				py=y;
+				pz=0.0;
+			}
+
+			double getx(int k)
+			{   double pval;
+				if(k==1)
+				{   pval=px;}
+				else if(k==2)
+				{   pval=py;}
+				else {pval=666.0;}
+				return pval;}
+		}gpoint;
+
+		class CTriangle {
+		public:
+			Cgridpoint p1;
+			Cgridpoint p2;
+			Cgridpoint p3;
+			//CTriangle(){p1=new Cgridpoint;p2=new Cgridpoint;p3=new Cgridpoint;}
+
+			void setpointtriangle(Cgridpoint p11,Cgridpoint p12,Cgridpoint p13)
+			{ //p1=new Cgridpoint;p2=new Cgridpoint;p3=new Cgridpoint;
+				p1=p11;
+				p2=p12;
+				p3=p13;
+			}
+
+			Cgridpoint getpoint(int k)
+			{   Cgridpoint pval;
+				if(k==1)
+				{   pval=p1;}
+				else if(k==2)
+				{   pval=p2;}
+				else if(k==3)
+				{   pval=p3;}
+				else if(k==4)
+				{   pval=p1;}
+				else {cout<<"Devil in the details "<<endl;pval=p3;}
+				return pval;}
+
+		}gtriangle;
+
+		class CPolygon {
+		public:
+			int Numpts;
+			CPolygon(int n,vector<Cgridpoint> p13)
+			{
+				for(int i=1;i<=n;i++)
+				{   points.reserve(points.size()+1);points.push_back(p13.at(i-1));}
+				Numpts=n;
+			}
+			vector<Cgridpoint> points;
+
+			CPolygon() {Numpts=0;points.reserve(0);}
+			void setpointpolygon(int n,vector<Cgridpoint> p13)
+			{
+				for(int i=1;i<=n;i++)
+				{   points.reserve(points.size()+1);points.push_back(p13.at(i-1));}
+				Numpts=n;
+			}
+
+			Cgridpoint getpoint(int k)
+			{   Cgridpoint pval;
+				if(k<=Numpts)
+				{   pval=points.at(k-1);}
+				else {cout<<"Bad"<<endl;pval=points.at(Numpts+10);}
+				return pval;}
+
+			void addpoint(Cgridpoint p13)
+			{   Numpts=Numpts+1;Cgridpoint a;a.setgridpoint(p13.getx(1),p13.getx(2));
+				points.reserve(points.size()+1);points.push_back(a);}
+
+		}gpolygon;
+		RTree<CellId, double, 2> constructtree(Array* x1,Array* y1,vector< vector<int> > nodes2);
+		/* class CPolygon{
+		 public:
+		 int polysize;
+		 vector<Cgridpoint*>* Points=new vector<Cgridpoint*>;
+
+		 void setpointPolygon(int n,vector<Cgridpoint>)
+		 {
+		 polysize=n;
+		 for(int i=1
+		 }
+
+		 } gtriangle;*/
+		/*  void setEnvironment(GridField *t, Dim_t i, GridField *s, Dim_t j) {
+		 this->T=t;
+		 this->S=s;
+		 this->_i = i;
+		 this->_j = j;
+		 left.setEnvironment(t,i,s,j);
+		 right.setEnvironment(t,i,s,j);
+		 };*/
+		bool point_inside_polygon(double x,double y,CPolygon poly);
+
+		bool inside(vector<double>& p,vector<double>&);
+
+		void clip(vector<double>& c,vector<double>& p1,vector<double>& p2,vector<double>& plane);
+
+		void polyclip(CPolygon* pout,CPolygon* pin,double x1[2],double x2[2]);
+		int intersect(CPolygon* pout,CPolygon* pin,CPolygon* pin1);
+		GridField* Remesh(const string &attrx,const string &attry,GridField *GF,GridField* Gnew);
+		//vector< vector<double> > Remeshvec(const string &attrx,const string &attry,GridField *GF, GridField * &Gnew);
+
+		set<int> constructintersection(RTree<CellId, double, 2>& tree,CPolygon& Tri);
+	protected:
+
+	private:
+
+	};
+
+}
+#endif
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/restrict.cc gridfields/clib/src/restrict.cc
--- tag/gridfieldsclib-0.7/src/restrict.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/restrict.cc	2014-05-16 22:57:00.726725200 +0200
@@ -1,3 +1,5 @@
+#include "config_gridfields.h"
+
 #include "gridfield.h"
 #include "array.h"
 #include "restrict.h"
@@ -5,71 +7,77 @@
 #include "expr.h"
 #include "timing.h"
 
+namespace GF {
 
-RestrictOp::RestrictOp(string expr, Dim_t k, GridFieldOperator *op) 
- : UnaryGridFieldOperator(op), k(k), expr(expr) 
+RestrictOp::RestrictOp(string expr, Dim_t k, GridFieldOperator *op) :
+		UnaryGridFieldOperator(op), k(k), expr(expr)
 {
 }
 
-void RestrictOp::Execute() {
-  this->PrepareForExecution();
-  this->Result = Restrict(this->expr, this->k, this->GF);
-  /*
-  if (Result->isAttribute("salt") && Result->card() > 0)  {
-    cout << "size: " << Result->card() << endl;
-    //getchar();
-  }
-  */
+void RestrictOp::Execute()
+{
+	this->PrepareForExecution();
+	this->Result = Restrict(this->expr, this->k, this->GF);
+	/*
+	 if (Result->isAttribute("salt") && Result->card() > 0)  {
+	 cout << "size: " << Result->card() << endl;
+	 //getchar();
+	 }
+	 */
 }
 
-GridField *RestrictOp::Restrict(string expr, Dim_t k, GridField *GF) {
+GridField *RestrictOp::Restrict(string expr, Dim_t k, GridField *GF)
+{
 
-  GridField *Out;
-  Grid *G = GF->GetGrid();
-  string name = "r" + G->name;
-  Grid *outgrid;
-
-  if (k>GF->Dim()) {
-    // if k>dim, then the result is the empty grid
-    outgrid = new Grid(name, -1);
-  } else {
-  
-    GF->Apply("mask="+expr, k);
-  
-
-    int n = GF->Size(k);
-
-    bool kcellFilter[n];
- 
-    outgrid = new Grid(name, G->getdim());
-  
-    // build the subgrid
-    Dataset::FloatIterator fi;
-    Dataset::FloatIterator vstop = GF->EndFloat(k, "mask");
-    int i=0;
-    for (fi=GF->BeginFloat(k, "mask"); fi!=vstop; ++fi) {
-      kcellFilter[i++] = (bool) (*fi);
-    }
-    if (k==0) {
-      GF->grid->nodeFilter(outgrid, kcellFilter);
-    } else {
-      for (i=0; i <= GF->grid->getdim(); i++) {
-        if (i==k){
-          GF->grid->copyCells(outgrid, kcellFilter, i);
-        } else {
-          GF->grid->shareCells(outgrid, i);
-        }
-      }
-    }
-  }
-  
-  //now filter the data
-  Out = new GridField(outgrid);  
-  outgrid->unref();
-  GF->RemoveAttribute(k, "mask");
-  Out->RestrictAll(*GF);
+	GridField *Out;
+	Grid *G = GF->GetGrid();
+	string name = "r" + G->name;
+	Grid *outgrid;
+
+	if (k > GF->Dim()) {
+		// if k>dim, then the result is the empty grid
+		outgrid = new Grid(name, -1);
+	}
+	else {
+
+		GF->Apply("mask=" + expr, k);
+
+		int n = GF->Size(k);
+
+		bool kcellFilter[n];
+
+		outgrid = new Grid(name, G->getdim());
+
+		// build the subgrid
+		Dataset::FloatIterator fi;
+		Dataset::FloatIterator vstop = GF->EndFloat(k, "mask");
+		int i = 0;
+		for (fi = GF->BeginFloat(k, "mask"); fi != vstop; ++fi) {
+			kcellFilter[i++] = (bool) (*fi);
+		}
+		if (k == 0) {
+			GF->grid->nodeFilter(outgrid, kcellFilter);
+		}
+		else {
+			for (i = 0; i <= GF->grid->getdim(); i++) {
+				if (i == k) {
+					GF->grid->copyCells(outgrid, kcellFilter, i);
+				}
+				else {
+					GF->grid->shareCells(outgrid, i);
+				}
+			}
+		}
+	}
+
+	//now filter the data
+	Out = new GridField(outgrid);
+	outgrid->unref();
+	GF->RemoveAttribute(k, "mask");
+	Out->RestrictAll(*GF);
 
-  DEBUG << "Restrict(" << expr << ")" << endl;
-  return Out;
+	DEBUG << "Restrict(" << expr << ")" << endl;
+	return Out;
 }
 
+} // namespace GF
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/restrict.h gridfields/clib/src/restrict.h
--- tag/gridfieldsclib-0.7/src/restrict.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/restrict.h	2014-05-16 22:57:00.730058533 +0200
@@ -4,18 +4,22 @@
 #include "expr.h"
 #include "gridfieldoperator.h"
 
-class RestrictOp : public UnaryGridFieldOperator {
+namespace GF {
+
+class RestrictOp: public UnaryGridFieldOperator {
 public:
-  RestrictOp(string expr, Dim_t k, GridFieldOperator *op);
-  
-  void Execute();
-  
-  static GridField *Restrict(string expr, Dim_t k, GridField *GF);
+	RestrictOp(string expr, Dim_t k, GridFieldOperator *op);
+
+	void Execute();
+
+	static GridField *Restrict(string expr, Dim_t k, GridField *GF);
 protected:
-  Dim_t k;
-  string expr;
+	Dim_t k;
+	string expr;
 private:
- 
+
 };
 
+} // namespace GF
+
 #endif
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/scan.h gridfields/clib/src/scan.h
--- tag/gridfieldsclib-0.7/src/scan.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/scan.h	2014-05-16 22:57:00.780058532 +0200
@@ -3,19 +3,28 @@
 
 #include "gridfieldoperator.h"
 
-class ScanOp : public ZeroaryGridFieldOperator {
+namespace GF {
+
+class ScanOp: public ZeroaryGridFieldOperator {
 public:
-  ScanOp(string filename, long offset)  :
-    filename(filename), offset(offset)
-  {
-  };
-  
-  ScanOp() :filename(""), offset(0) {};
-  string filename;
-  long offset;
-  //virtual static GridField *Scan(string filename) = 0;
+	ScanOp(string filename, long offset) :
+			filename(filename), offset(offset)
+	{
+	}
+	;
+
+	ScanOp() :
+			filename(""), offset(0)
+	{
+	}
+	;
+	string filename;
+	long offset;
+	//virtual static GridField *Scan(string filename) = 0;
 private:
 
 };
 
+} // namespace GF
+
 #endif
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/scaninternal.cc gridfields/clib/src/scaninternal.cc
--- tag/gridfieldsclib-0.7/src/scaninternal.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/scaninternal.cc	2014-05-16 22:57:00.803391865 +0200
@@ -1,7 +1,10 @@
+#include "config_gridfields.h"
+
 #include "gridfield.h"
-extern "C" {
-#include "stdio.h"
-}
+#include <stdio.h>
+//extern "C" {
+//#include "stdio.h"
+//}
 #include "expr.h"
 #include "timing.h"
 #include <iostream>
@@ -14,180 +17,198 @@
 
 using namespace std;
 
-ScanInternal::ScanInternal(string fn, long offset) : ScanOp(fn, offset) {
-  this->bytestream = new ifstream(filename.c_str(), ios_base::binary | ios::in);
-}
+namespace GF {
 
-void ScanInternal::setFileName(char *fn) {
-  this->filename = string(fn);
-  delete this->bytestream;
-  this->bytestream = new ifstream(filename.c_str(), ios_base::binary | ios::in);
-  this->Update();
-}
-
-ScanInternal::ScanInternal(string rawbytes) {
-  this->bytestream = new istringstream(rawbytes, ios::binary | ios::in);
-}
-
-void ScanInternal::setRawBytes(string rawbytes) {
-  this->filename = "";
-  delete this->bytestream;
-  this->bytestream = new istringstream(rawbytes, ios::binary | ios::in);
-  this->Update();
-}
-
-void ScanInternal::Execute() {
-  //this->PrepareForExecution();
-  DEBUG << "ScanInternal Operator" << endl;
-  this->Result =  this->Scan(*this->bytestream);
-}
-
-GridField *ScanInternal::Scan(istream &str) {
-  /*
-   * internal representation:
-   *  magic : 'GFGRID'
-   *  gridnamelength : i
-   *  gridname : gridnamelength*(char : c)
-   *  dim : i
-   *  implicitflag : i
-   *  implicitflag==0 ? (
-   *    zerocellcount : i
-   *    zerocells : zerocellcount*(id : i)
-   *  ) ( 
-   *    zerocellcount : i
-   *  )
-   *  kcelldata : dim*(
-   *    kcellcount : i
-   *    kcells : kcellcount*(
-   *      size : i
-   *      nodes : size*(node : i)
-   *    )
-   */
-
-   
-   if (!str.good()) {
-     Fatal("Cannot read from stream. (not good())");
-   }
-   char magic[7] = "xxxxx\0";
-   str.read(magic, 6);
-   if (string(magic) != "GFGRID") {
-     Fatal("Scan target is not a grid: (%s)", magic);
-   }
-  
-   Grid *G = readGrid(str);
-   int k;(void)k;
-   //cout << k << endl;
-   DEBUG << "ScanInternal: Grid refcount before reading gridfield:" << G->refcount << endl;
-   GridField *GF = readGridField(G, str);
-   G->unref();
-   //GF->print();
-
-   return GF;
-}
-
-Grid *ScanInternal::readGrid(istream &f) {
-   //cout << "name :";
-   string name = readName(f);
-   //cout << name << endl;
-   
-   int dim;
-   f.read((char *) &dim, sizeof(int));
-   //cout << dim << endl;
-   Grid *G = new Grid(name, dim);
-
-   //read zerocells
-   int implicitflag;
-   f.read((char *) &implicitflag, sizeof(int));
-   int nodecount;
-   f.read((char *) &nodecount, sizeof(int));
-   DEBUG << nodecount << endl;
-   
-   AbstractCellArray *zerocells;
-   if (!implicitflag) {
-     Node *nodes = new Node[nodecount];
-     f.read((char *) nodes, nodecount*4);
-
-     zerocells = (AbstractCellArray *) new CellArray(nodes, nodecount, 1);
-   } else {
-     zerocells = (AbstractCellArray *) new Implicit0Cells(nodecount);
-   }
-
-   G->setKCells(zerocells, 0);
-
-   for (int i=1; i<=dim; i++) {
-     G->setKCells(readCellArray(f), i);
-   }
-     
-   return G;
-  }
-
-  GridField *ScanInternal::readGridField(Grid *G, istream &f) {
-    int k;
-    GridField *GF = new GridField(G);
-    for (int i=0; i<G->getdim(); i++) {
-    f.read((char *) &k, sizeof(int));
-    readDataset(GF, i, f);
-  }
-  return GF;
-}
-
-void ScanInternal::readDataset(GridField *GF, int k, istream &f) {
-   int arity;
-   Type t;
-   f.read((char *) &arity, sizeof(int));
-   //cout << "arity: " << arity << endl;
-   ArrayReader ar(&f);
-   Array *a;
-   for (int i=0; i<arity; ++i) {
-     string name = readName(f);
-     f.read((char *) &t, sizeof(Type));
-     
-     a = new Array(name, t, GF->Card(k));
-     ar.setOffset(f.tellg());
-     ar.Read(GF, k, a);
-     GF->Bind(k, a);
-     a->unref();
-     //a->print();
-   }
-}
-
-
-CellArray *ScanInternal::readCellArray(istream &f) {
-   int bytesize;
-   int size;
-   int s;(void)s;
-   
-   f.read((char *) &size, sizeof(int));
-   f.read((char *) &bytesize, sizeof(int)); 
-
-   if (size == 0) {
-     return new CellArray();
-   } 
-   
-   int *data = new int[bytesize];
-   f.read((char *) data, bytesize);
-
-   Node *nodes = new Node[bytesize];
-   for (int i=0; i<bytesize; i++) {
-     nodes[i] = data[i];
-   }
-
-   CellArray *ca = new CellArray(nodes, size);
-
-   delete [] data;
-
-   return ca;
-}
-
-string ScanInternal::readName(istream &f) {
-   int namesize=0;
-   f.read((char *) &namesize, sizeof(int));
-   //cout << "namesize: " << namesize << endl;
-   char *name = new char[namesize+1];
-   f.read(name, namesize);
-   name[namesize] = '\0';
-   string s(name);
-   //cout << s.c_str() << endl;
-   delete [] name;
-   return s;
+ScanInternal::ScanInternal(string fn, long offset) :
+		ScanOp(fn, offset)
+{
+	this->bytestream = new ifstream(filename.c_str(), ios_base::binary | ios::in);
+}
+
+void ScanInternal::setFileName(char *fn)
+{
+	this->filename = string(fn);
+	delete this->bytestream;
+	this->bytestream = new ifstream(filename.c_str(), ios_base::binary | ios::in);
+	this->Update();
+}
+
+ScanInternal::ScanInternal(string rawbytes)
+{
+	this->bytestream = new istringstream(rawbytes, ios::binary | ios::in);
+}
+
+void ScanInternal::setRawBytes(string rawbytes)
+{
+	this->filename = "";
+	delete this->bytestream;
+	this->bytestream = new istringstream(rawbytes, ios::binary | ios::in);
+	this->Update();
+}
+
+void ScanInternal::Execute()
+{
+	//this->PrepareForExecution();
+	DEBUG << "ScanInternal Operator" << endl;
+	this->Result = this->Scan(*this->bytestream);
+}
+
+GridField *ScanInternal::Scan(istream &str)
+{
+	/*
+	 * internal representation:
+	 *  magic : 'GFGRID'
+	 *  gridnamelength : i
+	 *  gridname : gridnamelength*(char : c)
+	 *  dim : i
+	 *  implicitflag : i
+	 *  implicitflag==0 ? (
+	 *    zerocellcount : i
+	 *    zerocells : zerocellcount*(id : i)
+	 *  ) (
+	 *    zerocellcount : i
+	 *  )
+	 *  kcelldata : dim*(
+	 *    kcellcount : i
+	 *    kcells : kcellcount*(
+	 *      size : i
+	 *      nodes : size*(node : i)
+	 *    )
+	 */
+
+	if (!str.good()) {
+		Fatal("Cannot read from stream. (not good())");
+	}
+	char magic[7] = "xxxxx\0";
+	str.read(magic, 6);
+	if (string(magic) != "GFGRID") {
+		Fatal("Scan target is not a grid: (%s)", magic);
+	}
+
+	Grid *G = readGrid(str);
+	int k;
+	(void) k;
+	//cout << k << endl;
+	DEBUG << "ScanInternal: Grid refcount before reading gridfield:" << G->refcount << endl;
+	GridField *GF = readGridField(G, str);
+	G->unref();
+	//GF->print();
+
+	return GF;
+}
+
+Grid *ScanInternal::readGrid(istream &f)
+{
+	//cout << "name :";
+	string name = readName(f);
+	//cout << name << endl;
+
+	int dim;
+	f.read((char *) &dim, sizeof(int));
+	//cout << dim << endl;
+	Grid *G = new Grid(name, dim);
+
+	//read zerocells
+	int implicitflag;
+	f.read((char *) &implicitflag, sizeof(int));
+	int nodecount;
+	f.read((char *) &nodecount, sizeof(int));
+	DEBUG << nodecount << endl;
+
+	AbstractCellArray *zerocells;
+	if (!implicitflag) {
+		Node *nodes = new Node[nodecount];
+		f.read((char *) nodes, nodecount * 4);
+
+		zerocells = (AbstractCellArray *) new CellArray(nodes, nodecount, 1);
+	}
+	else {
+		zerocells = (AbstractCellArray *) new Implicit0Cells(nodecount);
+	}
+
+	G->setKCells(zerocells, 0);
+
+	for (int i = 1; i <= dim; i++) {
+		G->setKCells(readCellArray(f), i);
+	}
+
+	return G;
+}
+
+GridField *ScanInternal::readGridField(Grid *G, istream &f)
+{
+	int k;
+	GridField *GF = new GridField(G);
+	for (int i = 0; i < G->getdim(); i++) {
+		f.read((char *) &k, sizeof(int));
+		readDataset(GF, i, f);
+	}
+	return GF;
+}
+
+void ScanInternal::readDataset(GridField *GF, int k, istream &f)
+{
+	int arity;
+	Type t;
+	f.read((char *) &arity, sizeof(int));
+	//cout << "arity: " << arity << endl;
+	ArrayReader ar(&f);
+	Array *a;
+	for (int i = 0; i < arity; ++i) {
+		string name = readName(f);
+		f.read((char *) &t, sizeof(Type));
+
+		a = new Array(name, t, GF->Card(k));
+		ar.setOffset(f.tellg());
+		ar.Read(GF, k, a);
+		GF->Bind(k, a);
+		a->unref();
+		//a->print();
+	}
+}
+
+CellArray *ScanInternal::readCellArray(istream &f)
+{
+	int bytesize;
+	int size;
+	int s;
+	(void) s;
+
+	f.read((char *) &size, sizeof(int));
+	f.read((char *) &bytesize, sizeof(int));
+
+	if (size == 0) {
+		return new CellArray();
+	}
+
+	int *data = new int[bytesize];
+	f.read((char *) data, bytesize);
+
+	Node *nodes = new Node[bytesize];
+	for (int i = 0; i < bytesize; i++) {
+		nodes[i] = data[i];
+	}
+
+	CellArray *ca = new CellArray(nodes, size);
+
+	delete[] data;
+
+	return ca;
+}
+
+string ScanInternal::readName(istream &f)
+{
+	int namesize = 0;
+	f.read((char *) &namesize, sizeof(int));
+	//cout << "namesize: " << namesize << endl;
+	char *name = new char[namesize + 1];
+	f.read(name, namesize);
+	name[namesize] = '\0';
+	string s(name);
+	//cout << s.c_str() << endl;
+	delete[] name;
+	return s;
 }
+
+} // namespace GF
+
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/scaninternal.h gridfields/clib/src/scaninternal.h
--- tag/gridfieldsclib-0.7/src/scaninternal.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/scaninternal.h	2014-05-16 22:57:00.746725199 +0200
@@ -6,23 +6,27 @@
 #include <iostream>
 #include <sstream>
 
-class ScanInternal : public ScanOp {
+namespace GF {
+
+class ScanInternal: public ScanOp {
 public:
-  ScanInternal(string fn, long off);
-  ScanInternal(string rawbytes);
- 
-  void setFileName(char *fn);
-  void setRawBytes(string rawbytes);
-  void Execute();
-  static GridField *Scan(istream &s);
+	ScanInternal(string fn, long off);
+	ScanInternal(string rawbytes);
+
+	void setFileName(char *fn);
+	void setRawBytes(string rawbytes);
+	void Execute();
+	static GridField *Scan(istream &s);
 
 private:
-  static CellArray *readCellArray(istream &f);
-  static Grid *readGrid(istream &f);
-  static GridField *readGridField(Grid *G, istream &f);
-  static void readDataset(GridField *GF, int k, istream &f);
-  static string readName(istream &f);
-  std::istream *bytestream;
+	static CellArray *readCellArray(istream &f);
+	static Grid *readGrid(istream &f);
+	static GridField *readGridField(Grid *G, istream &f);
+	static void readDataset(GridField *GF, int k, istream &f);
+	static string readName(istream &f);
+	std::istream *bytestream;
 };
 
+} // namespace GF
+
 #endif
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/sift.cc gridfields/clib/src/sift.cc
--- tag/gridfieldsclib-0.7/src/sift.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/sift.cc	2014-05-16 22:57:00.823391864 +0200
@@ -1,57 +1,64 @@
+#include "config_gridfields.h"
+
 #include "sift.h"
 #include "timing.h"
 
+namespace GF {
 
-SiftOp::SiftOp(Dim_t k, GridFieldOperator *prev) 
-  : UnaryGridFieldOperator(prev), _k(k)
+SiftOp::SiftOp(Dim_t k, GridFieldOperator *prev) :
+		UnaryGridFieldOperator(prev), _k(k)
 {
-  // sift does not create a new gridfield, so 
-  // do not delete anything on destruction
-  //this->cleanup = false;
+	// sift does not create a new gridfield, so
+	// do not delete anything on destruction
+	//this->cleanup = false;
 }
-    
-void SiftOp::Execute() {
-  this->PrepareForExecution();
-  Result = this->Sift(this->_k, this->GF);
+
+void SiftOp::Execute()
+{
+	this->PrepareForExecution();
+	Result = this->Sift(this->_k, this->GF);
 }
 
-string SiftOp::newName(string gfname) {
+string SiftOp::newName(string gfname)
+{
 
-  string gname = "sift(" + gfname + ")";
-  return gname;
+	string gname = "sift(" + gfname + ")";
+	return gname;
 }
 
-GridField *SiftOp::Sift(Dim_t k, GridField *GF) {
+GridField *SiftOp::Sift(Dim_t k, GridField *GF)
+{
 
-  Grid *G = new Grid(GF->GetGrid()->name);
-  AbstractCellArray *kcells = GF->GetGrid()->getKCells(k);
-  G->setKCells(kcells, k);
-  kcells->ref();
-
-  if (k!=0) {
-
-    CellArray *newnodes = new CellArray();
-
-    set<Node> uniquenodes;
-
-    Cell *c;
-    for (size_t i=0; i<kcells->getsize(); i++) {
-      c = kcells->getCell(i);
-      const int n = c->getsize();
-      const Node *ns = c->getnodes();
-      for (int j=0; j<n; j++) {
-        uniquenodes.insert(ns[j]);
-      }
-    }
-    FOR(set<Node>, x, uniquenodes) {
-      Node c = *x;
-      newnodes->addCellNodes(&c, 1);
-    }
-    G->setKCells(newnodes, 0);
-  }
-
-  GridField *Out = new GridField(G);
-  Out->RestrictAll(GF);
-  return Out;
+	Grid *G = new Grid(GF->GetGrid()->name);
+	AbstractCellArray *kcells = GF->GetGrid()->getKCells(k);
+	G->setKCells(kcells, k);
+	kcells->ref();
+
+	if (k != 0) {
+
+		CellArray *newnodes = new CellArray();
+
+		set<Node> uniquenodes;
+
+		Cell *c;
+		for (size_t i = 0; i < kcells->getsize(); i++) {
+			c = kcells->getCell(i);
+			const int n = c->getsize();
+			const Node *ns = c->getnodes();
+			for (int j = 0; j < n; j++) {
+				uniquenodes.insert(ns[j]);
+			}
+		}
+		FOR(set<Node>, x, uniquenodes) {
+			Node c = *x;
+			newnodes->addCellNodes(&c, 1);
+		}
+		G->setKCells(newnodes, 0);
+	}
+
+	GridField *Out = new GridField(G);
+	Out->RestrictAll(GF);
+	return Out;
 }
 
+} // namespace GF
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/sift.h gridfields/clib/src/sift.h
--- tag/gridfieldsclib-0.7/src/sift.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/sift.h	2014-05-16 22:57:00.766725199 +0200
@@ -2,14 +2,17 @@
 #include "gridfield.h"
 #include "gridfieldoperator.h"
 
-class SiftOp : public UnaryGridFieldOperator {
- public:
-  SiftOp(Dim_t k, GridFieldOperator *prev);
-  void Execute(); 
-  static GridField *Sift(Dim_t k, GridField *Gf);
- private:
-  Dim_t _k;
-  static string newName(string gfname);
+namespace GF {
+
+class SiftOp: public UnaryGridFieldOperator {
+public:
+	SiftOp(Dim_t k, GridFieldOperator *prev);
+	void Execute();
+	static GridField *Sift(Dim_t k, GridField *Gf);
+private:
+	Dim_t _k;
+	static string newName(string gfname);
 
 };
 
+} // namespace GF
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/subgridordmap.h gridfields/clib/src/subgridordmap.h
--- tag/gridfieldsclib-0.7/src/subgridordmap.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/subgridordmap.h	2014-05-16 22:57:00.823391864 +0200
@@ -5,23 +5,33 @@
 #include "grid.h"
 #include "cellarray.h"
 
-class SubgridOrdMap : public OrdMap {
+namespace GF {
 
- public: 
-  SubgridOrdMap(Grid *basegrid) : OrdMap() { 
-    Base = basegrid;
-  };
-
-  virtual int getBaseSize(int d) {
-    return Base->ordmap->getBaseSize(d);
-  }
-  
-  virtual int getBaseOrd(Cell *c, int k) { 
-    return Base->ordmap->getBaseOrd(c, k);
-  };
- 
- private:
-  Grid *Base;
+class SubgridOrdMap: public OrdMap {
+
+public:
+	SubgridOrdMap(Grid *basegrid) :
+			OrdMap()
+	{
+		Base = basegrid;
+	}
+	;
+
+	virtual int getBaseSize(int d)
+	{
+		return Base->ordmap->getBaseSize(d);
+	}
+
+	virtual int getBaseOrd(Cell *c, int k)
+	{
+		return Base->ordmap->getBaseOrd(c, k);
+	}
+	;
+
+private:
+	Grid *Base;
 };
 
+} // namespace GF
+
 #endif /* _SUBGRIDORDMAP_H */
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/timing.cc gridfields/clib/src/timing.cc
--- tag/gridfieldsclib-0.7/src/timing.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/timing.cc	2014-05-16 22:57:00.783391865 +0200
@@ -1,15 +1,18 @@
+#include "config_gridfields.h"
+
 #include "timing.h"
 #include <math.h>
 #define DEC 10000
 
-float gettime(){
-  float ClockTicks;
-  struct tms Time;
-  float StarttimeSeconds;
-  (void)StarttimeSeconds;
-  times(&Time);  
+float gettime()
+{
+	float ClockTicks;
+	struct tms Time;
+	float StarttimeSeconds;
+	(void) StarttimeSeconds;
+	times(&Time);
+
+	ClockTicks = (double) sysconf(_SC_CLK_TCK);
 
-  ClockTicks = (double) sysconf(_SC_CLK_TCK);
-  
-  return floor(DEC*Time.tms_utime/ClockTicks)/DEC;
+	return floor(DEC * Time.tms_utime / ClockTicks) / DEC;
 }
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/tonetcdf.cc gridfields/clib/src/tonetcdf.cc
--- tag/gridfieldsclib-0.7/src/tonetcdf.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/tonetcdf.cc	2014-05-16 22:57:00.733391866 +0200
@@ -1,8 +1,10 @@
+#include "config_gridfields.h"
+
 #include "gridfield.h"
-extern "C" {
-#include "stdio.h"
+//extern "C" {
+#include <stdio.h>
 #include "elio.h"
-}
+//}
 #include "expr.h"
 #include "timing.h"
 #include <iostream>
@@ -23,669 +25,677 @@
 
 using namespace std;
 
-OutputNetCDFOp::OutputNetCDFOp(string fn, GridFieldOperator *op, 
-		               const Scheme f, const Scheme t)  
- : UnaryGridFieldOperator(op), filename(fn), fixed(f), time(t),  ncdf(NULL) {
-   GF = NULL;
-}
-
-void OutputNetCDFOp::SetDate(string ds) {
-  this->datestr = ds;
-}
-
-void OutputNetCDFOp::Execute() {
-  this->PrepareForExecution();
-  vector<GridField *> gfs;
-  //gfs.push_back(this->GF);
-  this->WriteNetCDF(gfs, this->GF, this->filename);
-  this->Result = this->GF;
-}
-
-NcType mapType(Type t) {NcType nyt=ncInt;
-  switch (t) {
-    case FLOAT:
-      nyt= ncFloat;
-      break;
-    case INT:
-      nyt= ncInt;
-      break;
-    default:
-      Fatal("Unknown Type encountered during netCDF emission");
-      exit(1);
-  }
-return nyt;
-}
-
-void OutputNetCDFOp::WriteTimeVars(GridFieldOperator *op, int index, float timestep) {
-  GridField *gf = op->getResult();
-  const Scheme &tsch = this->time;
-  Array *attr;
-  NcVar *var;
-  NcDim *nodedim = ncdf->get_dim("node");
-  if (!nodedim) {
-    Fatal("Unable to find dimension 'node'");
-  }
-  for (unsigned int k=0; k<tsch.size(); k++) {
-    attr = gf->GetAttribute(0, tsch.getAttribute(k));
-    //cout << attr->sname() <<", " << endl;
-    //attr->print();
-    var = ncdf->get_var(attr->sname().c_str());
-    //long *foo = var->edges();
-    var->set_cur(index, 0);
-    var->put((float *) attr->getVals(), 1, nodedim->size());
-  }
-  var = ncdf->get_var("time");
-  var->set_cur(index);
-  var->put(&timestep, 1);
-  ncdf->sync();
-}
-
-void addAttributes(NcVar *var, string datestr) {
-  DEBUG << "Adding attributes to " << var->name() << endl;
-  NcBool success = true;
-  if (strcmp(var->name(), "x") == 0) {
-     success &= var->add_att("units", "m");
-     success &= var->add_att("long_name", "X coordinate, in meters, epsg:32026, Oregon State Plane Index");
-  }
-  if (strcmp(var->name(), "y") == 0) {
-     success &= var->add_att("units", "m");
-     success &= var->add_att("long_name", "Y coordinate, in meters, epsg:32026, Oregon State Plane Index");
-  }
-  if (strcmp(var->name(), "time") == 0) {
-     success &= var->add_att("units", (string("seconds since ") + datestr).c_str());
-     success &= var->add_att("long_name", "Time in seconds from midnight");
-  }
-  if (strcmp(var->name(), "elev") == 0) {
-     success &= var->add_att("units", "m");
-     success &= var->add_att("positive", "up");
-     success &= var->add_att("long_name", "Water elevation in meters above Mean Sea Level");
-  }
-  if (strcmp(var->name(), "h") == 0) {
-     success &= var->add_att("units", "m");
-     success &= var->add_att("positive", "down");
-     success &= var->add_att("long_name", "bathymetry measured as meters below Mean Sea Level");
-  }
-  if (strcmp(var->name(), "b") == 0) {
-     success &= var->add_att("long_name", "Bottom index: level index indicating the lowest level that is still above the bathymetry; 0-based indexing");
-  }
-  if (strcmp(var->name(), "salt") == 0) {
-     success &= var->add_att("units", "psu");
-     success &= var->add_att("long_name", "Salinity in Practical Salinity Units");
-     success &= var->add_att("standard_name", "sea_water_salinity");
-     success &= var->add_att("missing_value", -99.0f);
-     success &= var->add_att("_FillValue", -99.0f);
-  }
-  if (strcmp(var->name(), "temp") == 0) {
-     success &= var->add_att("units", "C");
-     success &= var->add_att("long_name", "temperature in degrees celsius");
-     success &= var->add_att("missing_value", -99.0f);
-     success &= var->add_att("_FillValue", -99.0f);
-  }
-  if (strcmp(var->name(), "u") == 0) {
-     success &= var->add_att("units", "m/s");
-     success &= var->add_att("long_name", "velocity in the x direction in meters per second");
-     success &= var->add_att("missing_value", 0.0f);
-     success &= var->add_att("_FillValue", 0.0f);
-  }
-  if (strcmp(var->name(), "v") == 0) {
-     success &= var->add_att("units", "m/s");
-     success &= var->add_att("long_name", "velocity in the y direction in meters per second");
-     success &= var->add_att("missing_value", 0.0f);
-     success &= var->add_att("_FillValue", 0.0f);
-  }
-  if (strcmp(var->name(), "cell_vertices") == 0) {
-     success &= var->add_att("long_name", "conectivity table; 0-based indices");
-  }
-
-  if (strcmp(var->name(), "node") == 0) {
-     success &= var->add_att("long_name", "node number; 0-based");
-  }
-
-  if (!success) {
-    Fatal("Error adding attribute to netCDF variable");
-  }
-}
-
-void OutputNetCDFOp::WriteNetCDF(vector<GridField *> &, GridField *cross, 
-		                  const string &filename) {
-   GridField *gf = cross;
-   // only works for 2-D gridfields
-   assert(gf->Dim() == 2);
-   assert(gf->IsAttribute(0, "x"));
-   assert(gf->GetAttribute(0, "x")->type == FLOAT);
-   assert(gf->IsAttribute(0, "y"));
-   assert(gf->GetAttribute(0, "y")->type == FLOAT);
-   
-   vector<GridField *>::iterator p;
-   
-   ncdf = new NcFile(filename.c_str(), NcFile::Replace); 
-   
-   // write metadata
-   // add dims
-   NcDim *celldim = ncdf->add_dim("cell", gf->Card(2));
-   NcDim *nodedim = ncdf->add_dim("node", gf->Card(0));
- 
-   // an unlimited dimension
-   DEBUG << "Adding time dim in WriteNetCDF" << endl;
-   NcDim *timedim = ncdf->add_dim("time");
-
-   // maximum number of cell vertices
-   NcDim *cellvertexdim = ncdf->add_dim("nv", MAXCELLVERTEX);
-
-   // global attributes
-   ncdf->add_att("title", "Hindcast of Columbia River Physical Variables");
-   ncdf->add_att("institution", "STC Coastal Margin and Prediction");
-   ncdf->add_att("source", "ELCIRC");
-   if (this->datestr != "") {
-     ncdf->add_att("date", this->datestr.c_str());
-   }
-   
-   // write cells
-   NcVar *cellvertices = ncdf->add_var("cell_vertices", ncInt, celldim, cellvertexdim);
+namespace GF {
+
+OutputNetCDFOp::OutputNetCDFOp(string fn, GridFieldOperator *op, const Scheme f, const Scheme t) :
+		UnaryGridFieldOperator(op), filename(fn), fixed(f), time(t), ncdf(NULL)
+{
+	GF = NULL;
+}
+
+void OutputNetCDFOp::SetDate(string ds)
+{
+	this->datestr = ds;
+}
+
+void OutputNetCDFOp::Execute()
+{
+	this->PrepareForExecution();
+	vector<GridField *> gfs;
+	//gfs.push_back(this->GF);
+	this->WriteNetCDF(gfs, this->GF, this->filename);
+	this->Result = this->GF;
+}
+
+NcType mapType(Type t)
+{
+	NcType nyt = ncInt;
+	switch (t) {
+	case FLOAT:
+		nyt = ncFloat;
+		break;
+	case INT:
+		nyt = ncInt;
+		break;
+	default:
+		Fatal("Unknown Type encountered during netCDF emission");
+		exit(1);
+	}
+	return nyt;
+}
+
+void OutputNetCDFOp::WriteTimeVars(GridFieldOperator *op, int index, float timestep)
+{
+	GridField *gf = op->getResult();
+	const Scheme &tsch = this->time;
+	Array *attr;
+	NcVar *var;
+	NcDim *nodedim = ncdf->get_dim("node");
+	if (!nodedim) {
+		Fatal("Unable to find dimension 'node'");
+	}
+	for (unsigned int k = 0; k < tsch.size(); k++) {
+		attr = gf->GetAttribute(0, tsch.getAttribute(k));
+		//cout << attr->sname() <<", " << endl;
+		//attr->print();
+		var = ncdf->get_var(attr->sname().c_str());
+		//long *foo = var->edges();
+		var->set_cur(index, 0);
+		var->put((float *) attr->getVals(), 1, nodedim->size());
+	}
+	var = ncdf->get_var("time");
+	var->set_cur(index);
+	var->put(&timestep, 1);
+	ncdf->sync();
+}
+
+void addAttributes(NcVar *var, string datestr)
+{
+	DEBUG << "Adding attributes to " << var->name() << endl;
+	NcBool success = true;
+	if (strcmp(var->name(), "x") == 0) {
+		success &= var->add_att("units", "m");
+		success &= var->add_att("long_name", "X coordinate, in meters, epsg:32026, Oregon State Plane Index");
+	}
+	if (strcmp(var->name(), "y") == 0) {
+		success &= var->add_att("units", "m");
+		success &= var->add_att("long_name", "Y coordinate, in meters, epsg:32026, Oregon State Plane Index");
+	}
+	if (strcmp(var->name(), "time") == 0) {
+		success &= var->add_att("units", (string("seconds since ") + datestr).c_str());
+		success &= var->add_att("long_name", "Time in seconds from midnight");
+	}
+	if (strcmp(var->name(), "elev") == 0) {
+		success &= var->add_att("units", "m");
+		success &= var->add_att("positive", "up");
+		success &= var->add_att("long_name", "Water elevation in meters above Mean Sea Level");
+	}
+	if (strcmp(var->name(), "h") == 0) {
+		success &= var->add_att("units", "m");
+		success &= var->add_att("positive", "down");
+		success &= var->add_att("long_name", "bathymetry measured as meters below Mean Sea Level");
+	}
+	if (strcmp(var->name(), "b") == 0) {
+		success &=
+				var->add_att("long_name",
+						"Bottom index: level index indicating the lowest level that is still above the bathymetry; 0-based indexing");
+	}
+	if (strcmp(var->name(), "salt") == 0) {
+		success &= var->add_att("units", "psu");
+		success &= var->add_att("long_name", "Salinity in Practical Salinity Units");
+		success &= var->add_att("standard_name", "sea_water_salinity");
+		success &= var->add_att("missing_value", -99.0f);
+		success &= var->add_att("_FillValue", -99.0f);
+	}
+	if (strcmp(var->name(), "temp") == 0) {
+		success &= var->add_att("units", "C");
+		success &= var->add_att("long_name", "temperature in degrees celsius");
+		success &= var->add_att("missing_value", -99.0f);
+		success &= var->add_att("_FillValue", -99.0f);
+	}
+	if (strcmp(var->name(), "u") == 0) {
+		success &= var->add_att("units", "m/s");
+		success &= var->add_att("long_name", "velocity in the x direction in meters per second");
+		success &= var->add_att("missing_value", 0.0f);
+		success &= var->add_att("_FillValue", 0.0f);
+	}
+	if (strcmp(var->name(), "v") == 0) {
+		success &= var->add_att("units", "m/s");
+		success &= var->add_att("long_name", "velocity in the y direction in meters per second");
+		success &= var->add_att("missing_value", 0.0f);
+		success &= var->add_att("_FillValue", 0.0f);
+	}
+	if (strcmp(var->name(), "cell_vertices") == 0) {
+		success &= var->add_att("long_name", "conectivity table; 0-based indices");
+	}
+
+	if (strcmp(var->name(), "node") == 0) {
+		success &= var->add_att("long_name", "node number; 0-based");
+	}
+
+	if (!success) {
+		Fatal("Error adding attribute to netCDF variable");
+	}
+}
+
+void OutputNetCDFOp::WriteNetCDF(vector<GridField *> &, GridField *cross, const string &filename)
+{
+	GridField *gf = cross;
+	// only works for 2-D gridfields
+	assert(gf->Dim() == 2);
+	assert(gf->IsAttribute(0, "x"));
+	assert(gf->GetAttribute(0, "x")->type == FLOAT);
+	assert(gf->IsAttribute(0, "y"));
+	assert(gf->GetAttribute(0, "y")->type == FLOAT);
+
+	vector<GridField *>::iterator p;
+
+	ncdf = new NcFile(filename.c_str(), NcFile::Replace);
+
+	// write metadata
+	// add dims
+	NcDim *celldim = ncdf->add_dim("cell", gf->Card(2));
+	NcDim *nodedim = ncdf->add_dim("node", gf->Card(0));
+
+	// an unlimited dimension
+	DEBUG << "Adding time dim in WriteNetCDF" << endl;
+	NcDim *timedim = ncdf->add_dim("time");
+
+	// maximum number of cell vertices
+	NcDim *cellvertexdim = ncdf->add_dim("nv", MAXCELLVERTEX);
+
+	// global attributes
+	ncdf->add_att("title", "Hindcast of Columbia River Physical Variables");
+	ncdf->add_att("institution", "STC Coastal Margin and Prediction");
+	ncdf->add_att("source", "ELCIRC");
+	if (this->datestr != "") {
+		ncdf->add_att("date", this->datestr.c_str());
+	}
+
+	// write cells
+	NcVar *cellvertices = ncdf->add_var("cell_vertices", ncInt, celldim, cellvertexdim);
 //   int cd = celldim->size();
 //   int cv = cellvertexdim->size();
-   AbstractCellArray *ca = gf->GetGrid()->getKCells(2);
-   int *nodes; 
-   nodes = new int[MAXCELLVERTEX];
-   for (int i=0; i<celldim->size(); i++) {
-     Cell *c = ca->getCell(i);
-
-     assert(c->getsize() <= MAXCELLVERTEX);
-     
-     for (unsigned int j=0; j<c->getsize(); j++) {
-       nodes[j] = c->getnodes()[j]; 
-     }
-   
-     cellvertices->set_cur(i, 0);
-     
-     if (!cellvertices->put(nodes, 1, c->getsize())) {
-       Fatal("Error writing netCDF file");
-     }
-
-   }
-   delete [] nodes;
-   
-   // write nodes
-   NcVar *x = ncdf->add_var("x", ncFloat, nodedim);
-   addAttributes(x, this->datestr);
-   NcVar *y = ncdf->add_var("y", ncFloat, nodedim);
-   addAttributes(y, this->datestr);
-   
-   NcVar *time = ncdf->add_var("time", ncFloat, timedim);
-   DEBUG << "Date: " << this->datestr << endl;
-   addAttributes(time, this->datestr);
-
-
-   Array *attr;
-   NcVar *var;
-
-   // write fixed data
-   const Scheme &fsch = this->fixed;
-   for (unsigned int k=0; k<fsch.size(); k++) {
-     attr = gf->GetAttribute(0, fsch.getAttribute(k));
-     var = ncdf->add_var(attr->sname().c_str(), mapType(attr->type), nodedim);
-     addAttributes(var, this->datestr);
-   }
-
-   // prepare time-varying data
-   const Scheme &tsch = this->time;
-   string name;
-   for (unsigned int k=0; k<tsch.size(); k++) {
-     name = tsch.getAttribute(k);
-     var = ncdf->add_var(name.c_str(), mapType(tsch.getType(k)), timedim, nodedim);
-     addAttributes(var, this->datestr);
-   }
-
-   // write data last so we don't need to return to define mode
-   for (unsigned int k=0; k<fsch.size(); k++) {
-     attr = gf->GetAttribute(0, fsch.getAttribute(k));
-     var = ncdf->get_var(attr->sname().c_str());
-     switch (fsch.getType(k)) {
-      case INT:
-        var->put((int *) attr->getVals(), nodedim->size());
-        break;
-      case FLOAT:
-        var->put((float *) attr->getVals(), nodedim->size());
-        break;
-      default:
-        Fatal("Cannot convert object types to netcdf types for attribute %s", attr->sname().c_str());
-    }
-
-   }
-   
-   ncdf->sync();
-}
-
-
-/*   
-void OutputNetCDFOp::WriteNetCDF(vector<GridField *> &dims, GridField *cross, 
-		                  const string &filename) {
-   //put the dims
-   NcDim *d[dims.size()];
-   long counts[dims.size()];
-   int expectedcard = 1;
-   GridField *gf;
-   string attr;
-   
-   for (int i=0; i<dims.size(); i++) {
-      gf = dims[i];
-      attr = gf->getScheme()->getAttribute(0);
-      counts[i] = gf->card();
-      expectedcard *= gf->card();
-      d[i] = ncdf->add_dim(gf->getAttribute(attr.c_str())->name, gf->card());
-   }
-   
-   //put the dim variables
-   NcVar *var;
-   Array *a;
-   Scheme *sch;
-   NcType t;
-   long size;
-   for (int i=0; i<dims.size(); i++) {
-     gf = dims[i];
-     sch = gf->getScheme();
-     for (int j=0; j<gf->getarity(); j++) {
-       attr = sch->getAttribute(j);
-       cout << "(i,j)=" << i << ", " << j << " attr: " << attr << endl;
-       a = gf->getAttribute(attr.c_str());
-       size = (long) a->size;
-       OutputOp::putData(a, ncdf, &size, &(d[i]), 1); 
-     }
-   }
-   
-   //sanity check
-   if (cross->card() != expectedcard) {
-     Fatal("product grid cardinality different than product of component grid cardinalities. (%i, %i)", cross->card(), expectedcard);
-   }
-   
-   //put the cross variables
-   delete sch;
-   sch = cross->getScheme();
-   for (int j=0; j<cross->getarity(); j++) {
-     attr = sch->getAttribute(j);
-     cout << "(j)=" << ", " << j << " attr: " << attr << endl;
-     a = cross->getAttribute(attr.c_str());
-     OutputOp::putData(a, ncdf, counts, d, dims.size()); 
-   }
-   
-
-   delete ncdf;
-   
-  //Write each dim, using first attribute as 'name'
-  //
-  //Write each dim's arrays
-  //
-  //Write each cross attribute
+	AbstractCellArray *ca = gf->GetGrid()->getKCells(2);
+	int *nodes;
+	nodes = new int[MAXCELLVERTEX];
+	for (int i = 0; i < celldim->size(); i++) {
+		Cell *c = ca->getCell(i);
+
+		assert(c->getsize() <= MAXCELLVERTEX);
+
+		for (unsigned int j = 0; j < c->getsize(); j++) {
+			nodes[j] = c->getnodes()[j];
+		}
+
+		cellvertices->set_cur(i, 0);
+
+		if (!cellvertices->put(nodes, 1, c->getsize())) {
+			Fatal("Error writing netCDF file");
+		}
+
+	}
+	delete[] nodes;
+
+	// write nodes
+	NcVar *x = ncdf->add_var("x", ncFloat, nodedim);
+	addAttributes(x, this->datestr);
+	NcVar *y = ncdf->add_var("y", ncFloat, nodedim);
+	addAttributes(y, this->datestr);
+
+	NcVar *time = ncdf->add_var("time", ncFloat, timedim);
+	DEBUG << "Date: " << this->datestr << endl;
+	addAttributes(time, this->datestr);
+
+	Array *attr;
+	NcVar *var;
+
+	// write fixed data
+	const Scheme &fsch = this->fixed;
+	for (unsigned int k = 0; k < fsch.size(); k++) {
+		attr = gf->GetAttribute(0, fsch.getAttribute(k));
+		var = ncdf->add_var(attr->sname().c_str(), mapType(attr->type), nodedim);
+		addAttributes(var, this->datestr);
+	}
+
+	// prepare time-varying data
+	const Scheme &tsch = this->time;
+	string name;
+	for (unsigned int k = 0; k < tsch.size(); k++) {
+		name = tsch.getAttribute(k);
+		var = ncdf->add_var(name.c_str(), mapType(tsch.getType(k)), timedim, nodedim);
+		addAttributes(var, this->datestr);
+	}
+
+	// write data last so we don't need to return to define mode
+	for (unsigned int k = 0; k < fsch.size(); k++) {
+		attr = gf->GetAttribute(0, fsch.getAttribute(k));
+		var = ncdf->get_var(attr->sname().c_str());
+		switch (fsch.getType(k)) {
+		case INT:
+			var->put((int *) attr->getVals(), nodedim->size());
+			break;
+		case FLOAT:
+			var->put((float *) attr->getVals(), nodedim->size());
+			break;
+		default:
+			Fatal("Cannot convert object types to netcdf types for attribute %s", attr->sname().c_str());
+		}
+
+	}
+
+	ncdf->sync();
 }
-  */
 
-NcVar *OutputNetCDFOp::putData(Array *, NcFile *, long *, NcDim **, int ) {
+/*
+ void OutputNetCDFOp::WriteNetCDF(vector<GridField *> &dims, GridField *cross,
+ const string &filename) {
+ //put the dims
+ NcDim *d[dims.size()];
+ long counts[dims.size()];
+ int expectedcard = 1;
+ GridField *gf;
+ string attr;
+
+ for (int i=0; i<dims.size(); i++) {
+ gf = dims[i];
+ attr = gf->getScheme()->getAttribute(0);
+ counts[i] = gf->card();
+ expectedcard *= gf->card();
+ d[i] = ncdf->add_dim(gf->getAttribute(attr.c_str())->name, gf->card());
+ }
+
+ //put the dim variables
+ NcVar *var;
+ Array *a;
+ Scheme *sch;
+ NcType t;
+ long size;
+ for (int i=0; i<dims.size(); i++) {
+ gf = dims[i];
+ sch = gf->getScheme();
+ for (int j=0; j<gf->getarity(); j++) {
+ attr = sch->getAttribute(j);
+ cout << "(i,j)=" << i << ", " << j << " attr: " << attr << endl;
+ a = gf->getAttribute(attr.c_str());
+ size = (long) a->size;
+ OutputOp::putData(a, ncdf, &size, &(d[i]), 1);
+ }
+ }
+
+ //sanity check
+ if (cross->card() != expectedcard) {
+ Fatal("product grid cardinality different than product of component grid cardinalities. (%i, %i)", cross->card(), expectedcard);
+ }
+
+ //put the cross variables
+ delete sch;
+ sch = cross->getScheme();
+ for (int j=0; j<cross->getarity(); j++) {
+ attr = sch->getAttribute(j);
+ cout << "(j)=" << ", " << j << " attr: " << attr << endl;
+ a = cross->getAttribute(attr.c_str());
+ OutputOp::putData(a, ncdf, counts, d, dims.size());
+ }
+
+
+ delete ncdf;
+
+ //Write each dim, using first attribute as 'name'
+ //
+ //Write each dim's arrays
+ //
+ //Write each cross attribute
+ }
+ */
+
+NcVar *OutputNetCDFOp::putData(Array *, NcFile *, long *, NcDim **, int)
+{
 
 	/*
-  Type t = a->type;
-  NcVar *var = NULL;
-  UnTypedPtr p;
-  cout << a->name << ", " << a->size << endl; 
-  switch (t) {
-    case INT:
-      var = ncdf->add_var(a->name, ncInt, dimcount, (const NcDim **) d);
-      a->getData((int *) p);
-      var->put((int *) p, counts);
-      break;
-    case FLOAT:
-      var = ncdf->add_var(a->name, ncFloat, dimcount, (const NcDim **) d);
-      a->getData((float *) p);
-      var->put((float *) p, counts);
-      break;
-    default:
-      break;
-  }
-  return var;
-  */
-NcVar *var=NULL;
-return var;}
-/*
-void OutputNetCDFOp::writeName(string name, ofstream &f) {
-   int s = name.size();
-   f.write((char *) &s, sizeof(int));
-   f.write(name.c_str(), name.size());
+	 Type t = a->type;
+	 NcVar *var = NULL;
+	 UnTypedPtr p;
+	 cout << a->name << ", " << a->size << endl;
+	 switch (t) {
+	 case INT:
+	 var = ncdf->add_var(a->name, ncInt, dimcount, (const NcDim **) d);
+	 a->getData((int *) p);
+	 var->put((int *) p, counts);
+	 break;
+	 case FLOAT:
+	 var = ncdf->add_var(a->name, ncFloat, dimcount, (const NcDim **) d);
+	 a->getData((float *) p);
+	 var->put((float *) p, counts);
+	 break;
+	 default:
+	 break;
+	 }
+	 return var;
+	 */
+	NcVar *var = NULL;
+	return var;
 }
-*/
+/*
+ void OutputNetCDFOp::writeName(string name, ofstream &f) {
+ int s = name.size();
+ f.write((char *) &s, sizeof(int));
+ f.write(name.c_str(), name.size());
+ }
+ */
 
 /* Write a gridfield as a dimension variable or a regular variable*/
 
-OutputNetCDFVars::OutputNetCDFVars(
-NcFile *f, 
-const Scheme dims, 
-Dim_t d, 
-GridFieldOperator *Op,
-unsigned int i,  //index for the unbounded dimension
-float t // value for the unbounded dimension
-)
-: 
-UnaryGridFieldOperator(Op),  
-datestr(""),
-time(t),
-dimscheme(dims),
-index(i),
-ncdf(f), 
-dim(d)
-
-{
-   GF = NULL;
-};
-
-OutputNetCDFDim::OutputNetCDFDim
-(
-  NcFile *f, 
-  Dim_t d, 
-  string dn, 
-  GridFieldOperator *Op
-) : UnaryGridFieldOperator(Op), 
-
-    datestr(""),
-    basedimname(dn),
-    ncdf(f), 
-    dim(d)
-{
-   GF = NULL;
-};
-
-void OutputNetCDFVars::Execute() {
-  this->PrepareForExecution();
-  DEBUG << "Exporting gridfield as Vars" << endl;
-
-  GridField *gf = this->GF->getResult();
-  const Scheme &dsch = this->dimscheme;
-
-  //Array *attr;
-  NcVar *var;
-  const NcDim **vdims = new const NcDim *[dsch.size()+1];
-  int sz = 1;
-  // Dims are in reverse order in C and C++.  Record dimension is "first"
-  for (unsigned int k=0; k<dsch.size(); k++) {
-    int r = dsch.size() - k;
-    string a = dsch.getAttribute(k);
-    
-    if (HasDim(ncdf, a.c_str())) {
-      vdims[r] = ncdf->get_dim(a.c_str());
-    } else {
-      Fatal("Unable to find dimension %s in netcdf file", a.c_str());
-    }
-    sz *= vdims[r]->size();
-    DEBUG << "DIM: " << vdims[r]->name() << ", " << vdims[r]->size() << endl;
-  }
-  
-  // we always include a time dimension
-  // an unlimited dimension
-
-  NcDim *timedim;
-  if (HasDim(ncdf, "time")) {
-    // if it already has a time dimension, do nothing.
-    DEBUG << "Getting time dim" << endl;
-    timedim = ncdf->get_dim("time");
-  } else {
-    DEBUG << "Adding time dim" << endl;
-    timedim = ncdf->add_dim("time");
-    DEBUG << "Adding time var" << endl;
-    // We always add a time var
-    NcVar *nctime = ncdf->add_var("time", ncFloat, timedim);
-    DEBUG << "Date: " << this->datestr << endl;
-    addAttributes(nctime, this->datestr);
-  }
-
-  // record dimension is "first"
-  vdims[0] = timedim;
-  //for (int i=0; i<dsch.size()+1; i++) {
+OutputNetCDFVars::OutputNetCDFVars(NcFile *f, const Scheme dims, Dim_t d, GridFieldOperator *Op, unsigned int i, //index for the unbounded dimension
+		float t // value for the unbounded dimension
+		) :
+		UnaryGridFieldOperator(Op), datestr(""), time(t), dimscheme(dims), index(i), ncdf(f), dim(d)
+
+{
+	GF = NULL;
+}
+;
+
+OutputNetCDFDim::OutputNetCDFDim(NcFile *f, Dim_t d, string dn, GridFieldOperator *Op) :
+		UnaryGridFieldOperator(Op),
+
+		datestr(""), basedimname(dn), ncdf(f), dim(d)
+{
+	GF = NULL;
+}
+;
+
+void OutputNetCDFVars::Execute()
+{
+	this->PrepareForExecution();
+	DEBUG << "Exporting gridfield as Vars" << endl;
+
+	GridField *gf = this->GF->getResult();
+	const Scheme &dsch = this->dimscheme;
+
+	//Array *attr;
+	NcVar *var;
+	const NcDim **vdims = new const NcDim *[dsch.size() + 1];
+	int sz = 1;
+	// Dims are in reverse order in C and C++.  Record dimension is "first"
+	for (unsigned int k = 0; k < dsch.size(); k++) {
+		int r = dsch.size() - k;
+		string a = dsch.getAttribute(k);
+
+		if (HasDim(ncdf, a.c_str())) {
+			vdims[r] = ncdf->get_dim(a.c_str());
+		}
+		else {
+			Fatal("Unable to find dimension %s in netcdf file", a.c_str());
+		}
+		sz *= vdims[r]->size();
+		DEBUG << "DIM: " << vdims[r]->name() << ", " << vdims[r]->size() << endl;
+	}
+
+	// we always include a time dimension
+	// an unlimited dimension
+
+	NcDim *timedim;
+	if (HasDim(ncdf, "time")) {
+		// if it already has a time dimension, do nothing.
+		DEBUG << "Getting time dim" << endl;
+		timedim = ncdf->get_dim("time");
+	}
+	else {
+		DEBUG << "Adding time dim" << endl;
+		timedim = ncdf->add_dim("time");
+		DEBUG << "Adding time var" << endl;
+		// We always add a time var
+		NcVar *nctime = ncdf->add_var("time", ncFloat, timedim);
+		DEBUG << "Date: " << this->datestr << endl;
+		addAttributes(nctime, this->datestr);
+	}
+
+	// record dimension is "first"
+	vdims[0] = timedim;
+	//for (int i=0; i<dsch.size()+1; i++) {
 //    cout << vdims[i]->name() << endl;
-  //}
+	//}
 
-  DEBUG << "Record dim: ";
-  NcDim *d = ncdf->rec_dim();
-  DEBUG << d->name() << endl;
-  
-  var = ncdf->get_var("time");
-  var->set_cur(index);
-  var->put(&time, 1);
-  ncdf->sync();
-
-  const Scheme &tsch = gf->GetScheme(this->dim);
-  for (unsigned int k=0; k<tsch.size(); k++) {
-    Array *attr = gf->GetAttribute(this->dim, tsch.getAttribute(k));
-    if (attr->size() != sz) {
-      Fatal("Cardinality %i does not match product of dimension sizes %i", attr->size(), sz);
-    }
-
-    if (!HasVar(ncdf, attr->sname().c_str())) {
-      DEBUG << "Adding var " << attr->sname() << endl;
-      NcVar *var = ncdf->add_var(attr->sname().c_str(), mapType(attr->type), dsch.size()+1, vdims);
-      addAttributes(var, this->datestr);
+	DEBUG << "Record dim: ";
+	NcDim *d = ncdf->rec_dim();
+	DEBUG << d->name() << endl;
+
+	var = ncdf->get_var("time");
+	var->set_cur(index);
+	var->put(&time, 1);
+	ncdf->sync();
+
+	const Scheme &tsch = gf->GetScheme(this->dim);
+	for (unsigned int k = 0; k < tsch.size(); k++) {
+		Array *attr = gf->GetAttribute(this->dim, tsch.getAttribute(k));
+		if (attr->size() != sz) {
+			Fatal("Cardinality %i does not match product of dimension sizes %i", attr->size(), sz);
+		}
+
+		if (!HasVar(ncdf, attr->sname().c_str())) {
+			DEBUG << "Adding var " << attr->sname() << endl;
+			NcVar *var = ncdf->add_var(attr->sname().c_str(), mapType(attr->type), dsch.size() + 1, vdims);
+			addAttributes(var, this->datestr);
 
 //    DEBUG << "Putting data " << endl;
 //    var->set_cur(index, 0);
-      long *edges = var->edges();
-/*  
-    int d = var->num_dims();
-    for (int i=0; i<d; i++) {
-      DEBUG << edges[i] << ", " << vdims[i]->size()  << endl;
-    }
-*/
-      DEBUG << "Putting data " << sz << endl;
-    switch (attr->type) {
-      case INT:
-        var->put((int *) attr->getVals(), edges);
-        break;
-      case FLOAT:
-        var->put((float *) attr->getVals(), edges);
-        break;
-      default:
-        Fatal("Cannot convert object types to netcdf types for attribute %s", attr->sname().c_str());
-    }
-
-    }
-  }
-
-  ncdf->sync();
- 
-  this->Result = this->GF;
-};
-
-void OutputNetCDFDim::WriteCells(AbstractCellArray *ca, Dim_t d) {
-  GridField *gf = GF->getResult();
-
-  DEBUG << "writing Cells" << endl;
-  // Compute maximum number of cell vertices
-  unsigned int maxcellsize = 0;
-  for (unsigned int i=0; i<ca->getsize(); i++) { 
-     Cell *c = ca->getCell(i);
-     if (maxcellsize < c->getsize()) maxcellsize = c->getsize();
-  }
-
-  DEBUG << "adding cell dim of size " << gf->Card(d) << endl;
-  // add a dimension for the number of cells
-  NcDim *celldim = ncdf->add_dim("cell", gf->Card(d));
-
-  DEBUG << "adding cellsize dim of size " << maxcellsize << endl;
-  // add a dimension for the number of vertices in a cell
-  NcDim *cellvertexdim = ncdf->add_dim("nv", maxcellsize);
-
-  // write cells
-  DEBUG << "writing cells" << endl;
-  NcVar *cellvertices = ncdf->add_var("cell_vertices", ncInt, celldim, cellvertexdim);
+			long *edges = var->edges();
+			/*
+			 int d = var->num_dims();
+			 for (int i=0; i<d; i++) {
+			 DEBUG << edges[i] << ", " << vdims[i]->size()  << endl;
+			 }
+			 */DEBUG << "Putting data " << sz << endl;
+			switch (attr->type) {
+			case INT:
+				var->put((int *) attr->getVals(), edges);
+				break;
+			case FLOAT:
+				var->put((float *) attr->getVals(), edges);
+				break;
+			default:
+				Fatal("Cannot convert object types to netcdf types for attribute %s", attr->sname().c_str());
+			}
+
+		}
+	}
+
+	ncdf->sync();
+
+	this->Result = this->GF;
+}
+;
+
+void OutputNetCDFDim::WriteCells(AbstractCellArray *ca, Dim_t d)
+{
+	GridField *gf = GF->getResult();
+
+	DEBUG << "writing Cells" << endl;
+	// Compute maximum number of cell vertices
+	unsigned int maxcellsize = 0;
+	for (unsigned int i = 0; i < ca->getsize(); i++) {
+		Cell *c = ca->getCell(i);
+		if (maxcellsize < c->getsize()) maxcellsize = c->getsize();
+	}
+
+	DEBUG << "adding cell dim of size " << gf->Card(d) << endl;
+	// add a dimension for the number of cells
+	NcDim *celldim = ncdf->add_dim("cell", gf->Card(d));
+
+	DEBUG << "adding cellsize dim of size " << maxcellsize << endl;
+	// add a dimension for the number of vertices in a cell
+	NcDim *cellvertexdim = ncdf->add_dim("nv", maxcellsize);
+
+	// write cells
+	DEBUG << "writing cells" << endl;
+	NcVar *cellvertices = ncdf->add_var("cell_vertices", ncInt, celldim, cellvertexdim);
 
 //  int cd = celldim->size();
 //  int cv = cellvertexdim->size();
-  int *nodes;
+	int *nodes;
+
+	nodes = new int[maxcellsize];
+
+	for (int i = 0; i < celldim->size(); i++) {
+		Cell *c = ca->getCell(i);
+
+		assert(c->getsize() <= maxcellsize);
+
+		for (unsigned int j = 0; j < c->getsize(); j++) {
+			nodes[j] = c->getnodes()[j];
+		}
+
+		cellvertices->set_cur(i, 0);
+
+		if (!cellvertices->put(nodes, 1, c->getsize())) {
+			Fatal("Error writing netCDF file");
+		}
+
+	}
+	delete[] nodes;
+}
 
-  nodes = new int[maxcellsize];
+bool HasVar(NcFile *ncdf, const string varname)
+{
+	for (int i = 0; i < ncdf->num_vars(); i++) {
+		NcVar *var = ncdf->get_var(i);
+		if (string(var->name()) == varname) {
+			return 1;
+		}
+	}
+	return 0;
+}
+
+bool HasDim(NcFile *ncdf, const string dimname)
+{
+	NcDim *nodedim;
+	int i = 0;
+	DEBUG << "_" << endl;
+	for (; i < ncdf->num_dims(); i++) {
+		nodedim = ncdf->get_dim(i);
+		DEBUG << "|" << nodedim->name() << endl;
+		if (string(nodedim->name()) == dimname) break;
+	}
+	if (i == ncdf->num_dims()) {
+		return 0;
+	}
+	else {
+		return 1;
+	}
+}
+
+bool HasAttr(NcFile *ncdf, const string attr)
+{
+	DEBUG << "Has attr " << attr << "? ";
+	for (int i = 0; i < ncdf->num_atts(); i++) {
+		NcAtt *a = ncdf->get_att(i);
+		if (string(a->name()) == (attr)) {
+			DEBUG << "yes" << endl;
+			return 1;
+		}
+	}
+	DEBUG << "no" << endl;
+	return 0;
+}
+
+void OutputNetCDFDim::Execute()
+{
+	this->PrepareForExecution();
+	GridField *gf = GF->getResult();
 
-  for (int i=0; i<celldim->size(); i++) {
-    Cell *c = ca->getCell(i);
+	const Scheme &nodescheme = gf->GetScheme(0);
+	const Scheme &cellscheme = gf->GetScheme(this->dim);
+	NcDim *celldim = 0;
+
+	DEBUG << "Exporting gridfield as netcdf dims" << endl;
+	// add dims
+	if (this->dim > 0) {
+		AbstractCellArray *ca = gf->GetGrid()->getKCells(this->dim);
+		this->WriteCells(ca, this->dim);
+
+		// write cell vars
+		DEBUG << "Adding cell vars" << endl;
+		celldim = ncdf->get_dim("cell");
+		for (unsigned int k = 0; k < cellscheme.size(); k++) {
+			DEBUG << "Adding cell var " << cellscheme.getAttribute(k) << endl;
+			Array *attr = gf->GetAttribute(this->dim, cellscheme.getAttribute(k));
+			NcVar *var = ncdf->add_var(attr->sname().c_str(), mapType(attr->type), celldim);
+			addAttributes(var, this->datestr);
+		}
+	}
+
+	bool writenodes = 0;
+	NcDim *nodedim;
+	if (HasDim(ncdf, basedimname.c_str())) {
+		DEBUG << "Getting node dim " << basedimname.c_str() << endl;
+		nodedim = ncdf->get_dim(basedimname.c_str());
+	}
+	else {
+		DEBUG << "Adding node dim " << basedimname.c_str() << endl;
+		nodedim = ncdf->add_dim(basedimname.c_str(), gf->Card(0));
+		writenodes = 1;
+	}
+
+	DEBUG << "Adding attributes" << endl;
+	// global attributes
+	if (!HasAttr(ncdf, "title")) ncdf->add_att("title", "Hindcast of Columbia River Physical Variables");
+	if (!HasAttr(ncdf, "institution")) ncdf->add_att("institution", "STC Coastal Margin and Prediction");
+	if (!HasAttr(ncdf, "source")) ncdf->add_att("source", "SELFE");
+	if (this->datestr != "") {
+		if (!HasAttr(ncdf, "date")) ncdf->add_att("date", this->datestr.c_str());
+	}
+
+	if (writenodes) {
+		// write node vars
+		for (unsigned int k = 0; k < nodescheme.size(); k++) {
+			Array *attr = gf->GetAttribute(0, nodescheme.getAttribute(k));
+			assert(attr->size() == nodedim->size());
+			DEBUG << "Adding var for nodes " << attr->sname() << endl;
+			if (!HasVar(ncdf, attr->sname().c_str())) {
+				NcVar *var = ncdf->add_var(attr->sname().c_str(), mapType(attr->type), nodedim);
+				addAttributes(var, this->datestr);
+			}
+		}
+	}
+
+	DEBUG << "Writing node data" << endl;
+	if (writenodes) {
+		// write data last so we don't need to return to define mode
+		for (unsigned int k = 0; k < nodescheme.size(); k++) {
+			Array *attr = gf->GetAttribute(0, nodescheme.getAttribute(k));
+			NcVar *var = ncdf->get_var(attr->sname().c_str());
+			switch (attr->type) {
+			case INT:
+				var->put((int *) attr->getVals(), nodedim->size());
+				break;
+			case FLOAT:
+				var->put((float *) attr->getVals(), nodedim->size());
+				break;
+			default:
+				Fatal("Cannot convert object types to netcdf types for attribute %s", attr->sname().c_str());
+			}
+
+		}
+	}
+
+	if (this->dim > 0) {
+		// write data last so we don't need to return to define mode
+		for (unsigned int k = 0; k < cellscheme.size(); k++) {
+			Array *attr = gf->GetAttribute(0, cellscheme.getAttribute(k));
+			NcVar *var = ncdf->get_var(attr->sname().c_str());
+
+			switch (attr->type) {
+			case INT:
+				var->put((int *) attr->getVals(), celldim->size());
+				break;
+			case FLOAT:
+				var->put((float *) attr->getVals(), celldim->size());
+				break;
+			default:
+				Fatal("Cannot convert object types to netcdf types for attribute %s", attr->sname().c_str());
+			}
+
+		}
+	}
 
-    assert(c->getsize() <= maxcellsize);
+	ncdf->sync();
 
-    for (unsigned int j=0; j<c->getsize(); j++) {
-      nodes[j] = c->getnodes()[j];
-    }
-
-    cellvertices->set_cur(i, 0);
-
-    if (!cellvertices->put(nodes, 1, c->getsize())) {
-      Fatal("Error writing netCDF file");
-    }
-
-  }
-  delete [] nodes;
-}
-
-bool HasVar(NcFile *ncdf, const string varname) {
-  for (int i=0; i<ncdf->num_vars(); i++) {
-    NcVar *var = ncdf->get_var(i);
-    if (string(var->name()) == varname) {
-      return 1;
-    }
-  }
-  return 0;
-}
-
-bool HasDim(NcFile *ncdf, const string dimname) {
-  NcDim *nodedim;
-  int i=0;
-  DEBUG << "_" << endl;
-  for (; i<ncdf->num_dims(); i++) {
-    nodedim = ncdf->get_dim(i);
-    DEBUG << "|" << nodedim->name() << endl;
-    if (string(nodedim->name()) == dimname) break;
-  }
-  if (i==ncdf->num_dims()) {
-    return 0;
-  } else {
-    return 1;
-  }
-}
-
-bool HasAttr(NcFile *ncdf, const string attr) {
-  DEBUG << "Has attr " << attr << "? ";
-  for (int i=0; i<ncdf->num_atts(); i++) {
-    NcAtt *a = ncdf->get_att(i);
-    if (string(a->name()) == (attr)) {
-      DEBUG << "yes" << endl;
-      return 1;
-    }
-  }
-  DEBUG << "no" << endl;
-  return 0;
-}
-
-void OutputNetCDFDim::Execute() {
-  this->PrepareForExecution();
-  GridField *gf = GF->getResult();
-
-  const Scheme &nodescheme = gf->GetScheme(0);
-  const Scheme &cellscheme = gf->GetScheme(this->dim);
-  NcDim *celldim = 0;
-
-  DEBUG << "Exporting gridfield as netcdf dims" << endl;
-  // add dims
-  if (this->dim > 0) {
-    AbstractCellArray *ca = gf->GetGrid()->getKCells(this->dim);
-    this->WriteCells(ca, this->dim);
-
-    // write cell vars
-    DEBUG << "Adding cell vars" << endl;
-    celldim = ncdf->get_dim("cell");
-    for (unsigned int k=0; k<cellscheme.size(); k++) {
-      DEBUG << "Adding cell var " << cellscheme.getAttribute(k) << endl;
-      Array *attr = gf->GetAttribute(this->dim, cellscheme.getAttribute(k));
-      NcVar *var = ncdf->add_var(attr->sname().c_str(), mapType(attr->type), celldim);
-      addAttributes(var, this->datestr);
-    }
-  }
-
-  bool writenodes = 0;
-  NcDim *nodedim;
-  if (HasDim(ncdf, basedimname.c_str())) {
-    DEBUG << "Getting node dim " << basedimname.c_str() << endl;
-    nodedim = ncdf->get_dim(basedimname.c_str());
-  } else {
-    DEBUG << "Adding node dim " << basedimname.c_str() << endl;
-    nodedim = ncdf->add_dim(basedimname.c_str(), gf->Card(0));
-    writenodes = 1;
-  }
-
-  DEBUG << "Adding attributes" << endl;
-  // global attributes
-  if (!HasAttr(ncdf, "title")) ncdf->add_att("title", "Hindcast of Columbia River Physical Variables");
-  if (!HasAttr(ncdf, "institution")) ncdf->add_att("institution", "STC Coastal Margin and Prediction");
-  if (!HasAttr(ncdf, "source")) ncdf->add_att("source", "SELFE");
-  if (this->datestr != "") {
-    if (!HasAttr(ncdf, "date")) ncdf->add_att("date", this->datestr.c_str());
-  }
-
-  if (writenodes) {
-    // write node vars
-    for (unsigned int k=0; k<nodescheme.size(); k++) {
-      Array *attr = gf->GetAttribute(0, nodescheme.getAttribute(k));
-      assert(attr->size() == nodedim->size());
-      DEBUG << "Adding var for nodes " << attr->sname() << endl;
-      if (!HasVar(ncdf, attr->sname().c_str())) {
-        NcVar *var = ncdf->add_var(attr->sname().c_str(), mapType(attr->type), nodedim);
-        addAttributes(var, this->datestr);
-      }
-    }
-  }
-
-  DEBUG << "Writing node data" << endl;
-  if (writenodes) {
-    // write data last so we don't need to return to define mode
-    for (unsigned int k=0; k<nodescheme.size(); k++) {
-      Array *attr = gf->GetAttribute(0, nodescheme.getAttribute(k));
-      NcVar *var = ncdf->get_var(attr->sname().c_str());
-    switch (attr->type) {
-      case INT:
-        var->put((int *) attr->getVals(), nodedim->size());
-        break;
-      case FLOAT:
-        var->put((float *) attr->getVals(), nodedim->size());
-        break;
-      default:
-        Fatal("Cannot convert object types to netcdf types for attribute %s", attr->sname().c_str());
-    }
-
-    }
-  }
-
-  if (this->dim > 0) {
-    // write data last so we don't need to return to define mode
-    for (unsigned int k=0; k<cellscheme.size(); k++) {
-      Array *attr = gf->GetAttribute(0, cellscheme.getAttribute(k));
-      NcVar *var = ncdf->get_var(attr->sname().c_str());
-
-    switch (attr->type) {
-      case INT:
-        var->put((int *) attr->getVals(), celldim->size());
-        break;
-      case FLOAT:
-        var->put((float *) attr->getVals(), celldim->size());
-        break;
-      default:
-        Fatal("Cannot convert object types to netcdf types for attribute %s", attr->sname().c_str());
-    }
-
-    }
-  }
-
-  ncdf->sync();
-
-  DEBUG << "done" << endl;
-  this->Result = this->GF;
-};
-
-void OutputNetCDFDim::SetDate(string ds) {
-  this->datestr = ds;
-}
-
-void OutputNetCDFVars::SetDate(string ds) {
-  DEBUG << "Setting Date to " << ds << endl;
-  this->datestr = ds;
+	DEBUG << "done" << endl;
+	this->Result = this->GF;
 }
+;
+
+void OutputNetCDFDim::SetDate(string ds)
+{
+	this->datestr = ds;
+}
+
+void OutputNetCDFVars::SetDate(string ds)
+{
+	DEBUG << "Setting Date to " << ds << endl;
+	this->datestr = ds;
+}
+
+} // namespace GF
+
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/tonetcdf.h gridfields/clib/src/tonetcdf.h
--- tag/gridfieldsclib-0.7/src/tonetcdf.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/tonetcdf.h	2014-05-16 22:57:00.766725199 +0200
@@ -3,73 +3,67 @@
 
 #include "gridfieldoperator.h"
 //#include "elio.h"
-#include "netcdfcpp.h"
+#include <netcdfcpp.h>
 #include <iostream>
 
-class OutputNetCDFOp : public UnaryGridFieldOperator {
+namespace GF {
+
+class OutputNetCDFOp: public UnaryGridFieldOperator {
 public:
-  OutputNetCDFOp(string fn, GridFieldOperator *Op, const Scheme f, const Scheme t);
-  
-  string filename;
-  void Execute();
-  void setFileName(char *fn) { filename = string(fn); };
-  //virtual void Output(GridField *GF, string filename, long offset);
-  void WriteNetCDF(vector<GridField *> &dims, GridField *cross, const string &fname);
-  void WriteTimeVars(GridFieldOperator *gf, int index, float timestep);
-  void SetDate(string ds);
+	OutputNetCDFOp(string fn, GridFieldOperator *Op, const Scheme f, const Scheme t);
+
+	string filename;
+	void Execute();
+	void setFileName(char *fn)
+	{
+		filename = string(fn);
+	}
+	;
+	//virtual void Output(GridField *GF, string filename, long offset);
+	void WriteNetCDF(vector<GridField *> &dims, GridField *cross, const string &fname);
+	void WriteTimeVars(GridFieldOperator *gf, int index, float timestep);
+	void SetDate(string ds);
 
 private:
 
-  const Scheme fixed;
-  const Scheme time;
+	const Scheme fixed;
+	const Scheme time;
 
-  string datestr;
-  NcFile *ncdf;
-  NcVar *putData(Array *a, NcFile *ncdf, long *counts, NcDim **d, int dimcount);
+	string datestr;
+	NcFile *ncdf;
+	NcVar *putData(Array *a, NcFile *ncdf, long *counts, NcDim **d, int dimcount);
 };
 
-
-class OutputNetCDFDim : public UnaryGridFieldOperator {
+class OutputNetCDFDim: public UnaryGridFieldOperator {
 public:
-OutputNetCDFDim
-(
-  NcFile *f,
-  Dim_t d, 
-  string dn, 
-  GridFieldOperator *Op
-);
-
-  void WriteCells(AbstractCellArray *ca, Dim_t d);
-  void Execute();
-  void SetDate(string ds);
+	OutputNetCDFDim(NcFile *f, Dim_t d, string dn, GridFieldOperator *Op);
+
+	void WriteCells(AbstractCellArray *ca, Dim_t d);
+	void Execute();
+	void SetDate(string ds);
 
 private:
-  string datestr;
-  string basedimname;
-  NcFile *ncdf;
-  Dim_t dim;
+	string datestr;
+	string basedimname;
+	NcFile *ncdf;
+	Dim_t dim;
 };
 
-class OutputNetCDFVars : public UnaryGridFieldOperator {
+class OutputNetCDFVars: public UnaryGridFieldOperator {
 public:
-OutputNetCDFVars(
-NcFile *f,
-const Scheme dims,
-Dim_t d, 
-GridFieldOperator *Op,
-unsigned int i=0,  //index for the unbounded dimension
-float t=0 // value for the unbounded dimension
-);   
-  void Execute();
-  void SetDate(string ds);
+	OutputNetCDFVars(NcFile *f, const Scheme dims, Dim_t d, GridFieldOperator *Op, unsigned int i = 0, //index for the unbounded dimension
+			float t = 0 // value for the unbounded dimension
+			);
+	void Execute();
+	void SetDate(string ds);
 
 private:
-  string datestr;
-  float time;
-  Scheme dimscheme;
-  unsigned int index;
-  NcFile *ncdf;
-  Dim_t dim;
+	string datestr;
+	float time;
+	Scheme dimscheme;
+	unsigned int index;
+	NcFile *ncdf;
+	Dim_t dim;
 
 };
 // Utility netcdf functions
@@ -78,4 +72,7 @@
 bool HasDim(NcFile *ncdf, const string dimname);
 bool HasVar(NcFile *ncdf, const string varname);
 bool HasAttr(NcFile *ncdf, const string attr);
+
+} // namespace GF
+
 #endif
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/triangulate.cc gridfields/clib/src/triangulate.cc
--- tag/gridfieldsclib-0.7/src/triangulate.cc	1970-01-01 01:00:00.000000000 +0100
+++ gridfields/clib/src/triangulate.cc	2014-05-16 22:57:00.773391865 +0200
@@ -0,0 +1,148 @@
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+
+#include "triangulate.h"
+
+static const double EPSILON = 0.0000000001f;
+
+double Triangulate::Area(const Vector2dVector &contour)
+{
+
+	int n = contour.size();
+
+	double A = 0.0f;
+
+	for (int p = n - 1, q = 0; q < n; p = q++) {
+		A += contour[p].GetX() * contour[q].GetY() - contour[q].GetX() * contour[p].GetY();
+	}
+	return A * 0.5f;
+}
+
+/*
+ InsideTriangle decides if a point P is Inside of the triangle
+ defined by A, B, C.
+ */
+bool Triangulate::InsideTriangle(double Ax, double Ay, double Bx, double By, double Cx, double Cy, double Px, double Py)
+
+{
+	double ax, ay, bx, by, cx, cy, apx, apy, bpx, bpy, cpx, cpy;
+	double cCROSSap, bCROSScp, aCROSSbp;
+
+	ax = Cx - Bx;
+	ay = Cy - By;
+	bx = Ax - Cx;
+	by = Ay - Cy;
+	cx = Bx - Ax;
+	cy = By - Ay;
+	apx = Px - Ax;
+	apy = Py - Ay;
+	bpx = Px - Bx;
+	bpy = Py - By;
+	cpx = Px - Cx;
+	cpy = Py - Cy;
+
+	aCROSSbp = ax * bpy - ay * bpx;
+	cCROSSap = cx * apy - cy * apx;
+	bCROSScp = bx * cpy - by * cpx;
+
+	return ((aCROSSbp >= 0.0f) && (bCROSScp >= 0.0f) && (cCROSSap >= 0.0f));
+}
+;
+
+bool Triangulate::Snip(const Vector2dVector &contour, int u, int v, int w, int n, int *V)
+{
+	int p;
+	double Ax, Ay, Bx, By, Cx, Cy, Px, Py;
+
+	Ax = contour[V[u]].GetX();
+	Ay = contour[V[u]].GetY();
+
+	Bx = contour[V[v]].GetX();
+	By = contour[V[v]].GetY();
+
+	Cx = contour[V[w]].GetX();
+	Cy = contour[V[w]].GetY();
+
+	if (EPSILON > (((Bx - Ax) * (Cy - Ay)) - ((By - Ay) * (Cx - Ax)))) return false;
+
+	for (p = 0; p < n; p++) {
+		if ((p == u) || (p == v) || (p == w)) continue;
+		Px = contour[V[p]].GetX();
+		Py = contour[V[p]].GetY();
+		if (InsideTriangle(Ax, Ay, Bx, By, Cx, Cy, Px, Py)) return false;
+	}
+
+	return true;
+}
+
+bool Triangulate::Process(const Vector2dVector &contour, Vector2dVector &result)
+{
+	/* allocate and initialize list of Vertices in polygon */
+
+	int n = contour.size();
+	if (n < 3) return false;
+
+	int *V = new int[n];
+
+	/* we want a counter-clockwise polygon in V */
+
+	if (0.0f < Area(contour))
+		for (int v = 0; v < n; v++)
+			V[v] = v;
+	else
+		for (int v = 0; v < n; v++)
+			V[v] = (n - 1) - v;
+
+	int nv = n;
+
+	/*  remove nv-2 Vertices, creating 1 triangle every time */
+	int count = 2 * nv; /* error detection */
+
+	for (int m = 0, v = nv - 1; nv > 2;) {
+		/* if we loop, it is probably a non-simple polygon */
+		if (0 >= (count--)) {
+			//** Triangulate: ERROR - probable bad polygon!
+			return false;
+		}
+
+		/* three consecutive vertices in current polygon, <u,v,w> */
+		int u = v;
+		if (nv <= u) u = 0; /* previous */
+		v = u + 1;
+		if (nv <= v) v = 0; /* new v    */
+		int w = v + 1;
+		if (nv <= w) w = 0; /* next     */
+
+		if (Snip(contour, u, v, w, nv, V)) {
+			int a, b, c, s, t;
+
+			/* true names of the vertices */
+			a = V[u];
+			b = V[v];
+			c = V[w];
+
+			/* output Triangle */
+			result.push_back(contour[a]);
+			result.push_back(contour[b]);
+			result.push_back(contour[c]);
+
+			m++;
+
+			/* remove v from remaining polygon */
+			for (s = v, t = v + 1; t < nv; s++, t++)
+				V[s] = V[t];
+			nv--;
+
+			/* resest error detection counter */
+			count = 2 * nv;
+		}
+	}
+
+	delete V;
+
+	return true;
+}
+
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/triangulate.h gridfields/clib/src/triangulate.h
--- tag/gridfieldsclib-0.7/src/triangulate.h	1970-01-01 01:00:00.000000000 +0100
+++ gridfields/clib/src/triangulate.h	2014-05-16 22:57:00.776725199 +0200
@@ -0,0 +1,96 @@
+// COTD Entry submitted by John W. Ratcliff [jratcliff@verant.com]
+
+// ** THIS IS A CODE SNIPPET WHICH WILL EFFICIEINTLY TRIANGULATE ANY
+// ** POLYGON/CONTOUR (without holes) AS A STATIC CLASS.  THIS SNIPPET
+// ** IS COMPRISED OF 3 FILES, TRIANGULATE.H, THE HEADER FILE FOR THE
+// ** TRIANGULATE BASE CLASS, TRIANGULATE.CPP, THE IMPLEMENTATION OF
+// ** THE TRIANGULATE BASE CLASS, AND TEST.CPP, A SMALL TEST PROGRAM
+// ** DEMONSTRATING THE USAGE OF THE TRIANGULATOR.  THE TRIANGULATE
+// ** BASE CLASS ALSO PROVIDES TWO USEFUL HELPER METHODS, ONE WHICH
+// ** COMPUTES THE AREA OF A POLYGON, AND ANOTHER WHICH DOES AN EFFICENT
+// ** POINT IN A TRIANGLE TEST.
+// ** SUBMITTED BY JOHN W. RATCLIFF (jratcliff@verant.com) July 22, 2000
+
+/**********************************************************************/
+/************ HEADER FILE FOR TRIANGULATE.H ***************************/
+/**********************************************************************/
+
+#ifndef TRIANGULATE_H
+
+#define TRIANGULATE_H
+
+/*****************************************************************/
+/** Static class to triangulate any contour/polygon efficiently **/
+/** You should replace Vector2d with whatever your own Vector   **/
+/** class might be.  Does not support polygons with holes.      **/
+/** Uses STL vectors to represent a dynamic array of vertices.  **/
+/** This code snippet was submitted to FlipCode.com by          **/
+/** John W. Ratcliff (jratcliff@verant.com) on July 22, 2000    **/
+/** I did not write the original code/algorithm for this        **/
+/** this triangulator, in fact, I can't even remember where I   **/
+/** found it in the first place.  However, I did rework it into **/
+/** the following black-box static class so you can make easy   **/
+/** use of it in your own code.  Simply replace Vector2d with   **/
+/** whatever your own Vector implementation might be.           **/
+/*****************************************************************/
+
+#include <vector>  // Include STL vector class.
+class Vector2d {
+public:
+	Vector2d(double x, double y)
+	{
+		Set(x, y);
+	}
+	;
+
+	double GetX(void) const
+	{
+		return mX;
+	}
+	;
+
+	double GetY(void) const
+	{
+		return mY;
+	}
+	;
+
+	void Set(double x, double y)
+	{
+		mX = x;
+		mY = y;
+	}
+	;
+private:
+	double mX;
+	double mY;
+};
+
+// Typedef an STL vector of vertices which are used to represent
+// a polygon/contour and a series of triangles.
+typedef std::vector<Vector2d> Vector2dVector;
+
+class Triangulate {
+public:
+
+	// triangulate a contour/polygon, places results in STL vector
+	// as series of triangles.
+	static bool Process(const Vector2dVector &contour, Vector2dVector &result);
+
+	// compute area of a contour/polygon
+	static double Area(const Vector2dVector &contour);
+
+	// decide if point Px/Py is inside triangle defined by
+	// (Ax,Ay) (Bx,By) (Cx,Cy)
+	static bool InsideTriangle(double Ax, double Ay, double Bx, double By, double Cx, double Cy, double Px, double Py);
+
+private:
+	static bool Snip(const Vector2dVector &contour, int u, int v, int w, int n, int *V);
+
+};
+
+#endif
+
+/**************************************************************************/
+/*** END OF HEADER FILE TRIANGULATE.H BEGINNING OF CODE TRIANGULATE.CPP ***/
+/**************************************************************************/
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/tuple.cc gridfields/clib/src/tuple.cc
--- tag/gridfieldsclib-0.7/src/tuple.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/tuple.cc	2014-05-16 22:57:00.756725199 +0200
@@ -1,367 +1,433 @@
+#include "config_gridfields.h"
+
 #include <iostream>
 #include <fstream>
 #include <sstream>
-#include <assert.h>
+
+#include <cassert>
+#include <cstdlib>
+
 #include "tuple.h"
 #include "expr.h"
 #include "util.h"
 
-Scheme::Scheme() {}
+namespace GF {
+
+Scheme::Scheme()
+{
+}
+
+void Scheme::addAttribute(const string &attr, Type type)
+{
+	if (!this->isAttribute(attr)) {
+		pos[attr] = sort.size();
+		sort.push_back(make_pair(attr, type));
+	}
+}
+
+void Scheme::removeAttribute(const string &attr)
+{
+	vector<pair<string, Type> >::iterator i;
+	for (i = sort.begin(); i != sort.end(); i++) {
+		if (i->first == attr) {
+			sort.erase(i);
+			// stop iterating, since we've mutated the vector!
+			break;
+		}
+	}
+	rebuildPositions();
+}
+
+void Scheme::rebuildPositions()
+{
+	pos.clear();
+	for (size_t i = 0; i < sort.size(); i++) {
+		pos[sort[i].first] = i;
+	}
+}
+
+Scheme::Scheme(string scheme_string)
+{
+	vector<string> attrs;
+	vector<string> a;
 
-void Scheme::addAttribute(const string &attr, Type type) {
-  if (!this->isAttribute(attr)) {
-    pos[attr] = sort.size();
-    sort.push_back(make_pair(attr, type));
-  }
-}
-
-void Scheme::removeAttribute(const string &attr) {
-  vector< pair<string, Type> >::iterator i;
-  for (i=sort.begin(); i!=sort.end(); i++) {
-    if (i->first == attr) {
-      sort.erase(i);
-      // stop iterating, since we've mutated the vector!
-      break;
-    }
-  }
-  rebuildPositions();
-}
-
-void Scheme::rebuildPositions() {
-  pos.clear();
-  for (size_t i=0; i<sort.size(); i++) {
-    pos[sort[i].first] = i;
-  }
-}
-
-Scheme::Scheme(string scheme_string) {
-  vector<string> attrs;
-  vector<string> a;
-  
-  split(scheme_string, ";, ", attrs);
-
-  vector<string>::iterator p;
-
-  for (p=attrs.begin(); p!=attrs.end(); p++) { 
-    split(*p, ":", a);
-    if (a.size() == 1) {
+	split(scheme_string, ";, ", attrs);
+
+	vector<string>::iterator p;
+
+	for (p = attrs.begin(); p != attrs.end(); p++) {
+		split(*p, ":", a);
+		if (a.size() == 1) {
 //      cout << "SCHEME: " << a[0] << endl;
-      this->addAttribute(a[0], FLOAT);
-    } else if (a.size() == 2) {
-      this->addAttribute(a[0], typeval(a[1]));
-    } else {
-      cout << "Parse error for scheme string: " << scheme_string << endl;
-      exit(1);
-    }
-    a.clear();
-  }
-}
-
-bool Scheme::operator==(const Scheme &s) {
-  return (*this) >= s && (*this) <= s;
-}
-bool Scheme::operator>=(const Scheme &s) {
-  return this->Subsumes(s);
-}
-bool Scheme::operator<=(const Scheme &s){
-  return s.Subsumes((*this));
-}
-
-bool Scheme::Subsumes(const Scheme &sch) const {
-  string attr;
-  for (size_t i=0; i<sch.size(); i++) {
-    attr = sch.getAttribute(i);
-    if (this->isAttribute(attr)) {
-      if (this->getType(attr) != sch.getType(attr)) {
-      //  return false;
-      }
-    } else {
-      return false;
-    }
-  }
-  return true;
-}
-
-bool Tuple::Covers(Scheme &sch) {
-  return scheme->Subsumes(sch);
-}
-
-bool Tuple::CoveredBy(Scheme &sch) {
-  return sch.Subsumes(*scheme);
-}
-
-string Scheme::asString() {
-  stringstream retval;
-  for (size_t i=0; i<this->size(); i++) {
-    retval << this->getAttribute(i);
-    retval << ":";
-    retval << typeformat(this->getType(i));
-    retval << ", ";
-  }
-  return retval.str();
-}
-
-size_t Scheme::byteposition(const string &attr) {
-  int ord = this->getPosition(attr);
-  if (ord == -1) {
-    Fatal("Scheme::byteposition : Attribute '%s' not found.", attr.c_str() );
-  }
-  
-  int bytes = 0;
-  for (int i=0; i<ord; i++) {
-    bytes += typesize(this->getType(i));
-  }
-  return bytes;
-}
-
-size_t Scheme::bytesize() {
-  int s = this->size();
-  int bytes = 0;
-  for (int i=0; i<s; i++) {
-    bytes += typesize(this->getType(i));
-  }
-  return bytes;
-}
-
-size_t Scheme::size() const { return sort.size(); }
-
-Type Scheme::getType(const string &attr) const {
-  return this->getType(this->getPosition(attr));
-}
-
-Type Scheme::getType(int j) const {
-  int i=(signed) j;
-  assert(i>=(signed)0 && i<(signed)sort.size());
-  return sort[i].second;
-}
-
-int Scheme::getPosition(const string &attr) const {
-  map<string, int>::const_iterator i;
-  i = pos.find(attr);
-  if (i == pos.end()) {
-    stringstream ss;
-    Scheme *s = (Scheme *) this; 
-    s->PrintTo(ss,0);
-    Fatal("Attribute '%s' not found in scheme:\n %s", attr.c_str(), ss.str().c_str());
-    return -1;
-  } else {
-    return i->second;
-  }
-}
-
-string Scheme::formatOf(int position) {
-  string fmt;
-  fmt = typeformat(this->getType(position));
-  return "%" + fmt;
-}
-
-bool Scheme::isAttribute(const string &nm) const {
-  if (pos.find(nm) != pos.end()) 
-    return true;
-  return false;
-}
-
-string Scheme::getAttribute(int position) const {
-  assert((signed)position>=(signed)0  && (signed)position<(signed)sort.size());
-  return sort[(signed)position].first;
-}
-
-void Scheme::print() { print(0); }
-void Scheme::print(int ) { PrintTo(cout,0); }
-
-void Scheme::PrintTo(ostream &os, int indent) { 
-  int i;
-  vector<pair<string, Type> >::iterator pos;
-  for (i=0; i<indent; i++) os << " ";
-  os << "<";
-  for (pos=sort.begin(); pos!=sort.end(); ++pos) {
-    os << pos->first << " : " << pos->second << ", ";
-  }
-  if (pos==sort.begin()) {
-    os << "<no attributes>";
-  }
-  os << ">" << endl;
-}
-
-Tuple::Tuple(Scheme *sch) {
-  scheme = sch;
-  tupledata.reserve(scheme->size());
-  for (size_t i=0; i<scheme->size(); i++) {
-    tupledata.push_back(NULL);
-  }
-}
-
-void Tuple::Next() {
-  vector<UnTypedPtr>::iterator it;
-  Scheme::FieldIterator fi;
-  fi=this->scheme->begin();  
-  for (it=tupledata.begin(); it!=tupledata.end(); it++) {
-    plusplus(&(*it), fi->second);
-    fi++;
-    //*it = (UnTypedPtr) (((int) (*it)) + sizeof(int));
-    //((int *) (*it))++;// = (UnTypedPtr) (((int) (*it)) + sizeof(int));
-  }
-}
-
-bool Tuple::isNull() {
-  for (size_t i=0; i<scheme->size(); i++) {
-    if (tupledata[i] != NULL) return false;
-  }
-  return true;
+			this->addAttribute(a[0], FLOAT);
+		}
+		else if (a.size() == 2) {
+			this->addAttribute(a[0], typeval(a[1]));
+		}
+		else {
+			cout << "Parse error for scheme string: " << scheme_string << endl;
+			exit(1);
+		}
+		a.clear();
+	}
+}
+
+bool Scheme::operator==(const Scheme &s)
+{
+	return (*this) >= s && (*this) <= s;
+}
+bool Scheme::operator>=(const Scheme &s)
+{
+	return this->Subsumes(s);
+}
+bool Scheme::operator<=(const Scheme &s)
+{
+	return s.Subsumes((*this));
+}
+
+bool Scheme::Subsumes(const Scheme &sch) const
+{
+	string attr;
+	for (size_t i = 0; i < sch.size(); i++) {
+		attr = sch.getAttribute(i);
+		if (this->isAttribute(attr)) {
+			if (this->getType(attr) != sch.getType(attr)) {
+				//  return false;
+			}
+		}
+		else {
+			return false;
+		}
+	}
+	return true;
+}
+
+bool Tuple::Covers(Scheme &sch)
+{
+	return scheme->Subsumes(sch);
+}
+
+bool Tuple::CoveredBy(Scheme &sch)
+{
+	return sch.Subsumes(*scheme);
+}
+
+string Scheme::asString()
+{
+	stringstream retval;
+	for (size_t i = 0; i < this->size(); i++) {
+		retval << this->getAttribute(i);
+		retval << ":";
+		retval << typeformat(this->getType(i));
+		retval << ", ";
+	}
+	return retval.str();
+}
+
+size_t Scheme::byteposition(const string &attr)
+{
+	int ord = this->getPosition(attr);
+	if (ord == -1) {
+		Fatal("Scheme::byteposition : Attribute '%s' not found.", attr.c_str());
+	}
+
+	int bytes = 0;
+	for (int i = 0; i < ord; i++) {
+		bytes += typesize(this->getType(i));
+	}
+	return bytes;
+}
+
+size_t Scheme::bytesize()
+{
+	int s = this->size();
+	int bytes = 0;
+	for (int i = 0; i < s; i++) {
+		bytes += typesize(this->getType(i));
+	}
+	return bytes;
+}
+
+size_t Scheme::size() const
+{
+	return sort.size();
+}
+
+Type Scheme::getType(const string &attr) const
+{
+	return this->getType(this->getPosition(attr));
+}
+
+Type Scheme::getType(int j) const
+{
+	int i = (signed) j;
+	assert(i >= (signed )0 && i < (signed )sort.size());
+	return sort[i].second;
+}
+
+int Scheme::getPosition(const string &attr) const
+{
+	map<string, int>::const_iterator i;
+	i = pos.find(attr);
+	if (i == pos.end()) {
+		stringstream ss;
+		Scheme *s = (Scheme *) this;
+		s->PrintTo(ss, 0);
+		Fatal("Attribute '%s' not found in scheme:\n %s", attr.c_str(), ss.str().c_str());
+		return -1;
+	}
+	else {
+		return i->second;
+	}
+}
+
+string Scheme::formatOf(int position)
+{
+	string fmt;
+	fmt = typeformat(this->getType(position));
+	return "%" + fmt;
+}
+
+bool Scheme::isAttribute(const string &nm) const
+{
+	if (pos.find(nm) != pos.end()) return true;
+	return false;
+}
+
+string Scheme::getAttribute(int position) const
+{
+	assert((signed )position >= (signed )0 && (signed )position < (signed )sort.size());
+	return sort[(signed) position].first;
+}
+
+void Scheme::print()
+{
+	print(0);
+}
+void Scheme::print(int)
+{
+	PrintTo(cout, 0);
+}
+
+void Scheme::PrintTo(ostream &os, int indent)
+{
+	int i;
+	vector<pair<string, Type> >::iterator pos;
+	for (i = 0; i < indent; i++)
+		os << " ";
+	os << "<";
+	for (pos = sort.begin(); pos != sort.end(); ++pos) {
+		os << pos->first << " : " << pos->second << ", ";
+	}
+	if (pos == sort.begin()) {
+		os << "<no attributes>";
+	}
+	os << ">" << endl;
+}
+
+Tuple::Tuple(Scheme *sch)
+{
+	scheme = sch;
+	tupledata.reserve(scheme->size());
+	for (size_t i = 0; i < scheme->size(); i++) {
+		tupledata.push_back(NULL);
+	}
+}
+
+void Tuple::Next()
+{
+	vector<UnTypedPtr>::iterator it;
+	Scheme::FieldIterator fi;
+	fi = this->scheme->begin();
+	for (it = tupledata.begin(); it != tupledata.end(); it++) {
+		plusplus(&(*it), fi->second);
+		fi++;
+		//*it = (UnTypedPtr) (((int) (*it)) + sizeof(int));
+		//((int *) (*it))++;// = (UnTypedPtr) (((int) (*it)) + sizeof(int));
+	}
+}
+
+bool Tuple::isNull()
+{
+	for (size_t i = 0; i < scheme->size(); i++) {
+		if (tupledata[i] != NULL) return false;
+	}
+	return true;
 }
 
 /*
-Tuple::Tuple(const Tuple &tup) {
-  scheme = tup.scheme;
-  tupledata = tup.tupledata;
-}
-*/
-
-UnTypedPtr Tuple::get(string attr) {
-  int i = scheme->getPosition(attr);
-  //cout << "got position: " << attr << ", " << i << endl;
-  if (i == -1) Fatal("Tuple get: attribute %s not found.", attr.c_str());
-  return tupledata[i];
-}
-
-void Tuple::set(string attr, UnTypedPtr val) {
-  int i = scheme->getPosition(attr);
-  //cout << ": " << *(float *) val << endl;
-  tupledata[i] = val;
-}
-
-UnTypedPtr Tuple::operator[](size_t i) {
-  if (i > tupledata.size()) {
-    this->print();
-    Fatal("Tuple: Index out of range %i", i);
-  }    
-  return tupledata[i];  
-}
-
-int Tuple::bytesize() {
-  int s = this->scheme->size();
-  int bytes = 0;
-  for (int i=0; i<s; i++) {
-    bytes += typesize(this->scheme->getType(i));
-  }
-  return bytes;
-}
-
-void Tuple::Read(ifstream &f) {
-  // arbitrary limit...
-  char textline[256];
-  f.getline(textline, 256);
-  this->Parse(textline);
-}
- 
-void Tuple::Parse(char *text) {
-
-  stringstream ss(text);
-  int s = this->scheme->size();
-  int *x = new int;
-  float *y = new float;
-  for (int j=0; j<s; j++) {
-    switch (this->scheme->getType(j)) {
-      case INT:
-        ss >> *x;
-        tupledata[j] = (UnTypedPtr) x;
-        break;
-      case FLOAT:
-        ss >> *y;
-        tupledata[j] = (UnTypedPtr) y;
-        break;
-      default:
-         this->print();
-         Fatal("Tuple::Parse: only ints an floats right now...");
-    }
-  }
-}
-
-void Tuple::copy(Tuple &t) {
-    int n = scheme->size();
-    for (int i=0; i<n; i++) {
-      //int j=t.getPosition(this->getAttribute(i));
-      // assume tuples have same scheme
-      int j=i;
-      switch (scheme->getType(i)) {
-        case INT:
-          *((int*) tupledata[i]) = *((int *) t.tupledata[j]);
-          break;
-        case FLOAT:
-          *((float*) tupledata[i]) = *((float *) t.tupledata[j]);
-          break;
-        case OBJ:
-          *((UnTypedPtr *) tupledata[i]) = *((UnTypedPtr *) t.tupledata[j]);
-          break;
-        case TUPLE:
-          *((UnTypedPtr *) tupledata[i]) = *((UnTypedPtr *) t.tupledata[j]);
-          break;
-        case GRIDFIELD:
-          *((UnTypedPtr *) tupledata[i]) = *((UnTypedPtr *) t.tupledata[j]);
-          break;
-      }
-    }
-}
-
-string Tuple::asString(const string &delim) {
-  stringstream os;
-  if (scheme->size() != 0) { 
-    printattr(os, 0);
-    for (size_t i=1; i<scheme->size(); i++) {
-      os << delim;
-      printattr(os,i);
-    }
-  }
-  return os.str();
-}
-
-void Tuple::assign(char *rawbytes) {
-  char *p = rawbytes;
-  for (size_t i=0; i<scheme->size(); i++) {
-     this->set(scheme->getAttribute(i), p);
-     p += typesize(scheme->getType(i));
-  }
-}
-
-void Tuple::print() { print(0); }
-
-void Tuple::print(int indent) {
-  PrintTo(cout, indent);
-}
-
-void Tuple::PrintTo(ostream &os, int indent) {
-  os << tab(indent) << scheme->size() << ", " << tupledata.size() << ": ";
-  assert(scheme->size() == tupledata.size());
-  if (scheme->size() == 0) { os << "(empty tuple)"; }
-  
-  os << "<" << scheme->getAttribute(0) << "=";
-  os << tupledata[0] << "->";
-  printattr(os, 0);    
-  for (size_t i=1; i<scheme->size(); i++) {
-    os << ", " << scheme->getAttribute(i) << "=";
-    os << tupledata[i] << "->";
-    printattr(os, i);
-  }
-  os << ">" << endl;
-  
-}
-
-void Tuple::printattr(ostream &os, int i) {
-  switch (scheme->getType(scheme->getAttribute(i))) {
-    case INT:
-      os <<  *((int*) tupledata[i]);
-      break;
-    case FLOAT:
-      os <<  *((float*) tupledata[i]);
-      break;
-    case OBJ:
-      os << "object(" << *(UnTypedPtr **) tupledata[i] << ")";
-      break;
-    case TUPLE:
-      os << "object(" << *(UnTypedPtr **) tupledata[i] << ")";
-      break;
-    case GRIDFIELD:
-      os << "object(" << *(UnTypedPtr **) tupledata[i] << ")";
-      break;
-  }
+ Tuple::Tuple(const Tuple &tup) {
+ scheme = tup.scheme;
+ tupledata = tup.tupledata;
+ }
+ */
+
+UnTypedPtr Tuple::get(string attr)
+{
+	int i = scheme->getPosition(attr);
+	//cout << "got position: " << attr << ", " << i << endl;
+	if (i == -1) Fatal("Tuple get: attribute %s not found.", attr.c_str());
+	return tupledata[i];
+}
+
+void Tuple::set(string attr, UnTypedPtr val)
+{
+	int i = scheme->getPosition(attr);
+	//cout << ": " << *(float *) val << endl;
+	tupledata[i] = val;
+}
+
+UnTypedPtr Tuple::operator[](size_t i)
+{
+	if (i > tupledata.size()) {
+		this->print();
+		Fatal("Tuple: Index out of range %i", i);
+	}
+	return tupledata[i];
+}
+
+int Tuple::bytesize()
+{
+	int s = this->scheme->size();
+	int bytes = 0;
+	for (int i = 0; i < s; i++) {
+		bytes += typesize(this->scheme->getType(i));
+	}
+	return bytes;
+}
+
+void Tuple::Read(istream &f)
+{
+	// arbitrary limit...
+	char textline[256];
+	f.getline(textline, 256);
+	this->Parse(textline);
+}
+
+void Tuple::Parse(char *text)
+{
+
+	stringstream ss(text);
+	int s = this->scheme->size();
+	int *x = new int;
+	float *y = new float;
+	for (int j = 0; j < s; j++) {
+		switch (this->scheme->getType(j)) {
+		case INT:
+			ss >> *x;
+			tupledata[j] = (UnTypedPtr) x;
+			break;
+		case FLOAT:
+			ss >> *y;
+			tupledata[j] = (UnTypedPtr) y;
+			break;
+		default:
+			this->print();
+			Fatal("Tuple::Parse: only ints an floats right now...");
+			break;
+		}
+	}
+}
+
+void Tuple::copy(Tuple &t)
+{
+	int n = scheme->size();
+	for (int i = 0; i < n; i++) {
+		//int j=t.getPosition(this->getAttribute(i));
+		// assume tuples have same scheme
+		int j = i;
+		switch (scheme->getType(i)) {
+		case INT:
+			*((int*) tupledata[i]) = *((int *) t.tupledata[j]);
+			break;
+		case FLOAT:
+			*((float*) tupledata[i]) = *((float *) t.tupledata[j]);
+			break;
+		case OBJ:
+			*((UnTypedPtr *) tupledata[i]) = *((UnTypedPtr *) t.tupledata[j]);
+			break;
+		case TUPLE:
+			*((UnTypedPtr *) tupledata[i]) = *((UnTypedPtr *) t.tupledata[j]);
+			break;
+		case GRIDFIELD:
+			*((UnTypedPtr *) tupledata[i]) = *((UnTypedPtr *) t.tupledata[j]);
+			break;
+		}
+	}
+}
+
+string Tuple::asString(const string &delim)
+{
+	stringstream os;
+	if (scheme->size() != 0) {
+		printattr(os, 0);
+		for (size_t i = 1; i < scheme->size(); i++) {
+			os << delim;
+			printattr(os, i);
+		}
+	}
+	return os.str();
+}
+
+void Tuple::assign(char *rawbytes)
+{
+	char *p = rawbytes;
+	for (size_t i = 0; i < scheme->size(); i++) {
+		this->set(scheme->getAttribute(i), p);
+		p += typesize(scheme->getType(i));
+	}
+}
+
+void Tuple::print()
+{
+	print(0);
+}
+
+void Tuple::print(int indent)
+{
+	PrintTo(cout, indent);
+}
+
+void Tuple::PrintTo(ostream &os, int indent)
+{
+	os << tab(indent) << scheme->size() << ", " << tupledata.size() << ": ";
+	assert(scheme->size() == tupledata.size());
+	if (scheme->size() == 0) {
+		os << "(empty tuple)";
+	}
+
+	os << "<" << scheme->getAttribute(0) << "=";
+	os << tupledata[0] << "->";
+	printattr(os, 0);
+	for (size_t i = 1; i < scheme->size(); i++) {
+		os << ", " << scheme->getAttribute(i) << "=";
+		os << tupledata[i] << "->";
+		printattr(os, i);
+	}
+	os << ">" << endl;
+
+}
+
+void Tuple::printattr(ostream &os, int i)
+{
+	switch (scheme->getType(scheme->getAttribute(i))) {
+	case INT:
+		os << *((int*) tupledata[i]);
+		break;
+	case FLOAT:
+		os << *((float*) tupledata[i]);
+		break;
+	case OBJ:
+		os << "object(" << *(UnTypedPtr **) tupledata[i] << ")";
+		break;
+	case TUPLE:
+		os << "object(" << *(UnTypedPtr **) tupledata[i] << ")";
+		break;
+	case GRIDFIELD:
+		os << "object(" << *(UnTypedPtr **) tupledata[i] << ")";
+		break;
+	}
 }
+
+} // namespace GF
+
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/tuple.h gridfields/clib/src/tuple.h
--- tag/gridfieldsclib-0.7/src/tuple.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/tuple.h	2014-05-16 22:57:00.813391865 +0200
@@ -9,94 +9,129 @@
 
 using namespace std;
 
+namespace GF {
+
 class Scheme {
- public:
-  Scheme();
-  Scheme(string scheme_string);
-
-  typedef vector<pair<string, Type> >::iterator FieldIterator;
-  void addAttribute(const string &attr, Type t);
-  void removeAttribute(const string &attr);
-
-  void clear() { sort.clear(); rebuildPositions(); }
-  bool Subsumes(const Scheme &sch) const;
-  FieldIterator begin() { return sort.begin(); }
-  FieldIterator end() { return sort.end(); }
-  
-  size_t size() const;
-  size_t bytesize() ;
-  size_t byteposition(const string &attr);
-
-  Type getType(const string &attr) const;
-  Type getType(int i) const;
-  int getPosition(const string &attr) const;
-  string getAttribute(int position) const ;
-  bool isAttribute(const string &nm) const ;
-  
-  bool operator==(const Scheme &s);
-  bool operator>=(const Scheme &s);
-  bool operator<=(const Scheme &s);
-  string formatOf(int position);
-
-  string asString() ;
-
-  void PrintTo(ostream &os, int indent=0) ;
-  void print() ;
-  void print(int indent) ;
-
- private:
-  void rebuildPositions();
-  //pair<int, Type> getValue(string attr);
-  vector<pair<string, Type> > sort;
-  map<string, int> pos;
+public:
+	Scheme();
+	Scheme(string scheme_string);
+
+	typedef vector<pair<string, Type> >::iterator FieldIterator;
+	void addAttribute(const string &attr, Type t);
+	void removeAttribute(const string &attr);
+
+	void clear()
+	{
+		sort.clear();
+		rebuildPositions();
+	}
+	bool Subsumes(const Scheme &sch) const;
+	FieldIterator begin()
+	{
+		return sort.begin();
+	}
+	FieldIterator end()
+	{
+		return sort.end();
+	}
+
+	size_t size() const;
+	size_t bytesize();
+	size_t byteposition(const string &attr);
+
+	Type getType(const string &attr) const;
+	Type getType(int i) const;
+	int getPosition(const string &attr) const;
+	string getAttribute(int position) const;
+	bool isAttribute(const string &nm) const;
+
+	bool operator==(const Scheme &s);
+	bool operator>=(const Scheme &s);
+	bool operator<=(const Scheme &s);
+	string formatOf(int position);
+
+	string asString();
+
+	void PrintTo(ostream &os, int indent = 0);
+	void print();
+	void print(int indent);
+
+private:
+	void rebuildPositions();
+	//pair<int, Type> getValue(string attr);
+	vector<pair<string, Type> > sort;
+	map<string, int> pos;
 };
 
 class Tuple {
-typedef vector<UnTypedPtr> TupleData;
- public:
-  Tuple(Scheme *);
-
-  Scheme *getScheme() { return scheme; };
-
-  UnTypedPtr get(int pos) { return tupledata[pos]; };
-  void set(int pos, UnTypedPtr val) { tupledata[pos] = val; };
-  
-  UnTypedPtr get(string attr);
-  void set(string attr, UnTypedPtr val);
-
-  string getAttribute(int i) { return scheme->getAttribute(i); };
-  int size() { return scheme->size(); };
-
-  string asString(const string &delim=", ");
-  void print();
-  void print(int indent);
-  void PrintTo(ostream &os, int indent=0) ;
-
-  int bytesize();
-  void Next();
-  char *Allocate() { 
-    char *data = new char[this->bytesize()]; 
-    this->assign(data); 
-    return data; 
-  };
-  void assign(char *rawbytes);
-  void copy(Tuple &t);
-  bool isNull();
-  void Read(ifstream &f);
-  void Parse(char *text);
-  bool Covers(Scheme &sch);
-  bool CoveredBy(Scheme &sch);
-  
-  UnTypedPtr operator[](size_t i);
-  
-  friend class Dataset;
-  friend class TupleFunction;
-  friend class SpecializedTupleFunction;
- private:
-  void printattr(ostream &os, int i);
-  Scheme *scheme;
-  TupleData tupledata;
+	typedef vector<UnTypedPtr> TupleData;
+public:
+	Tuple(Scheme *);
+
+	Scheme *getScheme()
+	{
+		return scheme;
+	}
+	;
+
+	UnTypedPtr get(int pos)
+	{
+		return tupledata[pos];
+	}
+	;
+	void set(int pos, UnTypedPtr val)
+	{
+		tupledata[pos] = val;
+	}
+	;
+
+	UnTypedPtr get(string attr);
+	void set(string attr, UnTypedPtr val);
+
+	string getAttribute(int i)
+	{
+		return scheme->getAttribute(i);
+	}
+	;
+	int size()
+	{
+		return scheme->size();
+	}
+	;
+
+	string asString(const string &delim = ", ");
+	void print();
+	void print(int indent);
+	void PrintTo(ostream &os, int indent = 0);
+
+	int bytesize();
+	void Next();
+	char *Allocate()
+	{
+		char *data = new char[this->bytesize()];
+		this->assign(data);
+		return data;
+	}
+	;
+	void assign(char *rawbytes);
+	void copy(Tuple &t);
+	bool isNull();
+	void Read(/* ifstream: changed to istream to mesh with changes in arrayreader. jhrg 4/4/14 */istream &f);
+	void Parse(char *text);
+	bool Covers(Scheme &sch);
+	bool CoveredBy(Scheme &sch);
+
+	UnTypedPtr operator[](size_t i);
+
+	friend class Dataset;
+	friend class TupleFunction;
+	friend class SpecializedTupleFunction;
+private:
+	void printattr(ostream &os, int i);
+	Scheme *scheme;
+	TupleData tupledata;
 };
 
+} // namespace GF
 
 #endif /*_TUPLE_H */
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/type.cc gridfields/clib/src/type.cc
--- tag/gridfieldsclib-0.7/src/type.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/type.cc	2014-05-16 22:57:00.746725199 +0200
@@ -1,33 +1,49 @@
+#include "config_gridfields.h"
+
 #include <cstdlib>
 #include "type.h"
 #include "iostream"
 
+namespace GF {
 
+char typeformat(Type t)
+{
+	char nty = 'f';
+	// Added break statements. Added a default: case. jhrg 4/4/1/4
+	switch (t) {
+	case FLOAT:
+		nty = 'f';
+		break;
+	case INT:
+		nty = 'i';
+		break;
+	case OBJ:
+		nty = 'p';
+		break;
+	default:
+		break;
+	}
+	return nty;
+}
+;
 
-char typeformat(Type t) {char nty='f';
-  switch (t) {
-    case FLOAT:
-      nty= 'f';
-    case INT:
-      nty= 'i';
-    case OBJ:
-      nty= 'p';
-  }
-return nty;
-};
-
-Type typeval(std::string typestring) {Type nty=FLOAT;
-  if (typestring == "f" || typestring == "F") {
-    nty=FLOAT;
-  }
-  if (typestring == "i" || typestring == "I") {
-    nty= INT;
-  }
-  if (typestring == "p" || typestring == "P") {
-    nty= OBJ;
-  }
-  if (typestring == "o" || typestring == "O") {
-    nty= OBJ;
-  }
-return nty;
+Type typeval(std::string typestring)
+{
+	Type nty = FLOAT;
+	if (typestring == "f" || typestring == "F") {
+		nty = FLOAT;
+	}
+	if (typestring == "i" || typestring == "I") {
+		nty = INT;
+	}
+	if (typestring == "p" || typestring == "P") {
+		nty = OBJ;
+	}
+	if (typestring == "o" || typestring == "O") {
+		nty = OBJ;
+	}
+	return nty;
 }
+
+} // namespace GF
+
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/type.h gridfields/clib/src/type.h
--- tag/gridfieldsclib-0.7/src/type.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/type.h	2014-05-16 22:57:00.803391865 +0200
@@ -3,10 +3,16 @@
 #include <string>
 #include <stdio.h>
 
-enum e_Tag {VAR=1, VAL};
+namespace GF {
+
+enum e_Tag {
+	VAR = 1, VAL
+};
 typedef enum e_Tag Tag;
 
-enum e_Type {INT=1, FLOAT, OBJ, TUPLE, GRIDFIELD};
+enum e_Type {
+	INT = 1, FLOAT, OBJ, TUPLE, GRIDFIELD
+};
 typedef enum e_Type Type;
 
 typedef void *UnTypedPtr;
@@ -20,26 +26,32 @@
 typedef unsigned int Node;
 
 inline
-int typesize(Type t) {
-  switch (t) {
-    case FLOAT:
-      return sizeof(float);
-    case INT:
-      return sizeof(int);
-    case OBJ:
-      return sizeof(void *);
-    case TUPLE:
-      return sizeof(void *);
-    case GRIDFIELD:
-      return sizeof(void *);
-    default: 
-      return sizeof(int);
-  }
-};
+int typesize(Type t)
+{
+	switch (t) {
+	case FLOAT:
+		return sizeof(float);
+	case INT:
+		return sizeof(int);
+	case OBJ:
+		return sizeof(void *);
+	case TUPLE:
+		return sizeof(void *);
+	case GRIDFIELD:
+		return sizeof(void *);
+	default:
+		return sizeof(int);
+	}
+}
+;
 
 inline
-void plusplus(UnTypedPtr *p, Type type) {
-    *p = (UnTypedPtr) ((char *) (*p) + typesize(type));
-}; 
+void plusplus(UnTypedPtr *p, Type type)
+{
+	*p = (UnTypedPtr) ((char *) (*p) + typesize(type));
+}
+;
+
+} // namespace GF
 
 #endif
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/unarynodemap.cc gridfields/clib/src/unarynodemap.cc
--- tag/gridfieldsclib-0.7/src/unarynodemap.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/unarynodemap.cc	2014-05-16 22:57:00.730058533 +0200
@@ -1,3 +1,9 @@
+#include "config_gridfields.h"
+
 #include "unarynodemap.h"
 
+namespace GF {
+
 class UnaryNodeMap;
+
+} // namespace GF
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/unarynodemap.h gridfields/clib/src/unarynodemap.h
--- tag/gridfieldsclib-0.7/src/unarynodemap.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/unarynodemap.h	2014-05-16 22:57:00.766725199 +0200
@@ -3,12 +3,20 @@
 
 #include "nodemap.h"
 
-class UnaryNodeMap : public NodeMap {
+namespace GF {
 
- public:
-  virtual Node map(Node)=0;
-  //virtual ~UnaryNodeMap()=0;
- private:
+class UnaryNodeMap: public NodeMap {
+
+public:
+	virtual Node map(Node)=0;
+	//virtual ~UnaryNodeMap()=0;
+	// This class should have a destructor. jhrg 4/8/14
+	virtual ~UnaryNodeMap()
+	{
+	}
+private:
 };
 
+} // namespace GF
+
 #endif /* _UNARYNODEMAP_H */
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/util.cc gridfields/clib/src/util.cc
--- tag/gridfieldsclib-0.7/src/util.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/util.cc	2014-05-16 22:57:00.800058531 +0200
@@ -1,3 +1,5 @@
+#include "config_gridfields.h"
+
 #include <string>
 #include <iostream>
 #include <sstream>
@@ -6,68 +8,80 @@
 #include "tuple.h"
 #include "fparser.hh"
 extern "C" {
-  #include <stdarg.h>
+#include <stdarg.h>
 }
 
 using namespace std;
 
-string tab(int indent) {
-  string s;
-  for (int i=0; i< indent; i++) {
-    s += " ";
-  }
-  return s;
-}
-
-void split(const string &text, const string separators, vector<string> &words) {
-  int n = text.length();
-  int start, stop;
-  
-  start = text.find_first_not_of(separators);
-  while ((start>=0) && (start<n)) {
-    stop = text.find_first_of(separators, start);
-    if ((stop<0) || (stop>n)) stop = n;
-    words.push_back(text.substr(start, stop-start));
-    start = text.find_first_not_of(separators, stop+1);
-  }
-}
-
-void Fatal(const char *fmt, ...) {
-    // vulnerable to buffer overruns!
-    char foo[1000];
-    va_list ap;
-    va_start(ap, fmt);
-    vsprintf(foo, fmt, ap);
-    va_end(ap);
-    
-    stringstream errmsg;
-    errmsg << foo << endl;
-    cout << "Fatal Error: " << errmsg.str();
-    throw errmsg.str();
-}
- 
-void Warning(const char *fmt, ...) {
-    // vulnerable to buffer overruns!
-    char foo[1000];
-    va_list ap;
-    va_start(ap, fmt);
-    vsprintf(foo, fmt, ap);
-    va_end(ap);
-    
-    stringstream errmsg;
-    errmsg << foo << endl;
-    cout << "Warning: " << errmsg.str();
-}
-
-bool same(const string &r, const string &s) {
-  return (remove_whitespace(r) == remove_whitespace(s));
-}
-
-string remove_whitespace(const string &text) {
-  stringstream ss(text);
-  string buf, out;
-  while (ss >> buf) 
-    out += buf;
-  return out;
+namespace GF {
+
+string tab(int indent)
+{
+	string s;
+	for (int i = 0; i < indent; i++) {
+		s += " ";
+	}
+	return s;
+}
+
+void split(const string &text, const string separators, vector<string> &words)
+{
+	int n = text.length();
+	int start, stop;
+
+	start = text.find_first_not_of(separators);
+	while ((start >= 0) && (start < n)) {
+		stop = text.find_first_of(separators, start);
+		if ((stop < 0) || (stop > n)) stop = n;
+		words.push_back(text.substr(start, stop - start));
+		start = text.find_first_not_of(separators, stop + 1);
+	}
+}
+
+#define MSG_BUFFER_SIZE 1024
+
+void Fatal(const char *fmt, ...)
+{
+	// vulnerable to buffer overruns!
+	char foo[MSG_BUFFER_SIZE];
+	va_list ap;
+	va_start(ap, fmt);
+	vsnprintf(foo, MSG_BUFFER_SIZE, fmt, ap);
+	va_end(ap);
+
+	stringstream errmsg;
+	errmsg << foo << endl;
+	cout << "Fatal Error: " << errmsg.str();
+	throw errmsg.str();
+}
+
+void Warning(const char *fmt, ...)
+{
+	// vulnerable to buffer overruns!
+	char foo[MSG_BUFFER_SIZE];
+	va_list ap;
+	va_start(ap, fmt);
+	vsnprintf(foo, MSG_BUFFER_SIZE, fmt, ap);
+	va_end(ap);
+
+	stringstream errmsg;
+	errmsg << foo << endl;
+	cout << "Warning: " << errmsg.str();
+}
+
+bool same(const string &r, const string &s)
+{
+	return (remove_whitespace(r) == remove_whitespace(s));
+}
+
+string remove_whitespace(const string &text)
+{
+	stringstream ss(text);
+	string buf, out;
+	while (ss >> buf)
+		out += buf;
+	return out;
 }
 
+} // namespace GF
+
diff -Nur -x .svn tag/gridfieldsclib-0.7/src/util.h gridfields/clib/src/util.h
--- tag/gridfieldsclib-0.7/src/util.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/src/util.h	2014-05-16 22:57:00.743391866 +0200
@@ -1,10 +1,13 @@
 #ifndef _UTIL_H
 #define _UTIL_H
 
-#include <ext/hash_map>
+#include <stdio.h>
+
+#include <iostream>
 #include <vector>
 #include <string>
-#include <stdio.h>
+
+namespace GF {
 
 #define MAX(a,b) ((a)>(b)?(a):(b))
 #define MIN(a,b) ((a)<(b)?(a):(b))
@@ -22,12 +25,15 @@
         insert_iterator<type > ii(to, to.begin()); \
         copy(from.begin(), from.end(), ii);
 
-
-struct nullstream:
-std::ostream {
-nullstream(): std::ios(0), std::ostream(0) {}
+struct nullstream: std::ostream {
+	nullstream() :
+			std::ios(0), std::ostream(0)
+	{
+	}
 };
 
+// FIXME Use DBG(x) --> cerr << x or --> nothing instead.
+// jhrg 4/3/14
 #define DEBUG nullstream()
 //#define DEBUG cout
 
@@ -35,12 +41,13 @@
 std::string remove_whitespace(const std::string &text);
 bool same(const std::string &r, const std::string &s);
 
-void Fatal(const char *fmt, ...); 
-void Warning(const char *fmt, ...); 
-
+void Fatal(const char *fmt, ...);
+void Warning(const char *fmt, ...);
 
 std::string tab(int indent);
 typedef size_t idx;
+
+} // namespace GF
+
 #endif /* _UTIL_H */
-    
 
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/corierestrict.cc gridfields/clib/tests/corierestrict.cc
--- tag/gridfieldsclib-0.7/tests/corierestrict.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/corierestrict.cc	2014-05-16 22:59:45.930055090 +0200
@@ -4,6 +4,8 @@
 #include "restrict.h"
 #include "elio.h"
 
+using namespace GF;
+
 Grid *makeGrid(int scale, char *name) {
   CellArray *twocells;
   CellArray *onecells;
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/gfapply.cc gridfields/clib/tests/gfapply.cc
--- tag/gridfieldsclib-0.7/tests/gfapply.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/gfapply.cc	2014-05-16 22:59:46.323388415 +0200
@@ -10,6 +10,8 @@
 string filename;
 string outattr;
 
+using namespace GF;
+
 int main( int argc, char *argv[] ) {
   
   cout << "gfApply..." << flush;
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/gfbindvar.cc gridfields/clib/tests/gfbindvar.cc
--- tag/gridfieldsclib-0.7/tests/gfbindvar.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/gfbindvar.cc	2014-05-16 22:59:46.323388415 +0200
@@ -12,6 +12,8 @@
 string sourcefilename;
 int timestep;
 
+using namespace GF;
+
 int main( int argc, char *argv[] ) {
   
   cout << "gfBind..." << flush;
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/gfrestrict.cc gridfields/clib/tests/gfrestrict.cc
--- tag/gridfieldsclib-0.7/tests/gfrestrict.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/gfrestrict.cc	2014-05-16 22:59:45.926721756 +0200
@@ -8,6 +8,8 @@
 string opid;
 string predicate;
 
+using namespace GF;
+
 int main( int argc, char *argv[] ) {
   
   cout << "gfRestrict..." << flush;
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/gfscan.cc gridfields/clib/tests/gfscan.cc
--- tag/gridfieldsclib-0.7/tests/gfscan.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/gfscan.cc	2014-05-16 22:59:46.320055082 +0200
@@ -10,6 +10,8 @@
 
 char gridLetter;
 
+using namespace GF;
+
 int main( int argc, char *argv[] ) {
   
   cout << "gfScan..." << flush;
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/gfview.cc gridfields/clib/tests/gfview.cc
--- tag/gridfieldsclib-0.7/tests/gfview.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/gfview.cc	2014-05-16 22:59:46.316721748 +0200
@@ -10,6 +10,8 @@
 string filename;
 string attribute;
 
+using namespace GF;
+
 void View(string fn);
 void showhelp();
 void checkopts( int argc, char **argv );
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/Makefile.am gridfields/clib/tests/Makefile.am
--- tag/gridfieldsclib-0.7/tests/Makefile.am	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/Makefile.am	2014-05-16 22:59:46.340055081 +0200
@@ -1,16 +1,16 @@
+
 # Tests
 
 AUTOMAKE_OPTIONS = foreign
 
 # I think that if there are things in scratch that we need they should
 # move back out to the src directory (or here)
-#AM_CPPFLAGS = -I$(top_srcdir) -I$(top_srcdir)/experimental \
-#-I$(top_srcdir)/scratch
-AM_CXXFLAGS =  
+AM_CPPFLAGS = -Wno-deprecated
+AM_CXXFLAGS = -I$(top_srcdir)
 
 # These are not used by automake but are often useful for certain types of
 # debugging. 
-CXXFLAGS_DEBUG = -g3 -O0 -fno-defer-pop -Wall -W -Wcast-align -Werror
+CXXFLAGS_DEBUG = -g3 -O0 -Wall -Wcast-align
 TEST_COV_FLAGS = -ftest-coverage -fprofile-arcs
 
 # This determines what gets built by make check
@@ -21,25 +21,22 @@
 testrestrict testmerge testbind testgridfield	\
 testsift testdataset testcellarray testtuple testarray
 
-BROKEN_TESTS = testwrite63 testjoin testscan testgrid 
-
-VTK_TESTS= testvtk wedgetest testtag testvis testsmallrestrict	\
-testelcirc testsubapply
-
-NETCDF_TESTS = testnetcdf testoutput #testnetcdfadaptor  
-# selfe2netcdf 
+NETCDF_TESTS = testnetcdf testoutput 
 
 if NETCDF_FOUND
 TESTS += $(NETCDF_TESTS) 
 endif
 
+VTK_TESTS= testvtk wedgetest testtag testvis testsmallrestrict	\
+testelcirc testsubapply
+
 noinst_HEADERS = test.h	testarray.h testdataset.h transect.h
 
-# EXTRA_DIST = 
+EXTRA_DIST = dat data
 
 # CLEANFILES = 
 
-# DISTCLEANFILES = 
+DISTCLEANFILES = temp.nc data.nc
 
 # Note that the gcov options -f and -b are useful but sometimes make looking
 # at the results of coverage analysis a little taxing. -b reports on all
@@ -57,58 +54,18 @@
 #############################
 
 if NETCDF_FOUND
-#testnetcdfadaptor_SOURCES = testnetcdfadaptor.cc
-#testnetcdfadaptor_LDADD = -lnetcdf_c++ -lnetcdf ../libgridfields.la 
-
 testnetcdf_SOURCES = testnetcdf.cc
 testnetcdf_LDADD = -lnetcdf ../libgridfields.la 
 
-#selfe2netcdf_SOURCES = selfe2netcdf.cc
-#elfe2netcdf_LDADD = -lnetcdf ../libgridfields.la 
-
 testoutput_SOURCES = testoutput.cc
 testoutput_LDADD = ../libgridfields.la 
 endif
 
-if VTK_FOUND
-# testsmallrestrict_SOURCES = testsmallrestrict.cc
-# testsmallrestrict_LDADD = testsmallrestrict.cc -L$(VTKLIBPATH) \
-# 	$(VTKLIBS) ../libgridfields.la 
-
-# testsubapply_SOURCES = testsubapply.cc
-# testsubapply_LDADD = testsubapply.cc -L$(VTKLIBPATH) $(VTKLIBS) ../libgridfields.la 
-
-# testvtk_SOURCES = testvtk.cc
-# testvtk_LDADD = testvtk.o -L$(VTKLIBPATH) $(VTKLIBS) ../libgridfields.la 
-
-# wedgetest_SOURCES = wedgetest.cc
-# wedgetest_LDADD = wedgetest.o -L$(VTKLIBPATH) $(VTKLIBS) ../libgridfields.la 
-
-# testelcirc_SOURCES = testelcirc.o
-# testelcirc_LDADD = testelcirc.cc -L$(VTKLIBPATH) $(VTKLIBS) \
-# 	-L$(NETCDFLIBDIR) -lnetcdf_c++ -lnetcdf ../libgridfields.la 
-
-# testtag_SOURCES = testtag.o
-# testtag_LDADD = testtag.cc -L$(VTKLIBPATH) $(VTKLIBS) ../libgridfields.la 
-
-# testvis_SOURCES = testvis.o
-# testvis_LDADD = testvis.cc -L$(VTKLIBPATH) $(VTKLIBS) ../libgridfields.la 
-endif
-
 # io unit tests
 
 testarrayreader_SOURCES = testarrayreader.cc
 testarrayreader_LDADD = ../libgridfields.la 
 
-# testwrite63_SOURCES = testwrite63.cc
-# testwrite63_LDADD = ../libgridfields.la 
-
-# operator unit tests
-
-# testjoin_SOURCES = testjoin.cc
-# testjoin_LDADD = ../libgridfields.la 
-# LDADD originally included -lefence
-
 testcross_SOURCES = testcross.cc
 testcross_LDADD = ../libgridfields.la 
 
@@ -121,9 +78,6 @@
 testmerge_SOURCES = testmerge.cc
 testmerge_LDADD = ../libgridfields.la 
 
-# testscan_SOURCES = testscan.cc
-# testscan_LDADD = ../libgridfields.la 
-
 testbind_SOURCES = testbind.cc
 testbind_LDADD = ../libgridfields.la 
 
@@ -138,9 +92,6 @@
 testdataset_SOURCES = testdataset.cc
 testdataset_LDADD = ../libgridfields.la 
 
-# testgrid_SOURCES = testgrid.cc
-# testgrid_LDADD = ../libgridfields.la 
-
 testcellarray_SOURCES = testcellarray.cc
 testcellarray_LDADD = ../libgridfields.la 
 
@@ -150,6 +101,52 @@
 testarray_SOURCES = testarray.cc
 testarray_LDADD = ../libgridfields.la 
 
+# if VTK_FOUND
+# testsmallrestrict_SOURCES = testsmallrestrict.cc
+# testsmallrestrict_LDADD = testsmallrestrict.cc -L$(VTKLIBPATH) \
+# 	$(VTKLIBS) ../libgridfields.la 
+
+# testsubapply_SOURCES = testsubapply.cc
+# testsubapply_LDADD = testsubapply.cc -L$(VTKLIBPATH) $(VTKLIBS) ../libgridfields.la 
+
+# testvtk_SOURCES = testvtk.cc
+# testvtk_LDADD = testvtk.o -L$(VTKLIBPATH) $(VTKLIBS) ../libgridfields.la 
+
+# wedgetest_SOURCES = wedgetest.cc
+# wedgetest_LDADD = wedgetest.o -L$(VTKLIBPATH) $(VTKLIBS) ../libgridfields.la 
+
+# testelcirc_SOURCES = testelcirc.o
+# testelcirc_LDADD = testelcirc.cc -L$(VTKLIBPATH) $(VTKLIBS) \
+# 	-L$(NETCDFLIBDIR) -lnetcdf_c++ -lnetcdf ../libgridfields.la 
+
+# testtag_SOURCES = testtag.o
+# testtag_LDADD = testtag.cc -L$(VTKLIBPATH) $(VTKLIBS) ../libgridfields.la 
+
+# testvis_SOURCES = testvis.o
+# testvis_LDADD = testvis.cc -L$(VTKLIBPATH) $(VTKLIBS) ../libgridfields.la 
+# endif
+
+#selfe2netcdf_SOURCES = selfe2netcdf.cc
+#elfe2netcdf_LDADD = -lnetcdf ../libgridfields.la 
+
+#testnetcdfadaptor_SOURCES = testnetcdfadaptor.cc
+#testnetcdfadaptor_LDADD = -lnetcdf_c++ -lnetcdf ../libgridfields.la 
+
+# testwrite63_SOURCES = testwrite63.cc
+# testwrite63_LDADD = ../libgridfields.la 
+
+# operator unit tests
+
+# testjoin_SOURCES = testjoin.cc
+# testjoin_LDADD = ../libgridfields.la 
+# LDADD originally included -lefence
+
+# testscan_SOURCES = testscan.cc
+# testscan_LDADD = ../libgridfields.la 
+
+# testgrid_SOURCES = testgrid.cc
+# testgrid_LDADD = ../libgridfields.la 
+
 # testexpr : testexpr.cc expr.o tuple.o fparser.o type.o
 #	g++ -g testexpr.cc expr.o tuple.o -lwayne fparser.o -o testexpr
 
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/nested.cc gridfields/clib/tests/nested.cc
--- tag/gridfieldsclib-0.7/tests/nested.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/nested.cc	2014-05-16 22:59:46.336721748 +0200
@@ -17,6 +17,8 @@
 #include "visualize.h"
 #include "vtkGridField.h"
 
+using namespace GF;
+
 int main( int argc, char *argv[] ) {
 
   float vertscale = 20;
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/plugin.cc gridfields/clib/tests/plugin.cc
--- tag/gridfieldsclib-0.7/tests/plugin.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/plugin.cc	2014-05-16 22:59:45.910055090 +0200
@@ -17,6 +17,7 @@
 #include "corierecipes.h"
 
 using namespace std;
+using namespace GF;
 
 int main(int argc, char **argv) {
 
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/plumevol.cc gridfields/clib/tests/plumevol.cc
--- tag/gridfieldsclib-0.7/tests/plumevol.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/plumevol.cc	2014-05-16 22:59:46.326721748 +0200
@@ -1,4 +1,5 @@
 
+using namespace GF;
 
 int plumevol( GridField *H, GridField *V, const char *filename, 
               int addr, string region, string dataprod ) {
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/scalar.cc gridfields/clib/tests/scalar.cc
--- tag/gridfieldsclib-0.7/tests/scalar.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/scalar.cc	2014-05-16 22:59:46.330055081 +0200
@@ -12,6 +12,8 @@
 #include "visualize.h"
 #include "vtkGridField.h"
 
+using namespace GF;
+
 void computeColumnPositions(GridField *H,GridField*V); 
 int scalar3D( GridField *H, GridField *V, const char *filename, 
               int addr, string region, string dataprod);
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/scratch.cc gridfields/clib/tests/scratch.cc
--- tag/gridfieldsclib-0.7/tests/scratch.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/scratch.cc	2014-05-16 22:59:46.316721748 +0200
@@ -19,6 +19,7 @@
 #include "dataprods.h"
 #include "corierecipes.h"
 
+using namespace GF;
 
 int main( int argc, char *argv[] ) {
   cout << setprecision(3);
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/testaccess.cc gridfields/clib/tests/testaccess.cc
--- tag/gridfieldsclib-0.7/tests/testaccess.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/testaccess.cc	2014-05-16 22:59:45.913388423 +0200
@@ -3,6 +3,7 @@
 #include "access.h"
 
 using namespace std;
+using namespace GF;
 
 int main(int argc, char **argv) {
   
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/testaggregate.cc gridfields/clib/tests/testaggregate.cc
--- tag/gridfieldsclib-0.7/tests/testaggregate.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/testaggregate.cc	2014-05-16 22:59:46.340055081 +0200
@@ -10,6 +10,8 @@
 #include "src/project.h"
 #include "src/assignments.h"
 
+using namespace GF;
+
 Grid *makeGrid(int scale,const string name) {
   CellArray *twocells;
   CellArray *onecells;
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/testarray.cc gridfields/clib/tests/testarray.cc
--- tag/gridfieldsclib-0.7/tests/testarray.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/testarray.cc	2014-05-16 22:59:45.930055090 +0200
@@ -3,6 +3,7 @@
 #include "testarray.h"
 
 using namespace std;
+using namespace GF;
 
 int main(int argc, char **argv) {
   bool verbose = false;
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/testarray.h gridfields/clib/tests/testarray.h
--- tag/gridfieldsclib-0.7/tests/testarray.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/testarray.h	2014-05-16 22:59:46.333388415 +0200
@@ -1,6 +1,8 @@
 #ifndef _TESTARRAY_H
 #define _TESTARRAY_H
 
+using namespace GF;
+
 #include "src/array.h"
 Array *mkTestArray(string name, Type t, int size, int C=5) {
   Array *ca = new Array(name, t, size);
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/testarrayreader.cc gridfields/clib/tests/testarrayreader.cc
--- tag/gridfieldsclib-0.7/tests/testarrayreader.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/testarrayreader.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,98 +0,0 @@
-
-#include <cstdio>
-#include <cstring>
-#include <iostream>
-#include <fstream>
-#include <sstream>
-
-#include "src/array.h"
-#include "src/grid.h"
-#include "src/elcircfile.h"
-#include "src/arrayreader.h"
-#include "src/gridfield.h"
-
-// Was originally used explicitly in the code
-// "/home/workspace/ccalmr/forecasts/2003-25-RWKoo/run/1_hvel.64"
-#define TEST_DATA "data/1_flsu.61"
-
-using namespace std;
-
-Grid *makeGrid(int scale, string name);
-
-int main(int argc, char **argv) {
-
-  bool verbose = false;
-  // replace this with getopt? jhrg 9/30/11
-  if (argc == 2 && strncmp(argv[1], "-v", 2) == 0)
-    verbose = true;
-
-  try {
-    ElcircFile ef(TEST_DATA);
-    if (verbose) cout << ef.h.variable_nm << "|" << endl;
-    string nm(ef.h.variable_nm);
-    string nm2(ef.h.variable_nm);
-    if (verbose) {
-      cout << nm << endl;
-      cout << (nm == "horizontal velocity") << endl;
-      cout << (nm == string("horizontal velocity")) << endl;
-      cout << (nm == nm2) << endl;
-  
-      cout << "offset: " << ef.getVariableOffset(0, 0, 0) << endl;
-      cout << "offset: " << ef.getVariableOffset(3, 0, 0) << endl;
-    }
-    string s("u:f, v:f");
-    Scheme sch(s);
-    if (verbose) sch.print();
-    ProjectArrayReader pa(TEST_DATA, 1204616, "foo", s, "u");
-    if (verbose) pa.GetScheme().print();
-
-    return EXIT_SUCCESS;
-  }
-  catch (std::string &e) {
-    cerr << "Error: " << e << endl;
-    return EXIT_FAILURE;
-  }
-  catch (...) {
-    cerr << "Unknown Error." << endl;
-    return EXIT_FAILURE;
-  }
-}
-
-Grid *makeGrid(int scale, string name) {
-  CellArray *twocells;
-  CellArray *onecells;
-  CellArray *zerocells;
-  Grid *grid;
-  Node triangle[3];
-  Node segment[2];
-  Node node;
-
-  bool wf;
-  int i;
-  twocells = new CellArray();
-  for (i=0; i<scale/2; i++) {
-    triangle[0] = i;
-    triangle[1] = i+1;
-    triangle[2] = i+2;
-    twocells->addCellNodes(triangle, 3);
-  }
-  //twocells->print();
-  //getchar(); 
-  onecells = new CellArray();
- for (i=0; i<scale-1; i++) {
-    segment[0] = i;
-    segment[1] = i+1;
-    onecells->addCellNodes(segment, 2);
-  }
-  //onecells->print();
-  
-  //getchar(); 
-  grid = new Grid(name, 2);
-  grid->setImplicit0Cells(scale);
-  grid->setKCells(onecells, 1);
-  grid->setKCells(twocells, 2);
-  //grid->print(0);
-  //getchar();
-  printf("foo\n");
-  return grid; 
-}
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/testarrayreader.cc.in gridfields/clib/tests/testarrayreader.cc.in
--- tag/gridfieldsclib-0.7/tests/testarrayreader.cc.in	1970-01-01 01:00:00.000000000 +0100
+++ gridfields/clib/tests/testarrayreader.cc.in	2014-05-16 22:59:45.920055090 +0200
@@ -0,0 +1,99 @@
+
+#include <cstdio>
+#include <cstring>
+#include <iostream>
+#include <fstream>
+#include <sstream>
+
+#include "src/array.h"
+#include "src/grid.h"
+#include "src/elcircfile.h"
+#include "src/arrayreader.h"
+#include "src/gridfield.h"
+
+// Was originally used explicitly in the code
+// "/home/workspace/ccalmr/forecasts/2003-25-RWKoo/run/1_hvel.64"
+#define TEST_DATA "@top_srcdir@/tests/data/1_flsu.61"
+
+using namespace std;
+using namespace GF;
+
+Grid *makeGrid(int scale, string name);
+
+int main(int argc, char **argv) {
+
+  bool verbose = false;
+  // replace this with getopt? jhrg 9/30/11
+  if (argc == 2 && strncmp(argv[1], "-v", 2) == 0)
+    verbose = true;
+
+  try {
+    ElcircFile ef(TEST_DATA);
+    if (verbose) cout << ef.h.variable_nm << "|" << endl;
+    string nm(ef.h.variable_nm);
+    string nm2(ef.h.variable_nm);
+    if (verbose) {
+      cout << nm << endl;
+      cout << (nm == "horizontal velocity") << endl;
+      cout << (nm == string("horizontal velocity")) << endl;
+      cout << (nm == nm2) << endl;
+  
+      cout << "offset: " << ef.getVariableOffset(0, 0, 0) << endl;
+      cout << "offset: " << ef.getVariableOffset(3, 0, 0) << endl;
+    }
+    string s("u:f, v:f");
+    Scheme sch(s);
+    if (verbose) sch.print();
+    ProjectArrayReader pa(TEST_DATA, 1204616, "foo", s, "u");
+    if (verbose) pa.GetScheme().print();
+
+    return EXIT_SUCCESS;
+  }
+  catch (std::string &e) {
+    cerr << "Error: " << e << endl;
+    return EXIT_FAILURE;
+  }
+  catch (...) {
+    cerr << "Unknown Error." << endl;
+    return EXIT_FAILURE;
+  }
+}
+
+Grid *makeGrid(int scale, string name) {
+  CellArray *twocells;
+  CellArray *onecells;
+  CellArray *zerocells;
+  Grid *grid;
+  Node triangle[3];
+  Node segment[2];
+  Node node;
+
+  bool wf;
+  int i;
+  twocells = new CellArray();
+  for (i=0; i<scale/2; i++) {
+    triangle[0] = i;
+    triangle[1] = i+1;
+    triangle[2] = i+2;
+    twocells->addCellNodes(triangle, 3);
+  }
+  //twocells->print();
+  //getchar(); 
+  onecells = new CellArray();
+ for (i=0; i<scale-1; i++) {
+    segment[0] = i;
+    segment[1] = i+1;
+    onecells->addCellNodes(segment, 2);
+  }
+  //onecells->print();
+  
+  //getchar(); 
+  grid = new Grid(name, 2);
+  grid->setImplicit0Cells(scale);
+  grid->setKCells(onecells, 1);
+  grid->setKCells(twocells, 2);
+  //grid->print(0);
+  //getchar();
+  printf("foo\n");
+  return grid; 
+}
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/testbind.cc gridfields/clib/tests/testbind.cc
--- tag/gridfieldsclib-0.7/tests/testbind.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/testbind.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,121 +0,0 @@
-
-#include <cstdio>
-
-#include "src/grid.h"
-#include "src/gridfield.h"
-#include "src/bind.h"
-#include "src/array.h"
-#include "src/restrict.h"
-#include "src/refrestrict.h"
-#include "src/arrayreader.h"
-#include "src/accumulate.h"
-
-Grid *makeGrid(int scale, string name) {
-  CellArray *twocells;
-  CellArray *onecells;
-  CellArray *zerocells;
-  Grid *grid;
-  Node triangle[3];
-  Node segment[2];
-  Node node;
-
-  bool wf;
-  int i;
-  twocells = new CellArray();
-  for (i=0; i<scale/2; i++) {
-    triangle[0] = i;
-    triangle[1] = i+1;
-    triangle[2] = i+2;
-    twocells->addCellNodes(triangle, 3);
-  }
-  //twocells->print();
-  //getchar(); 
-  onecells = new CellArray();
-  for (i=0; i<scale-1; i++) {
-    segment[0] = i;
-    segment[1] = i+1;
-    onecells->addCellNodes(segment, 2);
-  }
-  //onecells->print();
-  
-  //getchar(); 
-  grid = new Grid(name, 2);
-  grid->setImplicit0Cells(scale);
-  grid->setKCells(onecells, 1);
-  grid->setKCells(twocells, 2);
-  //grid->print(0);
-  //getchar();
-  return grid; 
-}
-
-
-Array *makeFloatArray(int size,const char *name) {
-  Array *arr;
-  arr = new Array(name, FLOAT, size);
-  float *data;
-  arr->getData(data);
-  int i;
-
-  for (i=0; i<size; i++) {
-      data[i] = 2*i-10;
-  }
-  return arr;  
-}
-GridField *makeGridField(int size, string gridname,const char *datname, int k) {
-
-  Grid *G;
-  GridField *GF;
-  Array *data;
-  
-  G = makeGrid(12, "A");
-  k = 0;
-  data = makeFloatArray(12, "x");
-
-  GF = new GridField(G, k, data);
-  //printf("Valid? %i\n", !notValid(GF));
-  //GF->print();
-
-  return GF;
-}
-
-int main(int argc, char **argv) {
-  bool verbose = false;
-  // replace this with getopt? jhrg 9/30/11
-  if (argc == 2 && strncmp(argv[1], "-v", 2) == 0)
-    verbose = true;
-
-  try {
-    GridField *GF;
-    GridField *Result;
-
-    GF = makeGridField(12, "A", "x", 0);
-    Array *arr = new Array("io", FLOAT, 12);
-    GF->Bind(0, arr);
-
-    GridField *aGF = AccumulateOp::Accumulate(GF, 0, "result", "result+1", "0", 0);
-
-    if (verbose) aGF->print(9);
-    printf("restricting...\n");
-    Result = RefRestrictOp::Restrict("x<4",0,GF);
-    if (verbose) Result->print(0);
-    Result = RefRestrictOp::Restrict("x>-4",0,Result);
-    if (verbose) Result->print(10);
-
-    FileArrayReader *ar = new FileArrayReader("dat", 0);
-    ar->setPatternAttribute("result");
-    GridField *G = BindOp::Bind("io", FLOAT, ar, 0, Result);
- 
-    if (verbose) G->print();
-
-    return EXIT_SUCCESS;
-  }
-  catch (std::string &e) {
-    cerr << "Error: " << e << endl;
-    return EXIT_FAILURE;
-  }
-  catch (...) {
-    cerr << "Unknown Error." << endl;
-    return EXIT_FAILURE;
-  }
-}
-
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/testbind.cc.in gridfields/clib/tests/testbind.cc.in
--- tag/gridfieldsclib-0.7/tests/testbind.cc.in	1970-01-01 01:00:00.000000000 +0100
+++ gridfields/clib/tests/testbind.cc.in	2014-05-16 22:59:46.336721748 +0200
@@ -0,0 +1,125 @@
+
+#include <cstdio>
+
+#include "src/grid.h"
+#include "src/gridfield.h"
+#include "src/bind.h"
+#include "src/array.h"
+#include "src/restrict.h"
+#include "src/refrestrict.h"
+#include "src/arrayreader.h"
+#include "src/accumulate.h"
+
+using namespace GF;
+
+#define TEST_DATA "@top_srcdir@/tests/dat"
+
+Grid *makeGrid(int scale, string name) {
+  CellArray *twocells;
+  CellArray *onecells;
+  CellArray *zerocells;
+  Grid *grid;
+  Node triangle[3];
+  Node segment[2];
+  Node node;
+
+  bool wf;
+  int i;
+  twocells = new CellArray();
+  for (i=0; i<scale/2; i++) {
+    triangle[0] = i;
+    triangle[1] = i+1;
+    triangle[2] = i+2;
+    twocells->addCellNodes(triangle, 3);
+  }
+  //twocells->print();
+  //getchar(); 
+  onecells = new CellArray();
+  for (i=0; i<scale-1; i++) {
+    segment[0] = i;
+    segment[1] = i+1;
+    onecells->addCellNodes(segment, 2);
+  }
+  //onecells->print();
+  
+  //getchar(); 
+  grid = new Grid(name, 2);
+  grid->setImplicit0Cells(scale);
+  grid->setKCells(onecells, 1);
+  grid->setKCells(twocells, 2);
+  //grid->print(0);
+  //getchar();
+  return grid; 
+}
+
+
+Array *makeFloatArray(int size,const char *name) {
+  Array *arr;
+  arr = new Array(name, FLOAT, size);
+  float *data;
+  arr->getData(data);
+  int i;
+
+  for (i=0; i<size; i++) {
+      data[i] = 2*i-10;
+  }
+  return arr;  
+}
+GridField *makeGridField(int size, string gridname,const char *datname, int k) {
+
+  Grid *G;
+  GridField *GF;
+  Array *data;
+  
+  G = makeGrid(12, "A");
+  k = 0;
+  data = makeFloatArray(12, "x");
+
+  GF = new GridField(G, k, data);
+  //printf("Valid? %i\n", !notValid(GF));
+  //GF->print();
+
+  return GF;
+}
+
+int main(int argc, char **argv) {
+  bool verbose = false;
+  // replace this with getopt? jhrg 9/30/11
+  if (argc == 2 && strncmp(argv[1], "-v", 2) == 0)
+    verbose = true;
+
+  try {
+    GridField *GF;
+    GridField *Result;
+
+    GF = makeGridField(12, "A", "x", 0);
+    Array *arr = new Array("io", FLOAT, 12);
+    GF->Bind(0, arr);
+
+    GridField *aGF = AccumulateOp::Accumulate(GF, 0, "result", "result+1", "0", 0);
+
+    if (verbose) aGF->print(9);
+    printf("restricting...\n");
+    Result = RefRestrictOp::Restrict("x<4",0,GF);
+    if (verbose) Result->print(0);
+    Result = RefRestrictOp::Restrict("x>-4",0,Result);
+    if (verbose) Result->print(10);
+
+    FileArrayReader *ar = new FileArrayReader(TEST_DATA, 0);
+    ar->setPatternAttribute("result");
+    GridField *G = BindOp::Bind("io", FLOAT, ar, 0, Result);
+ 
+    if (verbose) G->print();
+
+    return EXIT_SUCCESS;
+  }
+  catch (std::string &e) {
+    cerr << "Error: " << e << endl;
+    return EXIT_FAILURE;
+  }
+  catch (...) {
+    cerr << "Unknown Error." << endl;
+    return EXIT_FAILURE;
+  }
+}
+
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/test.cc gridfields/clib/tests/test.cc
--- tag/gridfieldsclib-0.7/tests/test.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/test.cc	2014-05-16 22:59:46.333388415 +0200
@@ -3,6 +3,7 @@
 #include <string>
 
 using namespace std;
+using namespace GF;
 
 Agg::Agg(Big *b) {
   this->bigs.push_back(b);
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/testcellarray.cc gridfields/clib/tests/testcellarray.cc
--- tag/gridfieldsclib-0.7/tests/testcellarray.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/testcellarray.cc	2014-05-16 22:59:45.926721756 +0200
@@ -3,6 +3,8 @@
 #include "src/util.h"
 #include "src/implicitcrossnodemap.h"
 
+using namespace GF;
+
 int main(int argc, char **argv) {
   
   bool verbose = false;
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/testcross.cc gridfields/clib/tests/testcross.cc
--- tag/gridfieldsclib-0.7/tests/testcross.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/testcross.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,129 +0,0 @@
-
-#include <cstdio>
-#include <cstring>
-#include "src/grid.h"
-#include "src/onegrid.h"
-#include "src/gridfield.h"
-#include "src/array.h"
-#include "src/arrayreader.h"
-#include "src/cross.h"
-
-Grid *makeGrid(int scale, char *name) {
-  CellArray *twocells;
-  CellArray *onecells;
-  CellArray *zerocells;
-  Grid *grid;
-  Node triangle[3];
-  Node segment[2];
-  Node node;
-
-  bool wf;
-  int i;
-  twocells = new CellArray();
-  triangle[0] = 2;
-  triangle[1] = 0;
-  triangle[2] = 1;
-  twocells->addCellNodes(triangle, 3);
-  for (i=1; i<scale/2; i++) {
-    triangle[0] = scale-i;
-    triangle[1] = scale-1-i;
-    triangle[2] = scale-2-i;
-    twocells->addCellNodes(triangle, 3);
-  }
-
-  //twocells->print();
-  //getchar(); 
-  onecells = new CellArray();
-  for (i=0; i<scale-1; i++) {
-    segment[0] = i;
-    segment[1] = i+1;
-    onecells->addCellNodes(segment, 2);
-  }
-  //onecells->print();
-  
-  //getchar(); 
-  grid = new Grid(name, 2);
-  grid->setImplicit0Cells(scale);
-  grid->setKCells(onecells, 1);
-  grid->setKCells(twocells, 2);
-  //grid->print(0);
-  //getchar();
-  return grid; 
-}
-
-Array *makeFloatArray(int size,const char *name) {
-  Array *arr;
-  arr = new Array(name, FLOAT, size);
-  float *data;
-  arr->getData(data);
-  int i;
-
-  for (i=0; i<size; i++) {
-      data[i] = 2*i-10;
-  }
-  return arr;  
-}
-GridField *makeGridField(int size, char *gridname, char *datname, int k) {
-
-  Grid *G;
-  GridField *GF;
-  Array *data;
-  
-  G = makeGrid(size, gridname);
-  AbstractCellArray *cells = G->getKCells(k);
-  data = makeFloatArray(cells->getsize(), datname);
-
-  GF = new GridField(G, k, data);
-  //printf("Valid? %i\n", !notValid(GF));
-  //GF->print();
-
-  return GF;
-}
-
-int main(int argc, char **argv) {
-  bool verbose = false;
-
-  // replace this with getopt? jhrg 9/30/11
-  if (argc == 2 && strncmp(argv[1], "-v", 2) == 0)
-    verbose = true;
-
-
-  try {
-    GridField *Aa;
-    GridField *Bb;
-
-    if (verbose) cout << "Test 1" << endl;
-    OneGrid *A = new OneGrid("A", 3);
-    Array *a = makeFloatArray(3, "a");
-    //  GF = makeGridField(5, "A", "x", 0);
-    OneGrid *B = new OneGrid("B", 3);
-    Array *b = makeFloatArray(3, "b");
-  
-    Aa = new GridField(A, 0, a);
-    //Aa->print(3);
-    Bb = new GridField(B, 0, b);
-    //  GF2 = makeGridField(12, "A", "x", 2);
-  
-    GridField *Result = CrossOp::Cross(Aa,Bb);
-  
-    if (verbose) Result->print();
-
-    FileArrayReader *ar = new FileArrayReader("dat");    cerr << "here: "<< endl;
-    Array *arr = new Array("io", FLOAT, 3*3);
-    ar->Read(Result, 0, arr);
- 
-    if (verbose) arr->print();
-  
-    //  cout << "Test 2: Indirect Execution" << endl;
-
-    return EXIT_SUCCESS;
-  }
-  catch (std::string &e) {
-    cerr << "Error: " << e << endl;
-    return EXIT_FAILURE;
-  }
-  catch (...) {
-    cerr << "Unknown error." << endl;
-    return EXIT_FAILURE;
-  }
-}
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/testcross.cc.in gridfields/clib/tests/testcross.cc.in
--- tag/gridfieldsclib-0.7/tests/testcross.cc.in	1970-01-01 01:00:00.000000000 +0100
+++ gridfields/clib/tests/testcross.cc.in	2014-05-16 22:59:46.316721748 +0200
@@ -0,0 +1,133 @@
+
+#include <cstdio>
+#include <cstring>
+#include "src/grid.h"
+#include "src/onegrid.h"
+#include "src/gridfield.h"
+#include "src/array.h"
+#include "src/arrayreader.h"
+#include "src/cross.h"
+
+using namespace GF;
+
+#define TEST_DATA "@top_srcdir@/tests/dat"
+
+Grid *makeGrid(int scale, char *name) {
+  CellArray *twocells;
+  CellArray *onecells;
+  CellArray *zerocells;
+  Grid *grid;
+  Node triangle[3];
+  Node segment[2];
+  Node node;
+
+  bool wf;
+  int i;
+  twocells = new CellArray();
+  triangle[0] = 2;
+  triangle[1] = 0;
+  triangle[2] = 1;
+  twocells->addCellNodes(triangle, 3);
+  for (i=1; i<scale/2; i++) {
+    triangle[0] = scale-i;
+    triangle[1] = scale-1-i;
+    triangle[2] = scale-2-i;
+    twocells->addCellNodes(triangle, 3);
+  }
+
+  //twocells->print();
+  //getchar(); 
+  onecells = new CellArray();
+  for (i=0; i<scale-1; i++) {
+    segment[0] = i;
+    segment[1] = i+1;
+    onecells->addCellNodes(segment, 2);
+  }
+  //onecells->print();
+  
+  //getchar(); 
+  grid = new Grid(name, 2);
+  grid->setImplicit0Cells(scale);
+  grid->setKCells(onecells, 1);
+  grid->setKCells(twocells, 2);
+  //grid->print(0);
+  //getchar();
+  return grid; 
+}
+
+Array *makeFloatArray(int size,const char *name) {
+  Array *arr;
+  arr = new Array(name, FLOAT, size);
+  float *data;
+  arr->getData(data);
+  int i;
+
+  for (i=0; i<size; i++) {
+      data[i] = 2*i-10;
+  }
+  return arr;  
+}
+GridField *makeGridField(int size, char *gridname, char *datname, int k) {
+
+  Grid *G;
+  GridField *GF;
+  Array *data;
+  
+  G = makeGrid(size, gridname);
+  AbstractCellArray *cells = G->getKCells(k);
+  data = makeFloatArray(cells->getsize(), datname);
+
+  GF = new GridField(G, k, data);
+  //printf("Valid? %i\n", !notValid(GF));
+  //GF->print();
+
+  return GF;
+}
+
+int main(int argc, char **argv) {
+  bool verbose = false;
+
+  // replace this with getopt? jhrg 9/30/11
+  if (argc == 2 && strncmp(argv[1], "-v", 2) == 0)
+    verbose = true;
+
+
+  try {
+    GridField *Aa;
+    GridField *Bb;
+
+    if (verbose) cout << "Test 1" << endl;
+    OneGrid *A = new OneGrid("A", 3);
+    Array *a = makeFloatArray(3, "a");
+    //  GF = makeGridField(5, "A", "x", 0);
+    OneGrid *B = new OneGrid("B", 3);
+    Array *b = makeFloatArray(3, "b");
+  
+    Aa = new GridField(A, 0, a);
+    //Aa->print(3);
+    Bb = new GridField(B, 0, b);
+    //  GF2 = makeGridField(12, "A", "x", 2);
+  
+    GridField *Result = CrossOp::Cross(Aa,Bb);
+  
+    if (verbose) Result->print();
+
+    FileArrayReader *ar = new FileArrayReader(TEST_DATA);    cerr << "here: "<< endl;
+    Array *arr = new Array("io", FLOAT, 3*3);
+    ar->Read(Result, 0, arr);
+ 
+    if (verbose) arr->print();
+  
+    //  cout << "Test 2: Indirect Execution" << endl;
+
+    return EXIT_SUCCESS;
+  }
+  catch (std::string &e) {
+    cerr << "Error: " << e << endl;
+    return EXIT_FAILURE;
+  }
+  catch (...) {
+    cerr << "Unknown error." << endl;
+    return EXIT_FAILURE;
+  }
+}
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/testdataset.cc gridfields/clib/tests/testdataset.cc
--- tag/gridfieldsclib-0.7/tests/testdataset.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/testdataset.cc	2014-05-16 22:59:46.340055081 +0200
@@ -9,6 +9,7 @@
 #include "testdataset.h"
 
 using namespace std;
+using namespace GF;
 
 int main(int argc, char **argv) {
   
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/testdataset.h gridfields/clib/tests/testdataset.h
--- tag/gridfieldsclib-0.7/tests/testdataset.h	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/testdataset.h	2014-05-16 22:59:46.343388414 +0200
@@ -1,6 +1,8 @@
 #ifndef _TESTDATASET_H
 #define _TESTDATASET_H
 
+using namespace GF;
+
 #include "testarray.h"
 
 void mkTestDataset(Dataset &D, string sch, int size) {
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/testelcirc.cc gridfields/clib/tests/testelcirc.cc
--- tag/gridfieldsclib-0.7/tests/testelcirc.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/testelcirc.cc	2014-05-16 22:59:46.323388415 +0200
@@ -32,6 +32,8 @@
 #include "vtkGlyph3D.h"
 #include "vtkSphereSource.h"
 
+using namespace GF;
+
 void testTime() {
   ElcircFile ef("/home/bill/testbed/data/1_salt.63");
   GridField *T = ef.readTGrid();
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/testexpr.cc gridfields/clib/tests/testexpr.cc
--- tag/gridfieldsclib-0.7/tests/testexpr.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/testexpr.cc	2014-05-16 22:59:46.330055081 +0200
@@ -3,6 +3,7 @@
 #include "expr.h"
 
 using namespace std;
+using namespace GF;
 
 int main(int argc, char **argv) {
   TupleFunction tf;
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/testgrid.cc gridfields/clib/tests/testgrid.cc
--- tag/gridfieldsclib-0.7/tests/testgrid.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/testgrid.cc	2014-05-16 22:59:46.313388415 +0200
@@ -1,6 +1,8 @@
 #include <cstdlib>
 #include "grid.h"
 
+using namespace GF;
+
 Grid *makeGrid(int start, int stop, char *name);
 int main(int argc, char **argv) {
 
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/testgridfield.cc gridfields/clib/tests/testgridfield.cc
--- tag/gridfieldsclib-0.7/tests/testgridfield.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/testgridfield.cc	2014-05-16 22:59:46.343388414 +0200
@@ -2,6 +2,8 @@
 #include "src/gridfield.h"
 #include "src/array.h"
 
+using namespace GF;
+
 Grid *makeGrid(int scale, string name) {
   CellArray *twocells;
   CellArray *onecells;
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/testjoin.cc gridfields/clib/tests/testjoin.cc
--- tag/gridfieldsclib-0.7/tests/testjoin.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/testjoin.cc	2014-05-16 22:59:45.913388423 +0200
@@ -5,6 +5,8 @@
 #include "arrayreader.h"
 #include "join.h"
 
+using namespace GF;
+
 Grid *makeGrid(int scale, char *name) {
   CellArray *twocells;
   CellArray *onecells;
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/testmerge.cc gridfields/clib/tests/testmerge.cc
--- tag/gridfieldsclib-0.7/tests/testmerge.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/testmerge.cc	2014-05-16 22:59:45.910055090 +0200
@@ -5,6 +5,8 @@
 #include "src/merge.h"
 #include<cstring>
 
+using namespace GF;
+
 Grid *makeGrid(int scale,const char *name) {
   CellArray *twocells;
   CellArray *onecells;
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/testnest.cc gridfields/clib/tests/testnest.cc
--- tag/gridfieldsclib-0.7/tests/testnest.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/testnest.cc	2014-05-16 22:59:45.923388423 +0200
@@ -4,6 +4,8 @@
 #include "restrict.h"
 #include "merge.h"
 
+using namespace GF;
+
 Grid *makeGrid(int scale, char *name) {
   CellArray *twocells;
   CellArray *onecells;
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/testnetcdfadaptor.cc gridfields/clib/tests/testnetcdfadaptor.cc
--- tag/gridfieldsclib-0.7/tests/testnetcdfadaptor.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/testnetcdfadaptor.cc	2014-05-16 22:59:45.926721756 +0200
@@ -6,6 +6,7 @@
 #include "restrict.h"
 
 using namespace std;
+using namespace GF;
 
 int main(int argc, char **argv) {
   NetCDFAdaptor ncf("example.nc");
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/testnetcdf.cc gridfields/clib/tests/testnetcdf.cc
--- tag/gridfieldsclib-0.7/tests/testnetcdf.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/testnetcdf.cc	2014-05-16 22:59:46.326721748 +0200
@@ -5,6 +5,8 @@
 #include "src/arraywriter.h"
 #include "src/tonetcdf.h"
 
+using namespace GF;
+
 Grid *makeGrid(int scale,const char *name) {
   CellArray *twocells;
   CellArray *onecells;
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/testoutput.cc gridfields/clib/tests/testoutput.cc
--- tag/gridfieldsclib-0.7/tests/testoutput.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/testoutput.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,124 +0,0 @@
-#include "src/grid.h"
-#include "src/gridfield.h"
-#include "src/array.h"
-#include "src/arrayreader.h"
-#include "src/scaninternal.h"
-#include "src/output.h"
-#include "src/cross.h"
-#include "src/accumulate.h"
-//#include "subapply.h"
-#include "src/apply.h"
-#include "src/restrict.h"
-#include "src/bind.h"
-#include "src/project.h"
-#include "src/elcircfile.h"
-#include "src/tonetcdf.h"
-
-
-int main(int argc, char **argv) {
-
-  string filename("data/1_flsu.61");
-  string name("salt");
-  int offset = 0;
-  Type type = FLOAT;
-
-  ElcircFile ef(filename);
-  GridField *scanH = ef.readHGrid();
-  GridField *scanV = ef.readVGrid();
-  /*
-  AccumulateOp *address = new AccumulateOp(scanH, "address", "62-b+1+address", "0");
-
-  AccumulateOp *vpos = new AccumulateOp(scanV, "zpos", "zpos+1", "0");
-  RestrictOp *bath = new RestrictOp(new Condition("zpos", ">", 0), vpos);
-  BindOp *bind = new BindOp(name, type, filename, offset, "zpos", bath);
-  
-  SubApplyOp *nest = new SubApplyOp(bind, "vgrid", address);
-  //parameterize bind and test
-  sub->parameterize("address", bind, (ParameterAssigner::ParamFunc) &BindOp::setOffset);
-  sub->parameterize("b", bath, (ParameterAssigner::ParamFunc) &RestrictOp::setIntValue);
-
-  // UnNestOp *unnest = new UnNestOp();
-  // need a good grid to map to.
-  GridField *Xx = new GridField(new OneGrid(5), 0);
-  BindOp *bindx = new BindOp("datx", 0, "x", FLOAT);
-  //AccumulateOp *mkX = new AccumulateOp(Xx, "x", "x+136800", "-83000");
-  
-  GridField *Yy = new GridField(new OneGrid(5), 0);
-  BindOp *bindy = new BindOp("daty", 0, "y", FLOAT);
-  //AccumulateOp *mkY = new AccumulateOp(Yy, "y", "y+340000", "-966000");
-
-  GridField *Gg = CrossOp::Cross(mkX, mkY);
-
-  Assignments::pointpoly pp;
-  Aggregations::interpolate2D interp;
-  Aggregations::special special("vgrid");
-  */
-  /*
-   * Idea: make an aggregate function that does the right thing given 
-   * a sequence of gridfields....so, we have 3 or 4 tuples of type <x,y,GF salt>
-   * take the 3/4 tuples and loop over the gridfield, evaluating the 
-   * interpolation function on 3/4 (x,y,s) triples.
-   * Ugly, since it's all in an aggregation function, but maybe a more 
-   * general solution can be found involving parameterized aggregates.
-   * What to do with GF of varying size?  Stop when any GFs are done.
-   */
-  /*
-  //make aggregate lazy
-  AggregateOp *regrid = new AggregateOp(Gg, pp, special, nest);
-
-  vector<GridField *> vec;
-  vec.push_back(Xx);
-  vec.push_back(Yy);
-  vec.push_back(V);
-  */
-  
-  
-  //H->print();
-  //V->print();
-  OutputNetCDFOp::OutputNetCDFOp oo("temp.nc", scanH, Scheme("h:f"), Scheme("wave:f")); 
-  oo.SetDate("2004-06-24 00:00:00");
-  GridField *G = oo.getResult(); 
-
-  ApplyOp A("wave = h", 0, &oo);
-
-  oo.WriteTimeVars(&A, 0, 900.0);
-  oo.WriteTimeVars(&A, 1, 1800.0);
-
-//  ElcircFile out("temp.gf");
-//  GridField  *GF = out.readHGrid();
-/*
-  OutputElcircOp::OutputElcircOp oo("temp.gf", scanH); 
-  GridField *G = oo.getResult(); 
-  ElcircFile out("temp.gf");
-  GridField  *GF = out.readHGrid();
-*/
-/* 
-  OutputOp::OutputOp oo("temp.gf", 0, scanH); 
-  GridField *G = oo.getResult(); 
-  ScanInternal si("temp.gf", 0);
-  GridField  *GF = si.getResult();
-  GF->print();
- 
-  vector<GridField *> vec;
-  ApplyOp::Apply(V, "v2", "z");
-  
-  GridField *V1 = ProjectOp::Project(V, "z");
-  GridField *V2 = ProjectOp::Project(V, "v2");
-     
-  vec.push_back(V1); 
-  vec.push_back(V2); 
-
-  GridField *C = 
-    ProjectOp::Project(
-      AccumulateOp::Accumulate(
-       CrossOp::Cross(V1, V2)
-       , "cvals", "z*62+v2", "z*62+v2"
-      ),
-      "cvals"
-    );
-      
-  OutputOp::WriteNetCDF(vec, C);
-  */
-
-}
-
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/testoutput.cc.in gridfields/clib/tests/testoutput.cc.in
--- tag/gridfieldsclib-0.7/tests/testoutput.cc.in	1970-01-01 01:00:00.000000000 +0100
+++ gridfields/clib/tests/testoutput.cc.in	2014-05-16 22:59:45.916721757 +0200
@@ -0,0 +1,127 @@
+#include "src/grid.h"
+#include "src/gridfield.h"
+#include "src/array.h"
+#include "src/arrayreader.h"
+#include "src/scaninternal.h"
+#include "src/output.h"
+#include "src/cross.h"
+#include "src/accumulate.h"
+//#include "subapply.h"
+#include "src/apply.h"
+#include "src/restrict.h"
+#include "src/bind.h"
+#include "src/project.h"
+#include "src/elcircfile.h"
+#include "src/tonetcdf.h"
+
+using namespace GF;
+
+#define TEST_DATA "@top_srcdir@/tests/data/1_flsu.61"
+
+int main(int argc, char **argv) {
+
+  string filename(TEST_DATA);
+  string name("salt");
+  int offset = 0;
+  Type type = FLOAT;
+
+  ElcircFile ef(filename);
+  GridField *scanH = ef.readHGrid();
+  GridField *scanV = ef.readVGrid();
+  /*
+  AccumulateOp *address = new AccumulateOp(scanH, "address", "62-b+1+address", "0");
+
+  AccumulateOp *vpos = new AccumulateOp(scanV, "zpos", "zpos+1", "0");
+  RestrictOp *bath = new RestrictOp(new Condition("zpos", ">", 0), vpos);
+  BindOp *bind = new BindOp(name, type, filename, offset, "zpos", bath);
+  
+  SubApplyOp *nest = new SubApplyOp(bind, "vgrid", address);
+  //parameterize bind and test
+  sub->parameterize("address", bind, (ParameterAssigner::ParamFunc) &BindOp::setOffset);
+  sub->parameterize("b", bath, (ParameterAssigner::ParamFunc) &RestrictOp::setIntValue);
+
+  // UnNestOp *unnest = new UnNestOp();
+  // need a good grid to map to.
+  GridField *Xx = new GridField(new OneGrid(5), 0);
+  BindOp *bindx = new BindOp("datx", 0, "x", FLOAT);
+  //AccumulateOp *mkX = new AccumulateOp(Xx, "x", "x+136800", "-83000");
+  
+  GridField *Yy = new GridField(new OneGrid(5), 0);
+  BindOp *bindy = new BindOp("daty", 0, "y", FLOAT);
+  //AccumulateOp *mkY = new AccumulateOp(Yy, "y", "y+340000", "-966000");
+
+  GridField *Gg = CrossOp::Cross(mkX, mkY);
+
+  Assignments::pointpoly pp;
+  Aggregations::interpolate2D interp;
+  Aggregations::special special("vgrid");
+  */
+  /*
+   * Idea: make an aggregate function that does the right thing given 
+   * a sequence of gridfields....so, we have 3 or 4 tuples of type <x,y,GF salt>
+   * take the 3/4 tuples and loop over the gridfield, evaluating the 
+   * interpolation function on 3/4 (x,y,s) triples.
+   * Ugly, since it's all in an aggregation function, but maybe a more 
+   * general solution can be found involving parameterized aggregates.
+   * What to do with GF of varying size?  Stop when any GFs are done.
+   */
+  /*
+  //make aggregate lazy
+  AggregateOp *regrid = new AggregateOp(Gg, pp, special, nest);
+
+  vector<GridField *> vec;
+  vec.push_back(Xx);
+  vec.push_back(Yy);
+  vec.push_back(V);
+  */
+  
+  
+  //H->print();
+  //V->print();
+  OutputNetCDFOp::OutputNetCDFOp oo("temp.nc", scanH, Scheme("h:f"), Scheme("wave:f")); 
+  oo.SetDate("2004-06-24 00:00:00");
+  GridField *G = oo.getResult(); 
+
+  ApplyOp A("wave = h", 0, &oo);
+
+  oo.WriteTimeVars(&A, 0, 900.0);
+  oo.WriteTimeVars(&A, 1, 1800.0);
+
+//  ElcircFile out("temp.gf");
+//  GridField  *GF = out.readHGrid();
+/*
+  OutputElcircOp::OutputElcircOp oo("temp.gf", scanH); 
+  GridField *G = oo.getResult(); 
+  ElcircFile out("temp.gf");
+  GridField  *GF = out.readHGrid();
+*/
+/* 
+  OutputOp::OutputOp oo("temp.gf", 0, scanH); 
+  GridField *G = oo.getResult(); 
+  ScanInternal si("temp.gf", 0);
+  GridField  *GF = si.getResult();
+  GF->print();
+ 
+  vector<GridField *> vec;
+  ApplyOp::Apply(V, "v2", "z");
+  
+  GridField *V1 = ProjectOp::Project(V, "z");
+  GridField *V2 = ProjectOp::Project(V, "v2");
+     
+  vec.push_back(V1); 
+  vec.push_back(V2); 
+
+  GridField *C = 
+    ProjectOp::Project(
+      AccumulateOp::Accumulate(
+       CrossOp::Cross(V1, V2)
+       , "cvals", "z*62+v2", "z*62+v2"
+      ),
+      "cvals"
+    );
+      
+  OutputOp::WriteNetCDF(vec, C);
+  */
+
+}
+
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/testregrrid.cc gridfields/clib/tests/testregrrid.cc
--- tag/gridfieldsclib-0.7/tests/testregrrid.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/testregrrid.cc	2014-05-16 22:59:45.906721757 +0200
@@ -6,6 +6,8 @@
 #include "arrayreader.h"
 #include "apply.h"
 
+using namespace GF;
+
 Grid *makeGrid(int scale, char *name) {
   CellArray *twocells;
   CellArray *onecells;
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/testrepresent.cc gridfields/clib/tests/testrepresent.cc
--- tag/gridfieldsclib-0.7/tests/testrepresent.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/testrepresent.cc	2014-05-16 22:59:45.920055090 +0200
@@ -4,6 +4,8 @@
 #include "restrict.h"
 #include "merge.h"
 
+using namespace GF;
+
 Grid *makeGrid(int scale, char *name) {
   CellArray *twocells;
   CellArray *onecells;
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/testrestrict.cc gridfields/clib/tests/testrestrict.cc
--- tag/gridfieldsclib-0.7/tests/testrestrict.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/testrestrict.cc	2014-05-16 22:59:46.320055082 +0200
@@ -7,6 +7,8 @@
 #include "src/arrayreader.h"
 #include "src/apply.h"
 
+using namespace GF;
+
 Grid *makeGrid(int scale,const char *name) {
   CellArray *twocells;
   CellArray *onecells;
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/testscan.cc gridfields/clib/tests/testscan.cc
--- tag/gridfieldsclib-0.7/tests/testscan.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/testscan.cc	2014-05-16 22:59:46.336721748 +0200
@@ -6,6 +6,7 @@
 #include "scanvgrid.h"
 #include "scaninternal.h"
 
+using namespace GF;
 
 int main(int argc, char **argv) {
   //GridField *H = ScanHGridOp::Scan("../../../1_salt.63");
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/testsift.cc gridfields/clib/tests/testsift.cc
--- tag/gridfieldsclib-0.7/tests/testsift.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/testsift.cc	2014-05-16 22:59:45.920055090 +0200
@@ -3,6 +3,8 @@
 #include "src/array.h"
 #include "src/sift.h"
 
+using namespace GF;
+
 Grid *makeGrid(int scale,const char *name) {
   CellArray *twocells;
   CellArray *onecells;
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/testsmallrestrict.cc gridfields/clib/tests/testsmallrestrict.cc
--- tag/gridfieldsclib-0.7/tests/testsmallrestrict.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/testsmallrestrict.cc	2014-05-16 22:59:46.343388414 +0200
@@ -31,6 +31,7 @@
 #include "vtkGlyph3D.h"
 #include "vtkSphereSource.h"
 
+using namespace GF;
 
 main(int argc, char *argv[]) {
 
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/testsubapply.cc gridfields/clib/tests/testsubapply.cc
--- tag/gridfieldsclib-0.7/tests/testsubapply.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/testsubapply.cc	2014-05-16 22:59:45.913388423 +0200
@@ -7,6 +7,8 @@
 #include "accumulate.h"
 #include "bind.h"
 
+using namespace GF;
+
 Grid *makeGrid(int scale, char *name) {
   CellArray *twocells;
   CellArray *onecells;
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/testtag.cc gridfields/clib/tests/testtag.cc
--- tag/gridfieldsclib-0.7/tests/testtag.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/testtag.cc	2014-05-16 22:59:45.923388423 +0200
@@ -32,6 +32,7 @@
 #include "vtkSphereSource.h"
 
 //#include "vmon.h"
+using namespace GF;
 
 GridField *makeMesh() {
   Grid *grid;
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/testtuple.cc gridfields/clib/tests/testtuple.cc
--- tag/gridfieldsclib-0.7/tests/testtuple.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/testtuple.cc	2014-05-16 22:59:46.346721748 +0200
@@ -2,6 +2,8 @@
 #include "src/tuple.h"
 #include "src/expr.h"
 
+using namespace GF;
+
 int main(int argc, char **argv) {
 
   bool verbose = false;
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/testvis.cc gridfields/clib/tests/testvis.cc
--- tag/gridfieldsclib-0.7/tests/testvis.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/testvis.cc	2014-05-16 22:59:46.320055082 +0200
@@ -7,6 +7,8 @@
 #include "restrict.h"
 #include "elcircfile.h"
 
+using namespace GF;
+
 void testSmallRestrict() {
    ElcircFile ef("/home/workspace/ccalmr/hindcasts/2000-01-16/run/1_salt.63");
    GridField *H = ef.readHGrid();
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/testvtk.cc gridfields/clib/tests/testvtk.cc
--- tag/gridfieldsclib-0.7/tests/testvtk.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/testvtk.cc	2014-05-16 22:59:46.326721748 +0200
@@ -30,6 +30,8 @@
 void CaptureImage(vtkRenderWindow *);
 void ShowCamera(vtkRenderWindow *renWin);
 
+using namespace GF;
+
 class vtkMyCallback : public vtkCommand {
   public:
   static vtkMyCallback *New() { return new vtkMyCallback; }
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/testwrite63.cc gridfields/clib/tests/testwrite63.cc
--- tag/gridfieldsclib-0.7/tests/testwrite63.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/testwrite63.cc	2014-05-16 22:59:45.916721757 +0200
@@ -17,6 +17,7 @@
 #include <sstream>
 
 using namespace std;
+using namespace GF;
 
 int main(int argc, char **argv) {
 
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/transect.cc gridfields/clib/tests/transect.cc
--- tag/gridfieldsclib-0.7/tests/transect.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/transect.cc	2014-05-16 22:59:45.930055090 +0200
@@ -3,6 +3,8 @@
 #include "sift.h"
 #include "vtkUnstructuredGridWriter.h"
 
+using namespace GF;
+
 //defaults
 
 string filename("1_salt.63");
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/transpose.cc gridfields/clib/tests/transpose.cc
--- tag/gridfieldsclib-0.7/tests/transpose.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/transpose.cc	2014-05-16 22:59:46.333388415 +0200
@@ -17,6 +17,8 @@
 #include "visualize.h"
 #include "vtkGridField.h"
 
+using namespace GF;
+
 int main( int argc, char *argv[] ) {
 
   float vertscale = 20;
diff -Nur -x .svn tag/gridfieldsclib-0.7/tests/unopt-scalar.cc gridfields/clib/tests/unopt-scalar.cc
--- tag/gridfieldsclib-0.7/tests/unopt-scalar.cc	2012-02-13 17:47:10.000000000 +0100
+++ gridfields/clib/tests/unopt-scalar.cc	2014-05-16 22:59:46.330055081 +0200
@@ -10,6 +10,8 @@
 #include "visualize.h"
 #include "vtkGridField.h"
 
+using namespace GF;
+
 int main( int argc, char *argv[] ) {
 
   float secs;
